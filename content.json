{"meta":{"title":"求知若饥,虚心若愚。","subtitle":"","description":"","author":"Jeff Tian","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"学习笔记之git","slug":"学习笔记之git","date":"2020-04-05T11:35:38.496Z","updated":"2020-04-05T11:35:45.543Z","comments":true,"path":"2020/04/05/学习笔记之git/","link":"","permalink":"http://yoursite.com/2020/04/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bgit/","excerpt":"","text":")参考一参考二 @TOC 安装Git国内直接从官网下载比较困难，速度极慢。可以从镜像下载。下载完成后，按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后，还需要最后一步设置，在git bash中输入： 12$ git config --global user.name \"jefftian\"$ git config --global user.email \"email@163.com\" 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。创建版本库 1.选择一个合适的文件夹，比如H盘，创建一个空目录。空白处右键，选择Git bash here： 1234$ mkdir learngit$ cd learngit$ pwd/h/learngit 确保目录名（包括父目录）不包含中文。 2.通过git init命令把这个目录变成Git可以管理的仓库： 12$ git initInitialized empty Git repository in /h/learngit/.git/ 多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 至此，在我们创建的learngit文件夹中编写的文件，就可以进行版本控制了。 Git常用命令总结1.Git工作区域 工作区（Working Directory）：就是我们平时存放项目代码的地方 暂存区（Index / Stage）：暂存区是工作区用来提交更改（commit）前可以暂存工作区的变化（用于临时存放你的改动），事实上它只是一个文件，保存即将提交到文件列表信息 Git仓库（Repository）：安全存放数据的位置，这里面有你提交到所有版本的数据，受版本控制 Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。2.Git 版本提交（１）在工作目录中添加、修改文件； 12$ touch test.cpp$ vim test.cpp （２）将需要进行版本管理的文件放入暂存区域； 1$ git add test.cpp （３）将暂存区域的文件提交到git仓库。 1$ git commit -m \"描述信息\" 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)git status命令可以让我们时刻掌握仓库当前的状态 1$ git status 查看上次对 file 进行的修改：git diff file顾名思义就是查看difference，显示的格式正是Unix通用的diff格式 1$ git diff test.cpp 3.版本回退版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看，git log命令显示从最近到最远的提交日志，包含版本号（commit id）。如果嫌输出信息太多，看得眼花缭乱的，可以试试 1$ git log --pretty=oneline 当我们要把当前版本回退到上一个版本，就可以使用git reset命令,上一个版本就是==head^==，上上一个版本就是==head^^==，当然往上100个版本写100个^比较容易数不过来，所以写成==head~100==： 1$ git reset --hard head^ 如果想要回到版本回退之前的版本，可用下面的命令： 1$ git reset --hard 版本号 版本号（commit id）没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号 为了获得版本号，Git提供了一个命令git reflog用来记录你的每一次命令： 1$ git reflog 4.撤销修改 当发生下面两种情况时，想要放弃本次修改，可使用此命令： 1$ git checkout -- test.cpp 命令git checkout -- file意思就是，把 file 文件在工作区的修改全部撤销，这里有两种情况： 一种是file 自修改后还没有被放到暂存区（==commit后修改了==），现在，撤销修改就回到和版本库一模一样的状态； 一种是 file 已经添加到暂存区后，又作了修改（==add后修改了==），现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 当发生另一种情况时，想要放弃本次修改，可使用此命令： 12$ git reset head test.cpp$ git checkout -- test.cpp 这种情况是，==修改后add 了==，或者==直接 git rm==,想要放弃这种修改，即需要此命令。命令git reset head &lt;file&gt;可以把暂存区的修改撤销掉（unstage），相当于没有add git reset命令既可以回退版本，也可以把暂存区的修改删除掉。当我们用head时，表示最新的版本。 5.删除文件当我们把commit过的文件删除(rm)了，那么1.确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 12$ git rm test.txt$ git commit -m \"remove test.txt\" 2.删错了。因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 远程仓库由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C \"youremail@163.com\" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，点“Add Key”，你就应该看到已经添加的Key。 1.添加远程库1.现在GitHub上建立一个库，比如命名为learngit 。2.在本地库打开git bash，执行： 1$ git remote add origin git@github.com:jefftian666/learngit.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样，从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告，输入yes回车即可。 2.从远程库克隆从GitHub上找一个远程库，用命令git clone克隆一个本地库： 1$ git clone git@github.com:jefftian666/gitskills.git 或者 1$ git clone https://github.com/jefftian666/gitskills.git 3.fork别人的库如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： 1$ git clone git@github.com:jefftian666//bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。 4.使用码云把本地的learngit库同时关联GitHub的learngit和gitee的learngit1.删除已有的GitHub远程库： 1$ git remote rm origin 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 2.关联GitHub的远程库： 1$ git remote add github_origin git@github.com:jefftian666/learngit.git 注意，远程库的名称叫github_origin，不叫origin了。 3.关联Gitee的远程库： 1$ git remote add gitee_origin git@gitee.com:jefftian666/learngit.git 注意，远程库的名称叫gitee_origin，不叫origin了。 现在，我们用git remote -v查看远程库信息，可以看到两个远程库： 12345$ git remote -vgitee_origin git@gitee.com:jefftian666/learngit.git (fetch)gitee_origin git@gitee.com:jefftian666/learngit.git (push)github_origin git@github.com:jefftian666/learngit.git (fetch)github_origin git@github.com:jefftian666/learngit.git (push) 5.如果要推送到GitHub，使用命令： 1$ git push github_origin master 如果要推送到Gitee，使用命令： 1$ git push gitee_origin master 这样一来，我们的本地库就可以同时与多个远程库互相同步。 分支管理1.创建与合并分支Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt;或者git switch &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt;或者git switch -c &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 合并时禁用Fast forward模式，Git就会在merge时生成一个新的commit： git merge --no-ff -m &quot;merge with no-ff&quot; &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 2.bug分支当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交，并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 1$ git stash save \"储存信息\" 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： 1$ git stash list Git把stash内容存在某个地方了，但是需要恢复一下，用git stash pop，恢复的同时把stash内容也删了： 1$ git stash pop 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： 1$ git stash apply stash@&#123;0&#125; 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 1git cherry-pick &lt;commit&gt; 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。分支还没有被合并，如果删除，将丢失掉修改. 1$ git branch -D feature-vulcan 3.多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。要查看远程库的信息，用git remote： 1$ git remote 或者，用git remote -v显示更详细的信息： 1$ git remote -v 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 1.推送分支推送分支，就是把该分支上的所有==本地提交==推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 2.抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1$ git clone git@github.com:jefftian666/learngit.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： 12$ git branch* master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： 1$ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： 12345$ git add env.txt$ git commit -m \"add env\"$ git push origin dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 12345678$ cat env.txtenv$ git add env.txt$ git commit -m \"add new env\"$ git push origin dev 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： 1$ git pull ==git pull也失败了==，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 1$ git branch --set-upstream-to=origin/dev dev 再pull： 1$ git pull 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 123$ git commit -m \"fix env conflict\"$ git push origin dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示==no tracking information==，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 3.rebasegit rebase操作可以把本地未push的分叉提交历史整理成直线； git rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 标签1.创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 然后，敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了，比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： 1$ git tag v0.9 f52c633 再用命令git tag查看标签： 123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 1$ git show v0.9 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 用命令git show 可以看到说明文字： 1$ git show v0.1 2.操作标签如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag 'v0.1' (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1$ git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1$ git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 1$ git tag -d v0.9 然后，从远程删除。删除命令也是push，但是格式如下： 1$ git push origin :refs/tags/v0.9 自定义git1.配置别名 alias realname lg log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit st status co checkout ci commit br branch unstage reset HEAD last log -1 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中","categories":[],"tags":[]},{"title":"Git命令一览","slug":"Git命令一览","date":"2020-04-05T11:35:13.957Z","updated":"2020-04-05T11:35:20.990Z","comments":true,"path":"2020/04/05/Git命令一览/","link":"","permalink":"http://yoursite.com/2020/04/05/Git%E5%91%BD%E4%BB%A4%E4%B8%80%E8%A7%88/","excerpt":"","text":"Git准备工作安装 Ubuntu sudo apt-get install git Windows 下载、安装 https://git-scm.com/downloads 全局配置 git config –global user.name “Your Name” git config –global user.email “email@example.com“ 创建版本库 初始化一个Git仓库 git init 添加文件到Git仓库 git add git commit -m “message” 版本控制版本回退 查看提交历史 git log 在版本的历史之间穿梭 git reset –hard commit_id 重返未来 查看历史命令 git reflog 工作区、暂存区撤销修改 改乱了工作区某文件，想直接丢弃工作区的修改 git checkout – file 改乱了工作区某文件，还添加到了暂存区时，想丢弃修改 git reset HEAD git checkout – file 已经提交了不合适的修改到版本库时，想要撤销本次提交 删除文件 删除工作区文件 rm 删除暂存区文件 git rm 提交删除 git commit -m “remove file” 远程仓库添加远程github库 在github上建立一个库 关联远程库 git remote add origin git@github.com:account-name/repo-name.git 首次 推送 git push -u origin master 常规推送 git push origin master 从远程库克隆 ssh git clone git@github.com:account-name/repo-name.git https git clone https://github.com/account-name/repo-name.git 使用GitHub 在GitHub上，可以任意Fork开源仓库 自己拥有Fork后的仓库的读写权限 可以推送pull request给官方仓库来贡献代码 使用gitee远程库 在码云上建立一个库 查看远程库信息 git remote -v 删除已有的GitHub远程库 git remote rm origin 关联码云的远程库 git remote add origin git@gitee.com:account-name/repo-name.git 同时关联github和码云 git remote add hub_origin git@github.com:account-name/repo-name.git git remote add ee_origin git@gitee.com:account-name/repo-name.git 分支管理创建、合并 查看分支 git branch 创建分支 git branch 切换分支 git checkout 或者git switch 创建+切换 git checkout -b 或者git switch -c 合并某分支到当前分支 git merge 删除分支 git branch -d 解决冲突 冲突：master分支和feature1分支各自都对同一个文件分别有新的提交 在后提交的分支上手动修改冲突文件 再git add 、git commit 分支管理策略 再merge分支时，生成一个commit git merge –no-ff -m “merge with no-ff” dev master分支、发布新版本、不干活 dev分支干活 完事后merge到master 团队合作时，每个人都往dev分支上合并 bug分支 修复bug时，创建新的bug分支进行修复，然后合并，最后删除 当手头工作没有完成时，先把工作现场git stash 修复bug后，再git stash pop 在master分支上修复的bug，想要合并到当前dev分支 git cherry-pick feature分支 开发一个新feature，最好新建一个分支 丢弃未合并过的分支 git branch -D 多人协作 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交 在本地创建和远程分支对应的分支 git checkout -b branch-name origin/branch-name 建立本地分支和远程分支的关联 git branch –set-upstream branch-name origin/branch-name 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 rebase rebase操作可以把本地未push的分叉提交历史整理成直线 使得查看历史提交的变化时更容易 标签管理创建标签 新建一个标签，默认为HEAD git tag 为指定commit id新建标签 git tag 指定标签信息 git tag -a -m “blablabla…” 查看说明文字 git show 查看所有标签 git tag 查看指定标签 git tag 操作标签 推送一个本地标签 git push origin 推送全部未推送过的本地标签 git push origin –tags 删除一个本地标签 git tag -d 删除一个远程标签 git push origin :refs/tags/ 自定义忽略特殊文件配置别名 alias realname lg log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit st status co checkout ci commit br branch unstage reset HEAD last log -1 搭建git服务器","categories":[],"tags":[]},{"title":"PS 抠图去白边","slug":"PS 抠图去白边","date":"2020-04-05T08:59:52.484Z","updated":"2020-04-05T08:59:59.536Z","comments":true,"path":"2020/04/05/PS 抠图去白边/","link":"","permalink":"http://yoursite.com/2020/04/05/PS%20%E6%8A%A0%E5%9B%BE%E5%8E%BB%E7%99%BD%E8%BE%B9/","excerpt":"","text":"1. 选区缩像素 按住Ctrl键，点击人物层缩略图，为人物建立选区； 点击“选择”→“修改”→“收缩”，将收缩量调整为“2像素”，将选区收缩2像素 按住Ctrl+Shift+I 反选选区，按下Delete键删除，就能完美地去除白边了。 按Ctrl+D取消选区。 2. 滤镜处理法 按住Ctrl键，点击人物层缩略图，为人物建立选区； 点击“图层”》“图层蒙版”》“显示选区”，为人物层添加图层蒙版； 3. 点击“滤镜”→“其他”→“最小值”，根据画面效果调整“最小值”，将保留值修改为“圆度”，最后直到白边消失即可；4. 3. 利用“选择并遮住” 按住Ctrl键，点击人物层缩略图，为人物建立选区； 点击“选择”→“选择并遮住（调整边缘）”； 首先勾选“智能半径”、“净化颜色”，然后分别调整“半径值”、“移动边缘”、“羽化值”（净化颜色数量直接保持默认即可）三个选项，直到白边消失为止，同样也能很好地消除白边；","categories":[],"tags":[]},{"title":"PS 抠人像方法","slug":"PS 抠人像方法","date":"2020-04-05T08:48:06.271Z","updated":"2020-04-05T08:48:13.412Z","comments":true,"path":"2020/04/05/PS 抠人像方法/","link":"","permalink":"http://yoursite.com/2020/04/05/PS%20%E6%8A%A0%E4%BA%BA%E5%83%8F%E6%96%B9%E6%B3%95/","excerpt":"","text":"快速选择工具抠图在精度要求不高的图像上面，这两个是非常快速的抠图方法。使用这两个输出选区时建议配合“调整边缘”，否则毛刺会比较严重。调整边缘后，输出带蒙版的图层，利用 Alt+Delete 给选区填充前景色 Ctrl+Delete 给选区填充背景色给魔棒工具选区填充黑色或白色，可以进一步处理图片。 通道抠图通道抠图适用于扣取边缘复杂的对象，如树枝、毛发等；还可以扣取半透明的对象，如烟、火、水等。本质是通过通道生成选区。 1、ctrl+J复制一层（这是好习惯哦）。 2、调出右下角工具栏里的“通道”，选择反差对比最明显的一种模颜色式，也就是说人像要着重抠的地方（头发）最深、背景最浅的模式。这张图片在红色通道下面对比最明显，所以我们就选择用绿色通道。拷贝绿色通道，得到“绿副本”。 3、点击左上方工具栏，通过 图像——调整——色阶 ，使用左侧滴管为目标设置黑场，为背景设置白场。目的是目标抠图为黑色，其余背景为白色。色阶调整结果：4、使用画笔工具将背景中的黑色部分涂为白色。[为缩小画笔，]为放大画笔。按住Alt+鼠标右键上下拖动，可以更改画笔硬度。5.Ctrl+鼠标单击人物缩略图，载入选区，然后Ctrl+shift+i反选。回到图层区，Ctrl+J复制图层（复制图层也可以用增加蒙版替代，蒙版可以用黑色和白色画笔调整）。头发部分抠图完成。其余部分可以用钢笔完成。 钢笔抠图1.选择钢笔工具，勾勒大致轮廓。然后Ctrl+Enter生成选区。Ctrl+J复制图层。主要抠取通道抠图缺失的部分。2.Ctrl+E合并通道和钢笔抠好的图。抠图完成。","categories":[],"tags":[]},{"title":"视觉slam十四讲（第二版）代码学习(ch２_5)","slug":"视觉slam十四讲（第二版）代码学习(ch２_5)","date":"2020-04-04T13:10:06.396Z","updated":"2020-04-04T13:36:48.608Z","comments":true,"path":"2020/04/04/视觉slam十四讲（第二版）代码学习(ch２_5)/","link":"","permalink":"http://yoursite.com/2020/04/04/%E8%A7%86%E8%A7%89slam%E5%8D%81%E5%9B%9B%E8%AE%B2%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%89%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0(ch%EF%BC%92_5)/","excerpt":"","text":"@TOC CMakeLists.txt常用语法： 单文件的情况： 123456789101112# 声明要求的 cmake 最低版本cmake_minimum_required( VERSION 2.8 )# 声明一个 cmake 工程project( HelloSLAM )# 设置编译模式#Release 模式生成的可执行文件小，但不能断点调试；Debug模式，正好相反set( CMAKE_BUILD_TYPE \"Debug\" ) set(CMAKE_CXX_FLAGS \"-std=c++11\")# 把main函数文件 编译为可执行文件# 如果是分文件编写的话，把.h和.cpp都写在括号里就行了add_executable( useHello useHello.cpp ) 需要自己写一个库的情况：1234567# 生成一个共享库文件 libhello.so#这个库的头文件是在main文件中包含的：＃include\"libHelloSLAM.h\"add_library( hello SHARED libHelloSLAM.cpp ) # 把main函数文件 编译为可执行文件add_executable( useHello useHello.cpp )# 把可执行文件和库文件连接起来target_link_libraries( useHello hello ) 使用第三方库的情况：12345678910111213141516# 如果知道第三方库的位置，可以直接包含其绝对路径，以简便ｃｐｐ文件中的＃ｉｎｃｌｕｄｅ“”# 添加Eigen头文件include_directories( \"/usr/include/eigen3\" )#------------------------------------------------------#find_package 命令是 cmake 提供的寻找某个库的头文件与库文件的指令。如果 cmake能够找到它，就会提供头文件和库文件所在的目录的变量。# 添加Pangolin依赖find_package( Pangolin )include_directories( $&#123;Pangolin_INCLUDE_DIRS&#125; )add_executable( visualizeGeometry visualizeGeometry.cpp )target_link_libraries( visualizeGeometry $&#123;Pangolin_LIBRARIES&#125; )#-----------------------------------------------------# 在 Sophus 这个例子中，就是Sophus_INCLUDE_DIRS 和 Sophus_LIBRARIES 这两个变量。根据它们，我们就能将Sophus 库引入自己的 cmake 工程了。find_package( Sophus REQUIRED )include_directories( $&#123;Sophus_INCLUDE_DIRS&#125; )add_executable( useSophus useSophus.cpp )target_link_libraries( useSophus $&#123;Sophus_LIBRARIES&#125; ) find_package()分为module模式（基础模式）、config模式（高级模式）。 module模式中的关键字： version和EXACT 都是可选的，version指定的是版本，如果指定就必须检查找到的包的版本是否和version兼容。如果指定EXACT则表示必须完全匹配的版本而不是兼容版本就可以。 QUIET 可选字段，表示如果查找失败，不会在屏幕进行输出（但是如果指定了REQUIRED字段，则QUIET无效，仍然会输出查找失败提示语）。 MODULE 可选字段。前面提到说“如果Module模式查找失败则回退到Config模式进行查找”，但是假如设定了MODULE选项，那么就只在Module模式查找，如果Module模式下查找失败并不回落到Config模式查找。 REQUIRED可选字段。表示一定要找到包，找不到的话就立即停掉整个cmake。而如果不指定REQUIRED则cmake会继续执行。 COMPONENTS，components:可选字段，表示查找的包中必须要找到的组件(components），如果有任何一个找不到就算失败，类似于REQUIRED，导致cmake停止执行。 OPTIONAL_COMPONENTS：可选的模块，找不到也不会让cmake停止执行。 初识SLAMg++的使用安装g++: 1$ sudo apt-get install g++ 使用g++编译cpp程序，生成可执行文件a.out ： 12g++ helloSLAM.cpp -o a.out./a.out #执行 a.out cmake的使用方法：1234$ mkdir build$ cd build$ cmake ..$ make 三维空间刚体运动Eigen是一个 C++ 开源线性代数库。安装eigen: 1$ sudo apt-get install libeigen3-dev 它的默认位置在/usr/include/eigen3/中。如果你不确定，可以输入 12$ sudo updatedb$ locate eigen 来查找它的位置。 eigenMatrix这个例程演示了 Eigen 矩阵的基本操作与运算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;using namespace std;#include &lt;ctime&gt;// Eigen 核心部分#include &lt;Eigen/Core&gt;// 稠密矩阵的代数运算（逆，特征值等）#include &lt;Eigen/Dense&gt;using namespace Eigen;#define MATRIX_SIZE 50/***************************** 本程序演示了 Eigen 基本类型的使用****************************/int main(int argc, char **argv) &#123; // Eigen 中所有向量和矩阵都是Eigen::Matrix，它是一个模板类。它的前三个参数为：数据类型，行，列 // 声明一个2*3的float矩阵 Matrix&lt;float, 2, 3&gt; matrix_23; // 同时，Eigen 通过 typedef 提供了许多内置类型，不过底层仍是Eigen::Matrix // 例如 Vector3d 实质上是 Eigen::Matrix&lt;double, 3, 1&gt;，即三维向量 Vector3d v_3d; // 这是一样的 Matrix&lt;float, 3, 1&gt; vd_3d; // Matrix3d 实质上是 Eigen::Matrix&lt;double, 3, 3&gt; Matrix3d matrix_33 = Matrix3d::Zero(); //初始化为零 // 如果不确定矩阵大小，可以使用动态大小的矩阵 Matrix&lt;double, Dynamic, Dynamic&gt; matrix_dynamic; // 更简单的 MatrixXd matrix_x; // 这种类型还有很多，我们不一一列举 // 下面是对Eigen阵的操作 // 输入数据（初始化） matrix_23 &lt;&lt; 1, 2, 3, 4, 5, 6; // 输出 cout &lt;&lt; \"matrix 2x3 from 1 to 6: \\n\" &lt;&lt; matrix_23 &lt;&lt; endl; // 用()访问矩阵中的元素 cout &lt;&lt; \"print matrix 2x3: \" &lt;&lt; endl; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) cout &lt;&lt; matrix_23(i, j) &lt;&lt; \"\\t\"; cout &lt;&lt; endl; &#125; // 矩阵和向量相乘（实际上仍是矩阵和矩阵） v_3d &lt;&lt; 3, 2, 1; vd_3d &lt;&lt; 4, 5, 6; // 但是在Eigen里你不能混合两种不同类型的矩阵，像这样是错的 // Matrix&lt;double, 2, 1&gt; result_wrong_type = matrix_23 * v_3d; // 应该显式转换 Matrix&lt;double, 2, 1&gt; result = matrix_23.cast&lt;double&gt;() * v_3d; cout &lt;&lt; \"[1,2,3;4,5,6]*[3,2,1]=\" &lt;&lt; result.transpose() &lt;&lt; endl; Matrix&lt;float, 2, 1&gt; result2 = matrix_23 * vd_3d; cout &lt;&lt; \"[1,2,3;4,5,6]*[4,5,6]: \" &lt;&lt; result2.transpose() &lt;&lt; endl; // 同样你不能搞错矩阵的维度 // 试着取消下面的注释，看看Eigen会报什么错 // Eigen::Matrix&lt;double, 2, 3&gt; result_wrong_dimension = matrix_23.cast&lt;double&gt;() * v_3d; // 一些矩阵运算 // 四则运算就不演示了，直接用+-*/即可。 matrix_33 = Matrix3d::Random(); // 随机数矩阵 cout &lt;&lt; \"random matrix: \\n\" &lt;&lt; matrix_33 &lt;&lt; endl; cout &lt;&lt; \"transpose: \\n\" &lt;&lt; matrix_33.transpose() &lt;&lt; endl; // 转置 cout &lt;&lt; \"sum: \" &lt;&lt; matrix_33.sum() &lt;&lt; endl; // 各元素和 cout &lt;&lt; \"trace: \" &lt;&lt; matrix_33.trace() &lt;&lt; endl; // 迹 cout &lt;&lt; \"times 10: \\n\" &lt;&lt; 10 * matrix_33 &lt;&lt; endl; // 数乘 cout &lt;&lt; \"inverse: \\n\" &lt;&lt; matrix_33.inverse() &lt;&lt; endl; // 逆 cout &lt;&lt; \"det: \" &lt;&lt; matrix_33.determinant() &lt;&lt; endl; // 行列式 // 特征值 // 实对称矩阵可以保证对角化成功 SelfAdjointEigenSolver&lt;Matrix3d&gt; eigen_solver(matrix_33.transpose() * matrix_33); cout &lt;&lt; \"Eigen values = \\n\" &lt;&lt; eigen_solver.eigenvalues() &lt;&lt; endl; cout &lt;&lt; \"Eigen vectors = \\n\" &lt;&lt; eigen_solver.eigenvectors() &lt;&lt; endl; // 解方程 // 我们求解 matrix_NN * x = v_Nd 这个方程 // N的大小在前边的宏里定义，它由随机数生成 // 直接求逆自然是最直接的，但是求逆运算量大 Matrix&lt;double, MATRIX_SIZE, MATRIX_SIZE&gt; matrix_NN = MatrixXd::Random(MATRIX_SIZE, MATRIX_SIZE); matrix_NN = matrix_NN * matrix_NN.transpose(); // 保证半正定 Matrix&lt;double, MATRIX_SIZE, 1&gt; v_Nd = MatrixXd::Random(MATRIX_SIZE, 1); clock_t time_stt = clock(); // 计时 // 直接求逆 Matrix&lt;double, MATRIX_SIZE, 1&gt; x = matrix_NN.inverse() * v_Nd; cout &lt;&lt; \"time of normal inverse is \" &lt;&lt; 1000 * (clock() - time_stt) / (double) CLOCKS_PER_SEC &lt;&lt; \"ms\" &lt;&lt; endl; cout &lt;&lt; \"x = \" &lt;&lt; x.transpose() &lt;&lt; endl; // 通常用矩阵分解来求，例如QR分解，速度会快很多 time_stt = clock(); x = matrix_NN.colPivHouseholderQr().solve(v_Nd); cout &lt;&lt; \"time of Qr decomposition is \" &lt;&lt; 1000 * (clock() - time_stt) / (double) CLOCKS_PER_SEC &lt;&lt; \"ms\" &lt;&lt; endl; cout &lt;&lt; \"x = \" &lt;&lt; x.transpose() &lt;&lt; endl; // 对于正定矩阵，还可以用cholesky分解来解方程 time_stt = clock(); x = matrix_NN.ldlt().solve(v_Nd); cout &lt;&lt; \"time of ldlt decomposition is \" &lt;&lt; 1000 * (clock() - time_stt) / (double) CLOCKS_PER_SEC &lt;&lt; \"ms\" &lt;&lt; endl; cout &lt;&lt; \"x = \" &lt;&lt; x.transpose() &lt;&lt; endl; return 0;&#125; eigenGeometry本程序演示了 Eigen 几何模块的使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;using namespace Eigen;// 本程序演示了 Eigen 几何模块的使用方法int main(int argc, char **argv) &#123; // Eigen/Geometry 模块提供了各种旋转和平移的表示 // 3D 旋转矩阵直接使用 Matrix3d 或 Matrix3f Matrix3d rotation_matrix = Matrix3d::Identity(); // 旋转向量使用 AngleAxis, 它底层不直接是Matrix，但运算可以当作矩阵（因为重载了运算符） AngleAxisd rotation_vector(M_PI / 4, Vector3d(0, 0, 1)); //沿 Z 轴旋转 45 度 cout.precision(3); cout &lt;&lt; \"rotation matrix =\\n\" &lt;&lt; rotation_vector.matrix() &lt;&lt; endl; //用matrix()转换成矩阵 // 也可以直接赋值 rotation_matrix = rotation_vector.toRotationMatrix(); // 用 AngleAxis 可以进行坐标变换 Vector3d v(1, 0, 0); Vector3d v_rotated = rotation_vector * v; cout &lt;&lt; \"(1,0,0) after rotation (by angle axis) = \" &lt;&lt; v_rotated.transpose() &lt;&lt; endl; // 或者用旋转矩阵 v_rotated = rotation_matrix * v; cout &lt;&lt; \"(1,0,0) after rotation (by matrix) = \" &lt;&lt; v_rotated.transpose() &lt;&lt; endl; // 欧拉角: 可以将旋转矩阵直接转换成欧拉角 Vector3d euler_angles = rotation_matrix.eulerAngles(2, 1, 0); // ZYX顺序，即roll pitch yaw顺序 cout &lt;&lt; \"yaw pitch roll = \" &lt;&lt; euler_angles.transpose() &lt;&lt; endl; // 欧氏变换矩阵使用 Eigen::Isometry Isometry3d T = Isometry3d::Identity(); // 虽然称为3d，实质上是4＊4的矩阵 T.rotate(rotation_vector); // 按照rotation_vector进行旋转 T.pretranslate(Vector3d(1, 3, 4)); // 把平移向量设成(1,3,4) cout &lt;&lt; \"Transform matrix = \\n\" &lt;&lt; T.matrix() &lt;&lt; endl; // 用变换矩阵进行坐标变换 Vector3d v_transformed = T * v; // 相当于R*v+t cout &lt;&lt; \"v tranformed = \" &lt;&lt; v_transformed.transpose() &lt;&lt; endl; // 对于仿射和射影变换，使用 Eigen::Affine3d 和 Eigen::Projective3d 即可，略 // 四元数 // 可以直接把AngleAxis赋值给四元数，反之亦然 Quaterniond q = Quaterniond(rotation_vector); cout &lt;&lt; \"quaternion from rotation vector = \" &lt;&lt; q.coeffs().transpose() &lt;&lt; endl; // 请注意coeffs的顺序是(x,y,z,w),w为实部，前三者为虚部 // 也可以把旋转矩阵赋给它 q = Quaterniond(rotation_matrix); cout &lt;&lt; \"quaternion from rotation matrix = \" &lt;&lt; q.coeffs().transpose() &lt;&lt; endl; // 使用四元数旋转一个向量，使用重载的乘法即可 v_rotated = q * v; // 注意数学上是qvq^&#123;-1&#125; cout &lt;&lt; \"(1,0,0) after rotation = \" &lt;&lt; v_rotated.transpose() &lt;&lt; endl; // 用常规向量乘法表示，则应该如下计算 cout &lt;&lt; \"should be equal to \" &lt;&lt; (q * Quaterniond(0, 1, 0, 0) * q.inverse()).coeffs().transpose() &lt;&lt; endl; return 0;&#125; visualizeGeometry通过一个窗口展示数据变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;using namespace Eigen;#include &lt;pangolin/pangolin.h&gt;struct RotationMatrix &#123; Matrix3d matrix = Matrix3d::Identity();&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const RotationMatrix &amp;r) &#123; out.setf(ios::fixed); Matrix3d matrix = r.matrix; out &lt;&lt; '='; out &lt;&lt; \"[\" &lt;&lt; setprecision(2) &lt;&lt; matrix(0, 0) &lt;&lt; \",\" &lt;&lt; matrix(0, 1) &lt;&lt; \",\" &lt;&lt; matrix(0, 2) &lt;&lt; \"],\" &lt;&lt; \"[\" &lt;&lt; matrix(1, 0) &lt;&lt; \",\" &lt;&lt; matrix(1, 1) &lt;&lt; \",\" &lt;&lt; matrix(1, 2) &lt;&lt; \"],\" &lt;&lt; \"[\" &lt;&lt; matrix(2, 0) &lt;&lt; \",\" &lt;&lt; matrix(2, 1) &lt;&lt; \",\" &lt;&lt; matrix(2, 2) &lt;&lt; \"]\"; return out;&#125;istream &amp;operator&gt;&gt;(istream &amp;in, RotationMatrix &amp;r) &#123; return in;&#125;struct TranslationVector &#123; Vector3d trans = Vector3d(0, 0, 0);&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const TranslationVector &amp;t) &#123; out &lt;&lt; \"=[\" &lt;&lt; t.trans(0) &lt;&lt; ',' &lt;&lt; t.trans(1) &lt;&lt; ',' &lt;&lt; t.trans(2) &lt;&lt; \"]\"; return out;&#125;istream &amp;operator&gt;&gt;(istream &amp;in, TranslationVector &amp;t) &#123; return in;&#125;struct QuaternionDraw &#123; Quaterniond q;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const QuaternionDraw quat) &#123; auto c = quat.q.coeffs(); out &lt;&lt; \"=[\" &lt;&lt; c[0] &lt;&lt; \",\" &lt;&lt; c[1] &lt;&lt; \",\" &lt;&lt; c[2] &lt;&lt; \",\" &lt;&lt; c[3] &lt;&lt; \"]\"; return out;&#125;istream &amp;operator&gt;&gt;(istream &amp;in, const QuaternionDraw quat) &#123; return in;&#125;int main(int argc, char **argv) &#123; pangolin::CreateWindowAndBind(\"visualize geometry\", 1000, 600); glEnable(GL_DEPTH_TEST); pangolin::OpenGlRenderState s_cam( pangolin::ProjectionMatrix(1000, 600, 420, 420, 500, 300, 0.1, 1000), pangolin::ModelViewLookAt(3, 3, 3, 0, 0, 0, pangolin::AxisY) ); const int UI_WIDTH = 500; pangolin::View &amp;d_cam = pangolin::CreateDisplay(). SetBounds(0.0, 1.0, pangolin::Attach::Pix(UI_WIDTH), 1.0, -1000.0f / 600.0f). SetHandler(new pangolin::Handler3D(s_cam)); // ui pangolin::Var&lt;RotationMatrix&gt; rotation_matrix(\"ui.R\", RotationMatrix()); pangolin::Var&lt;TranslationVector&gt; translation_vector(\"ui.t\", TranslationVector()); pangolin::Var&lt;TranslationVector&gt; euler_angles(\"ui.rpy\", TranslationVector()); pangolin::Var&lt;QuaternionDraw&gt; quaternion(\"ui.q\", QuaternionDraw()); pangolin::CreatePanel(\"ui\").SetBounds(0.0, 1.0, 0.0, pangolin::Attach::Pix(UI_WIDTH)); while (!pangolin::ShouldQuit()) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); d_cam.Activate(s_cam); pangolin::OpenGlMatrix matrix = s_cam.GetModelViewMatrix(); Matrix&lt;double, 4, 4&gt; m = matrix; RotationMatrix R; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) R.matrix(i, j) = m(j, i); rotation_matrix = R; TranslationVector t; t.trans = Vector3d(m(0, 3), m(1, 3), m(2, 3)); t.trans = -R.matrix * t.trans; translation_vector = t; TranslationVector euler; euler.trans = R.matrix.eulerAngles(2, 1, 0); euler_angles = euler; QuaternionDraw quat; quat.q = Quaterniond(R.matrix); quaternion = quat; glColor3f(1.0, 1.0, 1.0); pangolin::glDrawColouredCube(); // draw the original axis glLineWidth(3); glColor3f(0.8f, 0.f, 0.f); glBegin(GL_LINES); glVertex3f(0, 0, 0); glVertex3f(10, 0, 0); glColor3f(0.f, 0.8f, 0.f); glVertex3f(0, 0, 0); glVertex3f(0, 10, 0); glColor3f(0.2f, 0.2f, 1.f); glVertex3f(0, 0, 0); glVertex3f(0, 0, 10); glEnd(); pangolin::FinishFrame(); &#125;&#125; coordinaeTransform点在不同坐标系间的转换 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;using namespace std;using namespace Eigen;int main(int argc, char** argv) &#123; Quaterniond q1(0.35, 0.2, 0.3, 0.1), q2(-0.5, 0.4, -0.1, 0.2); q1.normalize(); q2.normalize(); Vector3d t1(0.3, 0.1, 0.1), t2(-0.1, 0.5, 0.3); Vector3d p1(0.5, 0, 0.2); //用四元数ｑ和平移向量ｔ初始化变换矩阵Ｔ Isometry3d T1w(q1), T2w(q2); T1w.pretranslate(t1); T2w.pretranslate(t2); //p1乘T1w的逆是把p1转换到世界坐标系，再乘Ｔ２ｗ，即转换到T2w坐标系 Vector3d p2 = T2w * T1w.inverse() * p1; cout &lt;&lt; endl &lt;&lt; p2.transpose() &lt;&lt; endl; return 0;&#125; plotTrajectory本例演示了如何画出一个预先存储的轨迹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;pangolin/pangolin.h&gt;#include &lt;Eigen/Core&gt;#include &lt;unistd.h&gt;// 本例演示了如何画出一个预先存储的轨迹using namespace std;using namespace Eigen;// path to trajectory filestring trajectory_file = \"../trajectory.txt\";void DrawTrajectory(vector&lt;Isometry3d, Eigen::aligned_allocator&lt;Isometry3d&gt;&gt;);int main(int argc, char **argv) &#123; vector&lt;Isometry3d, Eigen::aligned_allocator&lt;Isometry3d&gt; &gt; poses; ifstream fin(trajectory_file); if (!fin) &#123; cout &lt;&lt; \"cannot find trajectory file at \" &lt;&lt; trajectory_file &lt;&lt; endl; return 1; &#125; while (!fin.eof()) &#123; double time, tx, ty, tz, qx, qy, qz, qw; fin &gt;&gt; time &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz &gt;&gt; qx &gt;&gt; qy &gt;&gt; qz &gt;&gt; qw; Isometry3d Twr(Quaterniond(qw, qx, qy, qz)); Twr.pretranslate(Vector3d(tx, ty, tz)); poses.push_back(Twr); &#125; cout &lt;&lt; \"read total \" &lt;&lt; poses.size() &lt;&lt; \" pose entries\" &lt;&lt; endl; // draw trajectory in pangolin DrawTrajectory(poses); return 0;&#125;/*******************************************************************************************/void DrawTrajectory(vector&lt;Isometry3d, Eigen::aligned_allocator&lt;Isometry3d&gt;&gt; poses) &#123; // create pangolin window and plot the trajectory pangolin::CreateWindowAndBind(\"Trajectory Viewer\", 1024, 768); glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); pangolin::OpenGlRenderState s_cam( pangolin::ProjectionMatrix(1024, 768, 500, 500, 512, 389, 0.1, 1000), pangolin::ModelViewLookAt(0, -0.1, -1.8, 0, 0, 0, 0.0, -1.0, 0.0) ); pangolin::View &amp;d_cam = pangolin::CreateDisplay() .SetBounds(0.0, 1.0, 0.0, 1.0, -1024.0f / 768.0f) .SetHandler(new pangolin::Handler3D(s_cam)); while (pangolin::ShouldQuit() == false) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); d_cam.Activate(s_cam); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glLineWidth(2); for (size_t i = 0; i &lt; poses.size(); i++) &#123; // 画每个位姿的三个坐标轴 Vector3d Ow = poses[i].translation(); Vector3d Xw = poses[i] * (0.1 * Vector3d(1, 0, 0)); Vector3d Yw = poses[i] * (0.1 * Vector3d(0, 1, 0)); Vector3d Zw = poses[i] * (0.1 * Vector3d(0, 0, 1)); glBegin(GL_LINES); glColor3f(1.0, 0.0, 0.0); glVertex3d(Ow[0], Ow[1], Ow[2]); glVertex3d(Xw[0], Xw[1], Xw[2]); glColor3f(0.0, 1.0, 0.0); glVertex3d(Ow[0], Ow[1], Ow[2]); glVertex3d(Yw[0], Yw[1], Yw[2]); glColor3f(0.0, 0.0, 1.0); glVertex3d(Ow[0], Ow[1], Ow[2]); glVertex3d(Zw[0], Zw[1], Zw[2]); glEnd(); &#125; // 画出连线 for (size_t i = 0; i &lt; poses.size(); i++) &#123; glColor3f(0.0, 0.0, 0.0); glBegin(GL_LINES); auto p1 = poses[i], p2 = poses[i + 1]; glVertex3d(p1.translation()[0], p1.translation()[1], p1.translation()[2]); glVertex3d(p2.translation()[0], p2.translation()[1], p2.translation()[2]); glEnd(); &#125; pangolin::FinishFrame(); usleep(5000); // sleep 5 ms &#125;&#125; 李群、李代数useSophus本程序演示sophus的基本用法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Geometry&gt;#include \"sophus/se3.hpp\"using namespace std;using namespace Eigen;/// 本程序演示sophus的基本用法int main(int argc, char **argv) &#123; // 沿Z轴转90度的旋转矩阵 Matrix3d R = AngleAxisd(M_PI / 2, Vector3d(0, 0, 1)).toRotationMatrix(); // 或者四元数 Quaterniond q(R); Sophus::SO3d SO3_R(R); // Sophus::SO3d可以直接从旋转矩阵构造 Sophus::SO3d SO3_q(q); // 也可以通过四元数构造 // 二者是等价的 cout &lt;&lt; \"SO(3) from matrix:\\n\" &lt;&lt; SO3_R.matrix() &lt;&lt; endl; cout &lt;&lt; \"SO(3) from quaternion:\\n\" &lt;&lt; SO3_q.matrix() &lt;&lt; endl; cout &lt;&lt; \"they are equal\" &lt;&lt; endl; // 使用对数映射获得它的李代数 Vector3d so3 = SO3_R.log(); cout &lt;&lt; \"so3 = \" &lt;&lt; so3.transpose() &lt;&lt; endl; // hat 为向量到反对称矩阵 cout &lt;&lt; \"so3 hat=\\n\" &lt;&lt; Sophus::SO3d::hat(so3) &lt;&lt; endl; // 相对的，vee为反对称到向量 cout &lt;&lt; \"so3 hat vee= \" &lt;&lt; Sophus::SO3d::vee(Sophus::SO3d::hat(so3)).transpose() &lt;&lt; endl; // 增量扰动模型的更新 Vector3d update_so3(1e-4, 0, 0); //假设更新量为这么多 Sophus::SO3d SO3_updated = Sophus::SO3d::exp(update_so3) * SO3_R; cout &lt;&lt; \"SO3 updated = \\n\" &lt;&lt; SO3_updated.matrix() &lt;&lt; endl; cout &lt;&lt; \"*******************************\" &lt;&lt; endl; // 对SE(3)操作大同小异 Vector3d t(1, 0, 0); // 沿X轴平移1 Sophus::SE3d SE3_Rt(R, t); // 从R,t构造SE(3) Sophus::SE3d SE3_qt(q, t); // 从q,t构造SE(3) cout &lt;&lt; \"SE3 from R,t= \\n\" &lt;&lt; SE3_Rt.matrix() &lt;&lt; endl; cout &lt;&lt; \"SE3 from q,t= \\n\" &lt;&lt; SE3_qt.matrix() &lt;&lt; endl; // 李代数se(3) 是一个六维向量，方便起见先typedef一下 typedef Eigen::Matrix&lt;double, 6, 1&gt; Vector6d; Vector6d se3 = SE3_Rt.log(); cout &lt;&lt; \"se3 = \" &lt;&lt; se3.transpose() &lt;&lt; endl; // 观察输出，会发现在Sophus中，se(3)的平移在前，旋转在后. // 同样的，有hat和vee两个算符 cout &lt;&lt; \"se3 hat = \\n\" &lt;&lt; Sophus::SE3d::hat(se3) &lt;&lt; endl; cout &lt;&lt; \"se3 hat vee = \" &lt;&lt; Sophus::SE3d::vee(Sophus::SE3d::hat(se3)).transpose() &lt;&lt; endl; // 最后，演示一下更新 Vector6d update_se3; //更新量 update_se3.setZero(); update_se3(0, 0) = 1e-4d; Sophus::SE3d SE3_updated = Sophus::SE3d::exp(update_se3) * SE3_Rt; cout &lt;&lt; \"SE3 updated = \" &lt;&lt; endl &lt;&lt; SE3_updated.matrix() &lt;&lt; endl; return 0;&#125; trajectoryError计算估计位姿和真值之间的误差。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;unistd.h&gt;#include &lt;pangolin/pangolin.h&gt;#include &lt;sophus/se3.hpp&gt;using namespace Sophus;using namespace std;string groundtruth_file = \"../../example/groundtruth.txt\";string estimated_file = \"../../example/estimated.txt\";typedef vector&lt;Sophus::SE3d, Eigen::aligned_allocator&lt;Sophus::SE3d&gt;&gt; TrajectoryType;void DrawTrajectory(const TrajectoryType &amp;gt, const TrajectoryType &amp;esti);TrajectoryType ReadTrajectory(const string &amp;path);int main(int argc, char **argv) &#123; TrajectoryType groundtruth = ReadTrajectory(groundtruth_file); TrajectoryType estimated = ReadTrajectory(estimated_file); assert(!groundtruth.empty() &amp;&amp; !estimated.empty()); assert(groundtruth.size() == estimated.size()); // compute rmse double rmse = 0; for (size_t i = 0; i &lt; estimated.size(); i++) &#123; Sophus::SE3d p1 = estimated[i], p2 = groundtruth[i]; double error = (p2.inverse() * p1).log().norm(); rmse += error * error; &#125; rmse = rmse / double(estimated.size()); rmse = sqrt(rmse); cout &lt;&lt; \"RMSE = \" &lt;&lt; rmse &lt;&lt; endl; DrawTrajectory(groundtruth, estimated); return 0;&#125;TrajectoryType ReadTrajectory(const string &amp;path) &#123; ifstream fin(path); TrajectoryType trajectory; if (!fin) &#123; cerr &lt;&lt; \"trajectory \" &lt;&lt; path &lt;&lt; \" not found.\" &lt;&lt; endl; return trajectory; &#125; while (!fin.eof()) &#123; double time, tx, ty, tz, qx, qy, qz, qw; fin &gt;&gt; time &gt;&gt; tx &gt;&gt; ty &gt;&gt; tz &gt;&gt; qx &gt;&gt; qy &gt;&gt; qz &gt;&gt; qw; Sophus::SE3d p1(Eigen::Quaterniond(qx, qy, qz, qw), Eigen::Vector3d(tx, ty, tz)); trajectory.push_back(p1); &#125; return trajectory;&#125;void DrawTrajectory(const TrajectoryType &amp;gt, const TrajectoryType &amp;esti) &#123; // create pangolin window and plot the trajectory pangolin::CreateWindowAndBind(\"Trajectory Viewer\", 1024, 768); glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); pangolin::OpenGlRenderState s_cam( pangolin::ProjectionMatrix(1024, 768, 500, 500, 512, 389, 0.1, 1000), pangolin::ModelViewLookAt(0, -0.1, -1.8, 0, 0, 0, 0.0, -1.0, 0.0) ); pangolin::View &amp;d_cam = pangolin::CreateDisplay() .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f) .SetHandler(new pangolin::Handler3D(s_cam)); while (pangolin::ShouldQuit() == false) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); d_cam.Activate(s_cam); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glLineWidth(2); for (size_t i = 0; i &lt; gt.size() - 1; i++) &#123; glColor3f(0.0f, 0.0f, 1.0f); // blue for ground truth glBegin(GL_LINES); auto p1 = gt[i], p2 = gt[i + 1]; glVertex3d(p1.translation()[0], p1.translation()[1], p1.translation()[2]); glVertex3d(p2.translation()[0], p2.translation()[1], p2.translation()[2]); glEnd(); &#125; for (size_t i = 0; i &lt; esti.size() - 1; i++) &#123; glColor3f(1.0f, 0.0f, 0.0f); // red for estimated glBegin(GL_LINES); auto p1 = esti[i], p2 = esti[i + 1]; glVertex3d(p1.translation()[0], p1.translation()[1], p1.translation()[2]); glVertex3d(p2.translation()[0], p2.translation()[1], p2.translation()[2]); glEnd(); &#125; pangolin::FinishFrame(); usleep(5000); // sleep 5 ms &#125;&#125; 相机与图像imageBasics12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;chrono&gt;using namespace std;#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;int main(int argc, char **argv) &#123; // 读取argv[1]指定的图像 cv::Mat image; image = cv::imread(argv[1]); //cv::imread函数读取指定路径下的图像 // 判断图像文件是否正确读取 if (image.data == nullptr) &#123; //数据不存在,可能是文件不存在 cerr &lt;&lt; \"文件\" &lt;&lt; argv[1] &lt;&lt; \"不存在.\" &lt;&lt; endl; return 0; &#125; // 文件顺利读取, 首先输出一些基本信息 cout &lt;&lt; \"图像宽为\" &lt;&lt; image.cols &lt;&lt; \",高为\" &lt;&lt; image.rows &lt;&lt; \",通道数为\" &lt;&lt; image.channels() &lt;&lt; endl; cv::imshow(\"image\", image); // 用cv::imshow显示图像 cv::waitKey(0); // 暂停程序,等待一个按键输入 // 判断image的类型 if (image.type() != CV_8UC1 &amp;&amp; image.type() != CV_8UC3) &#123; // 图像类型不符合要求 cout &lt;&lt; \"请输入一张彩色图或灰度图.\" &lt;&lt; endl; return 0; &#125; // 遍历图像, 请注意以下遍历方式亦可使用于随机像素访问 // 使用 std::chrono 来给算法计时 chrono::steady_clock::time_point t1 = chrono::steady_clock::now(); //size_t要么是unsigned int，要么是unsigned long int for (size_t y = 0; y &lt; image.rows; y++) &#123; // 用cv::Mat::ptr获得图像的行指针 unsigned char *row_ptr = image.ptr&lt;unsigned char&gt;(y); // row_ptr是第y行的头指针 for (size_t x = 0; x &lt; image.cols; x++) &#123; // 访问位于 x,y 处的像素 unsigned char *data_ptr = &amp;row_ptr[x * image.channels()]; // data_ptr 指向待访问的像素数据 // 输出该像素的每个通道,如果是灰度图就只有一个通道 for (int c = 0; c != image.channels(); c++) &#123; unsigned char data = data_ptr[c]; // data为I(x,y)第c个通道的值 &#125; &#125; &#125; chrono::steady_clock::time_point t2 = chrono::steady_clock::now(); chrono::duration&lt;double&gt; time_used = chrono::duration_cast &lt; chrono::duration &lt; double &gt;&gt; (t2 - t1); cout &lt;&lt; \"遍历图像用时：\" &lt;&lt; time_used.count() &lt;&lt; \" 秒。\" &lt;&lt; endl; // 关于 cv::Mat 的拷贝 // 直接赋值并不会拷贝数据 cv::Mat image_another = image; // 修改 image_another 会导致 image 发生变化 image_another(cv::Rect(0, 0, 100, 100)).setTo(0); // 将左上角100*100的块置零 cv::imshow(\"image\", image); cv::waitKey(0); // 使用clone函数来拷贝数据 cv::Mat image_clone = image.clone(); image_clone(cv::Rect(0, 0, 100, 100)).setTo(255); cv::imshow(\"image\", image); cv::imshow(\"image_clone\", image_clone); cv::waitKey(0); // 对于图像还有很多基本的操作,如剪切,旋转,缩放等,限于篇幅就不一一介绍了,请参看OpenCV官方文档查询每个函数的调用方法. cv::destroyAllWindows(); return 0;&#125; undistortImage123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;opencv2/opencv.hpp&gt;#include &lt;string&gt;using namespace std;string image_file = \"./distorted.png\"; // 请确保路径正确int main(int argc, char **argv) &#123; // 本程序实现去畸变部分的代码。尽管我们可以调用OpenCV的去畸变，但自己实现一遍有助于理解。 // 畸变参数 double k1 = -0.28340811, k2 = 0.07395907, p1 = 0.00019359, p2 = 1.76187114e-05; // 内参 double fx = 458.654, fy = 457.296, cx = 367.215, cy = 248.375; cv::Mat image = cv::imread(image_file, 0); // 图像是灰度图，CV_8UC1 int rows = image.rows, cols = image.cols; cv::Mat image_undistort = cv::Mat(rows, cols, CV_8UC1); // 去畸变以后的图 // 计算去畸变后图像的内容 for (int v = 0; v &lt; rows; v++) &#123; for (int u = 0; u &lt; cols; u++) &#123; // 按照公式，计算点(u,v)对应到畸变图像中的坐标(u_distorted, v_distorted) double x = (u - cx) / fx, y = (v - cy) / fy; double r = sqrt(x * x + y * y); double x_distorted = x * (1 + k1 * r * r + k2 * r * r * r * r) + 2 * p1 * x * y + p2 * (r * r + 2 * x * x); double y_distorted = y * (1 + k1 * r * r + k2 * r * r * r * r) + p1 * (r * r + 2 * y * y) + 2 * p2 * x * y; double u_distorted = fx * x_distorted + cx; double v_distorted = fy * y_distorted + cy; // 赋值 (最近邻插值) if (u_distorted &gt;= 0 &amp;&amp; v_distorted &gt;= 0 &amp;&amp; u_distorted &lt; cols &amp;&amp; v_distorted &lt; rows) &#123; image_undistort.at&lt;uchar&gt;(v, u) = image.at&lt;uchar&gt;((int) v_distorted, (int) u_distorted); &#125; else &#123; image_undistort.at&lt;uchar&gt;(v, u) = 0; &#125; &#125; &#125; // 画图去畸变后图像 cv::imshow(\"distorted\", image); cv::imshow(\"undistorted\", image_undistort); cv::waitKey(); return 0;&#125; stereoVision123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;opencv2/opencv.hpp&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;Eigen/Core&gt;#include &lt;pangolin/pangolin.h&gt;#include &lt;unistd.h&gt;using namespace std;using namespace Eigen;// 文件路径string left_file = \"./left.png\";string right_file = \"./right.png\";// 在pangolin中画图，已写好，无需调整void showPointCloud( const vector&lt;Vector4d, Eigen::aligned_allocator&lt;Vector4d&gt;&gt; &amp;pointcloud);int main(int argc, char **argv) &#123; // 内参 double fx = 718.856, fy = 718.856, cx = 607.1928, cy = 185.2157; // 基线 double b = 0.573; // 读取图像 cv::Mat left = cv::imread(left_file, 0); cv::Mat right = cv::imread(right_file, 0); cv::Ptr&lt;cv::StereoSGBM&gt; sgbm = cv::StereoSGBM::create( 0, 96, 9, 8 * 9 * 9, 32 * 9 * 9, 1, 63, 10, 100, 32); // 神奇的参数 cv::Mat disparity_sgbm, disparity; sgbm-&gt;compute(left, right, disparity_sgbm); disparity_sgbm.convertTo(disparity, CV_32F, 1.0 / 16.0f); // 生成点云 vector&lt;Vector4d, Eigen::aligned_allocator&lt;Vector4d&gt;&gt; pointcloud; // 如果你的机器慢，请把后面的v++和u++改成v+=2, u+=2 for (int v = 0; v &lt; left.rows; v++) for (int u = 0; u &lt; left.cols; u++) &#123; if (disparity.at&lt;float&gt;(v, u) &lt;= 0.0 || disparity.at&lt;float&gt;(v, u) &gt;= 96.0) continue; Vector4d point(0, 0, 0, left.at&lt;uchar&gt;(v, u) / 255.0); // 前三维为xyz,第四维为颜色 // 根据双目模型计算 point 的位置 double x = (u - cx) / fx; double y = (v - cy) / fy; double depth = fx * b / (disparity.at&lt;float&gt;(v, u)); point[0] = x * depth; point[1] = y * depth; point[2] = depth; pointcloud.push_back(point); &#125; cv::imshow(\"disparity\", disparity / 96.0); cv::waitKey(0); // 画出点云 showPointCloud(pointcloud); return 0;&#125;void showPointCloud(const vector&lt;Vector4d, Eigen::aligned_allocator&lt;Vector4d&gt;&gt; &amp;pointcloud) &#123; if (pointcloud.empty()) &#123; cerr &lt;&lt; \"Point cloud is empty!\" &lt;&lt; endl; return; &#125; pangolin::CreateWindowAndBind(\"Point Cloud Viewer\", 1024, 768); glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); pangolin::OpenGlRenderState s_cam( pangolin::ProjectionMatrix(1024, 768, 500, 500, 512, 389, 0.1, 1000), pangolin::ModelViewLookAt(0, -0.1, -1.8, 0, 0, 0, 0.0, -1.0, 0.0) ); pangolin::View &amp;d_cam = pangolin::CreateDisplay() .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f) .SetHandler(new pangolin::Handler3D(s_cam)); while (pangolin::ShouldQuit() == false) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); d_cam.Activate(s_cam); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glPointSize(2); glBegin(GL_POINTS); for (auto &amp;p: pointcloud) &#123; glColor3f(p[3], p[3], p[3]); glVertex3d(p[0], p[1], p[2]); &#125; glEnd(); pangolin::FinishFrame(); usleep(5000); // sleep 5 ms &#125; return;&#125; JoinMap (拼接点云）完成两件事：(1). 根据内参计算一对 RGB-D 图像对应的点云；(2). 根据各张图的相机位姿（也就是外参），把点云加起来，组成地图。点云库使用 PCL（Point Cloud Library） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;boost/format.hpp&gt; // for formating strings#include &lt;sophus/se3.hpp&gt;#include &lt;pangolin/pangolin.h&gt;using namespace std;typedef vector&lt;Sophus::SE3d, Eigen::aligned_allocator&lt;Sophus::SE3d&gt;&gt; TrajectoryType;typedef Eigen::Matrix&lt;double, 6, 1&gt; Vector6d;// 在pangolin中画图，已写好，无需调整void showPointCloud( const vector&lt;Vector6d, Eigen::aligned_allocator&lt;Vector6d&gt;&gt; &amp;pointcloud);int main(int argc, char **argv) &#123; vector&lt;cv::Mat&gt; colorImgs, depthImgs; // 彩色图和深度图 TrajectoryType poses; // 相机位姿 ifstream fin(\"./pose.txt\"); if (!fin) &#123; cerr &lt;&lt; \"请在有pose.txt的目录下运行此程序\" &lt;&lt; endl; return 1; &#125; for (int i = 0; i &lt; 5; i++) &#123; boost::format fmt(\"./%s/%d.%s\"); //图像文件格式 colorImgs.push_back(cv::imread((fmt % \"color\" % (i + 1) % \"png\").str())); depthImgs.push_back(cv::imread((fmt % \"depth\" % (i + 1) % \"pgm\").str(), -1)); // 使用-1读取原始图像 double data[7] = &#123;0&#125;; //for(auto a:b)中b为一个容器，效果是利用a遍历并获得b容器中的每一个值，但是a无法影响到b容器中的元素。 //for(auto &amp;a:b)中加了引用符号，可以对容器中的内容进行赋值，即可通过对a赋值来做到容器b的内容填充。 for (auto &amp;d:data) fin &gt;&gt; d; Sophus::SE3d pose(Eigen::Quaterniond(data[6], data[3], data[4], data[5]), Eigen::Vector3d(data[0], data[1], data[2])); poses.push_back(pose); &#125; // 计算点云并拼接 // 相机内参 double cx = 325.5; double cy = 253.5; double fx = 518.0; double fy = 519.0; double depthScale = 1000.0; vector&lt;Vector6d, Eigen::aligned_allocator&lt;Vector6d&gt;&gt; pointcloud; pointcloud.reserve(1000000); for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; \"转换图像中: \" &lt;&lt; i + 1 &lt;&lt; endl; cv::Mat color = colorImgs[i]; cv::Mat depth = depthImgs[i]; Sophus::SE3d T = poses[i]; for (int v = 0; v &lt; color.rows; v++) for (int u = 0; u &lt; color.cols; u++) &#123; unsigned int d = depth.ptr&lt;unsigned short&gt;(v)[u]; // 深度值 if (d == 0) continue; // 为0表示没有测量到 Eigen::Vector3d point; point[2] = double(d) / depthScale; point[0] = (u - cx) * point[2] / fx; point[1] = (v - cy) * point[2] / fy; Eigen::Vector3d pointWorld = T * point; Vector6d p; p.head&lt;3&gt;() = pointWorld; p[5] = color.data[v * color.step + u * color.channels()]; // blue p[4] = color.data[v * color.step + u * color.channels() + 1]; // green p[3] = color.data[v * color.step + u * color.channels() + 2]; // red pointcloud.push_back(p); &#125; &#125; cout &lt;&lt; \"点云共有\" &lt;&lt; pointcloud.size() &lt;&lt; \"个点.\" &lt;&lt; endl; showPointCloud(pointcloud); return 0;&#125;void showPointCloud(const vector&lt;Vector6d, Eigen::aligned_allocator&lt;Vector6d&gt;&gt; &amp;pointcloud) &#123; if (pointcloud.empty()) &#123; cerr &lt;&lt; \"Point cloud is empty!\" &lt;&lt; endl; return; &#125; pangolin::CreateWindowAndBind(\"Point Cloud Viewer\", 1024, 768); glEnable(GL_DEPTH_TEST); glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); pangolin::OpenGlRenderState s_cam( pangolin::ProjectionMatrix(1024, 768, 500, 500, 512, 389, 0.1, 1000), pangolin::ModelViewLookAt(0, -0.1, -1.8, 0, 0, 0, 0.0, -1.0, 0.0) ); pangolin::View &amp;d_cam = pangolin::CreateDisplay() .SetBounds(0.0, 1.0, pangolin::Attach::Pix(175), 1.0, -1024.0f / 768.0f) .SetHandler(new pangolin::Handler3D(s_cam)); while (pangolin::ShouldQuit() == false) &#123; glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); d_cam.Activate(s_cam); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glPointSize(2); glBegin(GL_POINTS); for (auto &amp;p: pointcloud) &#123; glColor3d(p[3] / 255.0, p[4] / 255.0, p[5] / 255.0); glVertex3d(p[0], p[1], p[2]); &#125; glEnd(); pangolin::FinishFrame(); usleep(5000); // sleep 5 ms &#125; return;&#125; 12345678910111213141516171819202122232425vector&lt;cv::Mat&gt; colorImgs, depthImgs; // 彩色图和深度图vector&lt;Eigen::Isometry3d, Eigen::aligned_allocator&lt;Eigen::Isometry3d&gt;&gt; poses; // 相机位姿,由4x4的变换矩阵T组成的容器ifstream fin(\"./pose.txt\");if (!fin)&#123; cerr&lt;&lt;\"请在有pose.txt的目录下运行此程序\"&lt;&lt;endl; return 1;&#125;for ( int i=0; i&lt;5; i++ )&#123; boost::format fmt( \"./%s/%d.%s\" ); //图像文件格式,（./字符串/整数.字符串） colorImgs.push_back( cv::imread( (fmt%\"color\"%(i+1)%\"png\").str() ));//cv::imread(./color/1.png) depthImgs.push_back( cv::imread( (fmt%\"depth\"%(i+1)%\"pgm\").str(), -1 )); // 使用-1读取原始图像 double data[7] = &#123;0&#125;; for ( auto&amp; d:data )//for(auto a:b)中b为一个容器，效果是利用a遍历并获得b容器中的每一个值，但是a无法影响到b容器中的元素。 //for(auto &amp;a:b)中加了引用符号，可以对容器中的内容进行赋值，即可通过对a赋值来做到容器b的内容填充。 fin&gt;&gt;d; Eigen::Quaterniond q( data[6], data[3], data[4], data[5] ); Eigen::Isometry3d T(q); T.pretranslate( Eigen::Vector3d( data[0], data[1], data[2] )); poses.push_back( T ); &#125;","categories":[],"tags":[]},{"title":"C++基础入门","slug":"C++基础入门","date":"2020-03-20T14:54:42.406Z","updated":"2020-03-20T14:54:49.512Z","comments":true,"path":"2020/03/20/C++基础入门/","link":"","permalink":"http://yoursite.com/2020/03/20/C++%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"C++基础入门1 C++初识1.1 第一个C++程序编写一个C++程序总共分为4个步骤 创建项目 创建文件 编写代码 运行程序 1.1.1 创建项目​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开 1.1.2 创建文件右键源文件，选择添加-&gt;新建项 给C++文件起个名称，然后点击添加即可。 1.1.3 编写代码1234567891011#include&lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; \"Hello world\" &lt;&lt; endl; system(\"pause\"); return 0;&#125; 1.1.4 运行程序 1.2 注释作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码 两种格式 单行注释：// 描述信息 通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明== 多行注释： /* 描述信息 */ 通常放在一段代码的上方，==对该段代码做整体说明== 提示：编译器在编译代码时，会忽略注释的内容 1.3 变量作用：给一段指定的内存空间起名，方便操作这段内存 语法：数据类型 变量名 = 初始值; 示例： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123; //变量的定义 //语法：数据类型 变量名 = 初始值 int a = 10; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; system(\"pause\"); return 0;&#125; 注意：C++在创建变量时，必须给变量一个初始值，否则会报错 1.4 常量作用：用于记录程序中不可更改的数据 C++定义常量两种方式 #define 宏常量： #define 常量名 常量值 通常在文件上方定义，表示一个常量 const修饰的变量 const 数据类型 常量名 = 常量值 通常在变量定义前加关键字const，修饰该变量为常量，不可修改 示例： 123456789101112131415161718//1、宏常量#define day 7int main() &#123; cout &lt;&lt; \"一周里总共有 \" &lt;&lt; day &lt;&lt; \" 天\" &lt;&lt; endl; //day = 8; //报错，宏常量不可以修改 //2、const修饰变量 const int month = 12; cout &lt;&lt; \"一年里总共有 \" &lt;&lt; month &lt;&lt; \" 个月份\" &lt;&lt; endl; //month = 24; //报错，常量是不可以修改的 system(\"pause\"); return 0;&#125; 1.5 关键字作用：关键字是C++中预先保留的单词（标识符） 在定义变量或者常量时候，不要用关键字 C++关键字如下： asm do if return typedef auto double inline short typeid bool dynamic_cast int signed typename break else long sizeof union case enum mutable static unsigned catch explicit namespace static_cast using char export new struct virtual class extern operator switch void const false private template volatile const_cast float protected this wchar_t continue for public throw while default friend register true delete goto reinterpret_cast try 提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。 1.6 标识符命名规则作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则 标识符不能是关键字 标识符只能由字母、数字、下划线组成 第一个字符必须为字母或下划线 标识符中字母区分大小写 建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读 2 数据类型C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存 2.1 整型作用：整型变量表示的是整数类型的数据 C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同： 数据类型 占用空间 取值范围 short(短整型) 2字节 (-2^15 ~ 2^15-1) int(整型) 4字节 (-2^31 ~ 2^31-1) long(长整形) Windows为4字节，Linux为4字节(32位)，8字节(64位) (-2^31 ~ 2^31-1) long long(长长整形) 8字节 (-2^63 ~ 2^63-1) 2.2 sizeof关键字作用：利用sizeof关键字可以统计数据类型所占内存大小 语法： sizeof( 数据类型 / 变量) 示例： 1234567891011121314int main() &#123; cout &lt;&lt; \"short 类型所占内存空间为： \" &lt;&lt; sizeof(short) &lt;&lt; endl; cout &lt;&lt; \"int 类型所占内存空间为： \" &lt;&lt; sizeof(int) &lt;&lt; endl; cout &lt;&lt; \"long 类型所占内存空间为： \" &lt;&lt; sizeof(long) &lt;&lt; endl; cout &lt;&lt; \"long long 类型所占内存空间为： \" &lt;&lt; sizeof(long long) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 整型结论：short &lt; int &lt;= long &lt;= long long 2.3 实型（浮点型）作用：用于表示小数 浮点型变量分为两种： 单精度float 双精度double 两者的区别在于表示的有效数字范围不同。 数据类型 占用空间 有效数字范围 float 4字节 7位有效数字 double 8字节 15～16位有效数字 示例： 12345678910111213141516171819202122int main() &#123; float f1 = 3.14f; double d1 = 3.14; cout &lt;&lt; f1 &lt;&lt; endl; cout &lt;&lt; d1&lt;&lt; endl; cout &lt;&lt; \"float sizeof = \" &lt;&lt; sizeof(f1) &lt;&lt; endl; cout &lt;&lt; \"double sizeof = \" &lt;&lt; sizeof(d1) &lt;&lt; endl; //科学计数法 float f2 = 3e2; // 3 * 10 ^ 2 cout &lt;&lt; \"f2 = \" &lt;&lt; f2 &lt;&lt; endl; float f3 = 3e-2; // 3 * 0.1 ^ 2 cout &lt;&lt; \"f3 = \" &lt;&lt; f3 &lt;&lt; endl; system(\"pause\"); return 0;&#125; 2.4 字符型作用：字符型变量用于显示单个字符 语法：char ch = &#39;a&#39;; 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号 注意2：单引号内只能有一个字符，不可以是字符串 C和C++中字符型变量只占用1个字节。 字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元 示例： 1234567891011121314151617int main() &#123; char ch = 'a'; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; sizeof(char) &lt;&lt; endl; //ch = \"abcde\"; //错误，不可以用双引号 //ch = 'abcde'; //错误，单引号内只能引用一个字符 cout &lt;&lt; (int)ch &lt;&lt; endl; //查看字符a对应的ASCII码 ch = 97; //可以直接用ASCII给字符型变量赋值 cout &lt;&lt; ch &lt;&lt; endl; system(\"pause\"); return 0;&#125; ASCII码表格： ASCII值 控制字符 ASCII值 字符 ASCII值 字符 ASCII值 字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ASCII 码大致由以下两部分组成： ASCII 非打印控制字符： ASCII 表上的数字 0-31 分配给了控制字符，用于控制像打印机等一些外围设备。 ASCII 打印字符：数字 32-126 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。 2.5 转义字符作用：用于表示一些 不能显示出来的ASCII字符 现阶段我们常用的转义字符有：\\n \\\\ \\t 转义字符 含义 ASCII码值（十进制） \\a 警报 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符”&quot; 092 &#39; 代表一个单引号（撇号）字符 039 &quot; 代表一个双引号字符 034 ? 代表一个问号 063 \\0 数字0 000 \\ddd 8进制转义字符，d范围0~7 3位8进制 \\xhh 16进制转义字符，h范围09，af，A~F 3位16进制 示例： 1234567891011int main() &#123; cout &lt;&lt; \"\\\\\" &lt;&lt; endl; cout &lt;&lt; \"\\tHello\" &lt;&lt; endl; cout &lt;&lt; \"\\n\" &lt;&lt; endl; system(\"pause\"); return 0;&#125; 2.6 字符串型作用：用于表示一串字符 两种风格 C风格字符串： char 变量名[] = &quot;字符串值&quot; 示例： 123456789int main() &#123; char str1[] = \"hello world\"; cout &lt;&lt; str1 &lt;&lt; endl; system(\"pause\"); return 0;&#125; 注意：C风格的字符串要用双引号括起来 C++风格字符串： string 变量名 = &quot;字符串值&quot; 示例： 123456789int main() &#123; string str = \"hello world\"; cout &lt;&lt; str &lt;&lt; endl; system(\"pause\"); return 0;&#125; 注意：C++风格字符串，需要加入头文件#include\\&lt;string&gt; 2.7 布尔类型 bool作用：布尔数据类型代表真或假的值 bool类型只有两个值： true — 真（本质是1） false — 假（本质是0） bool类型占 1个字节 大小 示例： 1234567891011121314int main() &#123; bool flag = true; cout &lt;&lt; flag &lt;&lt; endl; // 1 flag = false; cout &lt;&lt; flag &lt;&lt; endl; // 0 cout &lt;&lt; \"size of bool = \" &lt;&lt; sizeof(bool) &lt;&lt; endl; //1 system(\"pause\"); return 0;&#125; 2.8 数据的输入作用：用于从键盘获取数据 关键字：cin 语法： cin &gt;&gt; 变量 示例： 12345678910111213141516171819202122232425262728293031323334int main()&#123; //整型输入 int a = 0; cout &lt;&lt; \"请输入整型变量：\" &lt;&lt; endl; cin &gt;&gt; a; cout &lt;&lt; a &lt;&lt; endl; //浮点型输入 double d = 0; cout &lt;&lt; \"请输入浮点型变量：\" &lt;&lt; endl; cin &gt;&gt; d; cout &lt;&lt; d &lt;&lt; endl; //字符型输入 char ch = 0; cout &lt;&lt; \"请输入字符型变量：\" &lt;&lt; endl; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; //字符串型输入 string str; cout &lt;&lt; \"请输入字符串型变量：\" &lt;&lt; endl; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; endl; //布尔类型输入 bool flag = true; cout &lt;&lt; \"请输入布尔型变量：\" &lt;&lt; endl; cin &gt;&gt; flag; cout &lt;&lt; flag &lt;&lt; endl; system(\"pause\"); return EXIT_SUCCESS;&#125; 3 运算符作用：用于执行代码的运算 本章我们主要讲解以下几类运算符： 运算符类型 作用 算术运算符 用于处理四则运算 赋值运算符 用于将表达式的值赋给变量 比较运算符 用于表达式的比较，并返回一个真值或假值 逻辑运算符 用于根据表达式的值返回真值或假值 3.1 算术运算符作用：用于处理四则运算 算术运算符包括以下符号： 运算符 术语 示例 结果 + 正号 +3 3 - 负号 -3 -3 + 加 10 + 5 15 - 减 10 - 5 5 * 乘 10 * 5 50 / 除 10 / 5 2 % 取模(取余) 10 % 3 1 ++ 前置递增 a=2; b=++a; a=3; b=3; ++ 后置递增 a=2; b=a++; a=3; b=2; – 前置递减 a=2; b=–a; a=1; b=1; – 后置递减 a=2; b=a–; a=1; b=2; 示例1： 1234567891011121314151617181920212223242526272829//加减乘除int main() &#123; int a1 = 10; int b1 = 3; cout &lt;&lt; a1 + b1 &lt;&lt; endl; cout &lt;&lt; a1 - b1 &lt;&lt; endl; cout &lt;&lt; a1 * b1 &lt;&lt; endl; cout &lt;&lt; a1 / b1 &lt;&lt; endl; //两个整数相除结果依然是整数 int a2 = 10; int b2 = 20; cout &lt;&lt; a2 / b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0 //两个小数可以相除 double d1 = 0.5; double d2 = 0.25; cout &lt;&lt; d1 / d2 &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：在除法运算中，除数不能为0 示例2： 12345678910111213141516171819202122232425262728//取模int main() &#123; int a1 = 10; int b1 = 3; cout &lt;&lt; 10 % 3 &lt;&lt; endl; int a2 = 10; int b2 = 20; cout &lt;&lt; a2 % b2 &lt;&lt; endl; int a3 = 10; int b3 = 0; //cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0 //两个小数不可以取模 double d1 = 3.14; double d2 = 1.1; //cout &lt;&lt; d1 % d2 &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：只有整型变量可以进行取模运算 示例3： 12345678910111213141516171819202122232425262728//递增int main() &#123; //后置递增 int a = 10; a++; //等价于a = a + 1 cout &lt;&lt; a &lt;&lt; endl; // 11 //前置递增 int b = 10; ++b; cout &lt;&lt; b &lt;&lt; endl; // 11 //区别 //前置递增先对变量进行++，再计算表达式 int a2 = 10; int b2 = ++a2 * 10; cout &lt;&lt; b2 &lt;&lt; endl; //后置递增先计算表达式，后对变量进行++ int a3 = 10; int b3 = a3++ * 10; cout &lt;&lt; b3 &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：前置递增先对变量进行++，再计算表达式，后置递增相反 3.2 赋值运算符作用：用于将表达式的值赋给变量 赋值运算符包括以下几个符号： 运算符 术语 示例 结果 = 赋值 a=2; b=3; a=2; b=3; += 加等于 a=0; a+=2; a=2; -= 减等于 a=5; a-=3; a=2; *= 乘等于 a=2; a*=2; a=4; /= 除等于 a=4; a/=2; a=2; %= 模等于 a=3; a%2; a=1; 示例： 1234567891011121314151617181920212223242526272829303132333435363738int main() &#123; //赋值运算符 // = int a = 10; a = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // += a = 10; a += 2; // a = a + 2; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // -= a = 10; a -= 2; // a = a - 2 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // *= a = 10; a *= 2; // a = a * 2 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // /= a = 10; a /= 2; // a = a / 2; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; // %= a = 10; a %= 2; // a = a % 2; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; system(\"pause\"); return 0;&#125; 3.3 比较运算符作用：用于表达式的比较，并返回一个真值或假值 比较运算符有以下符号： 运算符 术语 示例 结果 == 相等于 4 == 3 0 != 不等于 4 != 3 1 &lt; 小于 4 &lt; 3 0 &gt; 大于 4 &gt; 3 1 &lt;= 小于等于 4 &lt;= 3 0 &gt;= 大于等于 4 &gt;= 1 1 示例： 123456789101112131415161718192021int main() &#123; int a = 10; int b = 20; cout &lt;&lt; (a == b) &lt;&lt; endl; // 0 cout &lt;&lt; (a != b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt; b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt; b) &lt;&lt; endl; // 1 cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; // 0 cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; // 1 system(\"pause\"); return 0;&#125; 注意：C和C++ 语言的比较运算中，“真”用数字“1”来表示， “假”用数字“0”来表示。 3.4 逻辑运算符作用：用于根据表达式的值返回真值或假值 逻辑运算符有以下符号： 运算符 术语 示例 结果 ! 非 !a 如果a为假，则!a为真； 如果a为真，则!a为假。 &amp;&amp; 与 a &amp;&amp; b 如果a和b都为真，则结果为真，否则为假。 || 或 a || b 如果a和b有一个为真，则结果为真，二者都为假时，结果为假。 示例1：逻辑非 12345678910111213//逻辑运算符 --- 非int main() &#123; int a = 10; cout &lt;&lt; !a &lt;&lt; endl; // 0 cout &lt;&lt; !!a &lt;&lt; endl; // 1 system(\"pause\"); return 0;&#125; 总结： 真变假，假变真 示例2：逻辑与 12345678910111213141516171819202122//逻辑运算符 --- 与int main() &#123; int a = 10; int b = 10; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 a = 0; b = 0; cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;// 0 system(\"pause\"); return 0;&#125; 总结：逻辑与运算符总结：同真为真，其余为假 示例3：逻辑或 12345678910111213141516171819202122//逻辑运算符 --- 或int main() &#123; int a = 10; int b = 10; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 10; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 1 a = 0; b = 0; cout &lt;&lt; (a || b) &lt;&lt; endl;// 0 system(\"pause\"); return 0;&#125; 逻辑或运算符总结： 同假为假，其余为真 4 程序流程结构C/C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构 顺序结构：程序按顺序执行，不发生跳转 选择结构：依据条件是否满足，有选择的执行相应功能 循环结构：依据条件是否满足，循环多次执行某段代码 4.1 选择结构4.1.1 if语句作用：执行满足条件的语句 if语句的三种形式 单行格式if语句 多行格式if语句 多条件的if语句 单行格式if语句：if(条件){ 条件满足执行的语句 } 示例： 12345678910111213141516171819202122int main() &#123; //选择结构-单行if语句 //输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印 int score = 0; cout &lt;&lt; \"请输入一个分数：\" &lt;&lt; endl; cin &gt;&gt; score; cout &lt;&lt; \"您输入的分数为： \" &lt;&lt; score &lt;&lt; endl; //if语句 //注意事项，在if判断语句后面，不要加分号 if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学！！！\" &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 注意：if条件表达式后不要加分号 多行格式if语句：if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 }; 示例： 123456789101112131415161718192021int main() &#123; int score = 0; cout &lt;&lt; \"请输入考试分数：\" &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我未考上一本大学\" &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 多条件的if语句：if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句} 示例： 1234567891011121314151617181920212223242526272829 int main() &#123; int score = 0; cout &lt;&lt; \"请输入考试分数：\" &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学\" &lt;&lt; endl; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; \"我考上了二本大学\" &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; \"我考上了三本大学\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我未考上本科\" &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断 案例需求： 提示用户输入一个高考考试分数，根据分数做如下判断 分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科； 在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142int main() &#123; int score = 0; cout &lt;&lt; \"请输入考试分数：\" &lt;&lt; endl; cin &gt;&gt; score; if (score &gt; 600) &#123; cout &lt;&lt; \"我考上了一本大学\" &lt;&lt; endl; if (score &gt; 700) &#123; cout &lt;&lt; \"我考上了北大\" &lt;&lt; endl; &#125; else if (score &gt; 650) &#123; cout &lt;&lt; \"我考上了清华\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我考上了人大\" &lt;&lt; endl; &#125; &#125; else if (score &gt; 500) &#123; cout &lt;&lt; \"我考上了二本大学\" &lt;&lt; endl; &#125; else if (score &gt; 400) &#123; cout &lt;&lt; \"我考上了三本大学\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"我未考上本科\" &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 练习案例： 三只小猪称体重 4.1.2 三目运算符作用： 通过三目运算符实现简单的判断 语法：表达式1 ? 表达式2 ：表达式3 解释： 如果表达式1的值为真，执行表达式2，并返回表达式2的结果； 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。 示例： 123456789101112131415161718192021int main() &#123; int a = 10; int b = 20; int c = 0; c = a &gt; b ? a : b; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; //C++中三目运算符返回的是变量,可以继续赋值 (a &gt; b ? a : b) = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰 4.1.3 switch语句作用：执行多条件分支语句 语法： 12345678910111213switch(表达式)&#123; case 结果1：执行语句;break; case 结果2：执行语句;break; ... default:执行语句;break;&#125; 示例： 12345678910111213141516171819202122232425262728293031323334int main() &#123; //请给电影评分 //10 ~ 9 经典 // 8 ~ 7 非常好 // 6 ~ 5 一般 // 5分以下 烂片 int score = 0; cout &lt;&lt; \"请给电影打分\" &lt;&lt; endl; cin &gt;&gt; score; switch (score) &#123; case 10: case 9: cout &lt;&lt; \"经典\" &lt;&lt; endl; break; case 8: cout &lt;&lt; \"非常好\" &lt;&lt; endl; break; case 7: case 6: cout &lt;&lt; \"一般\" &lt;&lt; endl; break; default: cout &lt;&lt; \"烂片\" &lt;&lt; endl; break; &#125; system(\"pause\"); return 0;&#125; 注意1：switch语句中表达式类型只能是整型或者字符型 注意2：case里如果没有break，那么程序会一直向下执行 总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间 4.2 循环结构4.2.1 while循环语句作用：满足循环条件，执行循环语句 语法：while(循环条件){ 循环语句 } 解释：只要循环条件的结果为真，就执行循环语句 示例： 12345678910111213int main() &#123; int num = 0; while (num &lt; 10) &#123; cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl; num++; &#125; system(\"pause\"); return 0;&#125; 注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环 while循环练习案例： 猜数字 案例描述：系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。 4.2.2 do…while循环语句作用： 满足循环条件，执行循环语句 语法： do{ 循环语句 } while(循环条件); 注意： 与while的区别在于do…while会先执行一次循环语句，再判断循环条件 示例： 12345678910111213141516int main() &#123; int num = 0; do &#123; cout &lt;&lt; num &lt;&lt; endl; num++; &#125; while (num &lt; 10); system(\"pause\"); return 0;&#125; 总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件 练习案例：水仙花数 案例描述：水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身 例如：1^3 + 5^3+ 3^3 = 153 请利用do…while语句，求出所有3位数中的水仙花数 4.2.3 for循环语句作用： 满足循环条件，执行循环语句 语法：for(起始表达式;条件表达式;末尾循环体) { 循环语句; } 示例： 1234567891011int main() &#123; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 详解： 注意：for循环中的表达式，要用分号进行分隔 总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用 练习案例：敲桌子 案例描述：从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。 4.2.4 嵌套循环作用： 在循环体中再嵌套一层循环，解决一些实际问题 例如我们想在屏幕中打印如下图片，就需要利用嵌套循环 示例： 12345678910111213141516int main() &#123; //外层循环执行1次，内层循环执行1轮 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; cout &lt;&lt; \"*\" &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 练习案例：乘法口诀表 案例描述：利用嵌套循环，实现九九乘法表 4.3 跳转语句4.3.1 break语句作用: 用于跳出选择结构或者循环结构 break使用的时机： 出现在switch条件语句中，作用是终止case并跳出switch 出现在循环语句中，作用是跳出当前的循环语句 出现在嵌套循环中，跳出最近的内层循环语句 示例1： 12345678910111213141516171819202122232425262728int main() &#123; //1、在switch 语句中使用break cout &lt;&lt; \"请选择您挑战副本的难度：\" &lt;&lt; endl; cout &lt;&lt; \"1、普通\" &lt;&lt; endl; cout &lt;&lt; \"2、中等\" &lt;&lt; endl; cout &lt;&lt; \"3、困难\" &lt;&lt; endl; int num = 0; cin &gt;&gt; num; switch (num) &#123; case 1: cout &lt;&lt; \"您选择的是普通难度\" &lt;&lt; endl; break; case 2: cout &lt;&lt; \"您选择的是中等难度\" &lt;&lt; endl; break; case 3: cout &lt;&lt; \"您选择的是困难难度\" &lt;&lt; endl; break; &#125; system(\"pause\"); return 0;&#125; 示例2： 123456789101112131415int main() &#123; //2、在循环语句中用break for (int i = 0; i &lt; 10; i++) &#123; if (i == 5) &#123; break; //跳出循环语句 &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 示例3： 12345678910111213141516171819int main() &#123; //在嵌套循环语句中使用break，退出内层循环 for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; if (j == 5) &#123; break; &#125; cout &lt;&lt; \"*\" &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 4.3.2 continue语句作用： 在 循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环 示例： 123456789101112131415int main() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; continue; &#125; cout &lt;&lt; i &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 注意：continue并没有使整个循环终止，而break会跳出循环 4.3.3 goto语句作用：可以无条件跳转语句 语法： goto 标记; 解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置 示例： 123456789101112131415161718int main() &#123; cout &lt;&lt; \"1\" &lt;&lt; endl; goto FLAG; cout &lt;&lt; \"2\" &lt;&lt; endl; cout &lt;&lt; \"3\" &lt;&lt; endl; cout &lt;&lt; \"4\" &lt;&lt; endl; FLAG: cout &lt;&lt; \"5\" &lt;&lt; endl; system(\"pause\"); return 0;&#125; 注意：在程序中不建议使用goto语句，以免造成程序流程混乱 5 数组5.1 概述所谓数组，就是一个集合，里面存放了相同类型的数据元素 特点1：数组中的每个数据元素都是相同的数据类型 特点2： 数组是由连续的内存位置组成的 5.2 一维数组5.2.1 一维数组定义方式一维数组定义的三种方式： 数据类型 数组名[ 数组长度 ]; 数据类型 数组名[ 数组长度 ] = { 值1，值2 ...}; 数据类型 数组名[ ] = { 值1，值2 ...}; 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445int main() &#123; //定义方式1 //数据类型 数组名[元素个数]; int score[10]; //利用下标赋值 score[0] = 100; score[1] = 99; score[2] = 85; //利用下标输出 cout &lt;&lt; score[0] &lt;&lt; endl; cout &lt;&lt; score[1] &lt;&lt; endl; cout &lt;&lt; score[2] &lt;&lt; endl; //第二种定义方式 //数据类型 数组名[元素个数] = &#123;值1，值2 ，值3 ...&#125;; //如果&#123;&#125;内不足10个数据，剩余数据用0补全 int score2[10] = &#123; 100, 90,80,70,60,50,40,30,20,10 &#125;; //逐个输出 //cout &lt;&lt; score2[0] &lt;&lt; endl; //cout &lt;&lt; score2[1] &lt;&lt; endl; //一个一个输出太麻烦，因此可以利用循环进行输出 for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; score2[i] &lt;&lt; endl; &#125; //定义方式3 //数据类型 数组名[] = &#123;值1，值2 ，值3 ...&#125;; int score3[] = &#123; 100,90,80,70,60,50,40,30,20,10 &#125;; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; score3[i] &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名 总结2：数组中下标是从0开始索引 总结3：如果在初始化数组时，没有全部填写完，会用0来填补剩余数据 总结4：定义数组时，必须有初始长度 5.2.2 一维数组数组名一维数组名称的用途： 可以统计整个数组在内存中的长度 可以获取数组在内存中的首地址 示例： 12345678910111213141516171819202122int main() &#123; //数组名用途 //1、可以获取整个数组占用内存空间大小 int arr[10] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; cout &lt;&lt; \"整个数组所占内存空间为： \" &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; \"每个元素所占内存空间为： \" &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; \"数组的元素个数为： \" &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; //2、可以通过数组名获取到数组首地址 cout &lt;&lt; \"数组首地址为： \" &lt;&lt; (int)arr &lt;&lt; endl; cout &lt;&lt; \"数组中第一个元素地址为： \" &lt;&lt; (int)&amp;arr[0] &lt;&lt; endl; cout &lt;&lt; \"数组中第二个元素地址为： \" &lt;&lt; (int)&amp;arr[1] &lt;&lt; endl; //arr = 100; 错误，数组名是常量，因此不可以赋值 system(\"pause\"); return 0;&#125; 注意：数组名是常量，不可以赋值 总结1：直接打印数组名，可以查看数组所占内存的首地址 总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小 练习案例1：五只小猪称体重案例描述： 在一个数组中记录了五只小猪的体重，如：int arr[5] = {300,350,200,400,250}; 找出并打印最重的小猪体重。 1234567891011121314151617181920212223int main3() &#123; //1、创建5只小猪体重的数组 int arr[5] = &#123; 300,350,500,400,250 &#125;; //2、从数组中找到最大值 int max = 0; //先认定一个最大值为0 for (int i = 0; i &lt; 5; i++) &#123; //cout &lt;&lt; arr[i] &lt;&lt; endl; //如果访问的数组中的元素比我认定的最大值还有大，更新最大值 if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //3、打印最大值 cout &lt;&lt; \"最重的小猪体重为： \" &lt;&lt; max &lt;&lt; endl; system(\"pause\"); return 0;&#125; 练习案例2：数组元素逆置案例描述：请声明一个5个元素的数组，并且将元素逆置. (如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1); 1234567891011121314151617181920212223242526272829303132333435363738394041424344int main4() &#123; //实现数组元素逆置 //1、创建数组 int arr[5] = &#123; 1,3,2,5,4 &#125;; cout &lt;&lt; \"数组逆置前：\" &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; //2、实现逆置 //2.1记录起始下标位置 //2.2记录结束下标位置 //2.3起始下标与结束下标的元素互换 //2.4起始位置++ 结束位置-- //2.5循环执行2.1操作，直到起始位置 &gt;= 结束位置 int start = 0; //起始下标 int end = sizeof(arr) / sizeof(arr[0]) - 1; //结束下标 while (start &lt; end) &#123; //实现元素互换 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; //下标更新 start++; end--; &#125; //3、打印逆置后的数组 cout &lt;&lt; \"数组元素逆置后：\" &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 5.2.3 冒泡排序作用： 最常用的排序算法，对数组内元素进行排序 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。 重复以上的步骤，每次比较次数-1，直到不需要比较 示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序 1234567891011121314151617181920212223242526int main() &#123; int arr[9] = &#123; 4,2,8,0,5,7,1,3,9 &#125;; for (int i = 0; i &lt; 9 - 1; i++) &#123; for (int j = 0; j &lt; 9 - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 5.3 二维数组二维数组就是在一维数组上，多加一个维度。 5.3.1 二维数组定义方式二维数组定义的四种方式： 数据类型 数组名[ 行数 ][ 列数 ]; 数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } }; 数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4}; 建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041int main() &#123; //方式1 //数组类型 数组名 [行数][列数] int arr[2][3]; arr[0][0] = 1; arr[0][1] = 2; arr[0][2] = 3; arr[1][0] = 4; arr[1][1] = 5; arr[1][2] = 6; for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cout &lt;&lt; arr[i][j] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; //方式2 //数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;; int arr2[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; //方式3 //数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr3[2][3] = &#123; 1,2,3,4,5,6 &#125;; //方式4 //数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4 &#125;; int arr4[][3] = &#123; 1,2,3,4,5,6 &#125;; system(\"pause\"); return 0;&#125; 总结：在定义二维数组时，如果初始化了数据，可以省略行数 5.3.2 二维数组数组名 查看二维数组所占内存空间 获取二维数组首地址 示例： 12345678910111213141516171819202122232425262728int main() &#123; //二维数组数组名 int arr[2][3] = &#123; &#123;1,2,3&#125;, &#123;4,5,6&#125; &#125;; cout &lt;&lt; \"二维数组大小： \" &lt;&lt; sizeof(arr) &lt;&lt; endl; cout &lt;&lt; \"二维数组一行大小： \" &lt;&lt; sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; \"二维数组元素大小： \" &lt;&lt; sizeof(arr[0][0]) &lt;&lt; endl; cout &lt;&lt; \"二维数组行数： \" &lt;&lt; sizeof(arr) / sizeof(arr[0]) &lt;&lt; endl; cout &lt;&lt; \"二维数组列数： \" &lt;&lt; sizeof(arr[0]) / sizeof(arr[0][0]) &lt;&lt; endl; //地址 cout &lt;&lt; \"二维数组首地址：\" &lt;&lt; arr &lt;&lt; endl; cout &lt;&lt; \"二维数组第一行地址：\" &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; \"二维数组第二行地址：\" &lt;&lt; arr[1] &lt;&lt; endl; cout &lt;&lt; \"二维数组第一个元素地址：\" &lt;&lt; &amp;arr[0][0] &lt;&lt; endl; cout &lt;&lt; \"二维数组第二个元素地址：\" &lt;&lt; &amp;arr[0][1] &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结1：二维数组名就是这个数组的首地址 总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小 5.3.3 二维数组应用案例考试成绩统计： 案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，请分别输出三名同学的总成绩 语文 数学 英语 张三 100 100 100 李四 90 50 100 王五 60 70 80 参考答案： 12345678910111213141516171819202122232425int main() &#123; int scores[3][3] = &#123; &#123;100,100,100&#125;, &#123;90,50,100&#125;, &#123;60,70,80&#125;, &#125;; string names[3] = &#123; \"张三\",\"李四\",\"王五\" &#125;; for (int i = 0; i &lt; 3; i++) &#123; int sum = 0; for (int j = 0; j &lt; 3; j++) &#123; sum += scores[i][j]; &#125; cout &lt;&lt; names[i] &lt;&lt; \"同学总成绩为： \" &lt;&lt; sum &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 6 函数6.1 概述作用：将一段经常使用的代码封装起来，减少重复代码 一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。 6.2 函数的定义函数的定义一般主要有5个步骤： 1、返回值类型 2、函数名 3、参数表列 4、函数体语句 5、return 表达式 语法： 12345678返回值类型 函数名 （参数列表）&#123; 函数体语句 return表达式&#125; 返回值类型 ：一个函数可以返回一个值。在函数定义中 函数名：给函数起个名称 参数列表：使用该函数时，传入的数据 函数体语句：花括号内的代码，函数内需要执行的语句 return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据 示例：定义一个加法函数，实现两个数相加 123456//函数定义int add(int num1, int num2)&#123; int sum = num1 + num2; return sum;&#125; 6.3 函数的调用功能：使用定义好的函数 语法：函数名（参数） 示例： 12345678910111213141516171819202122232425//函数定义int add(int num1, int num2) //定义中的num1,num2称为形式参数，简称形参&#123; int sum = num1 + num2; return sum;&#125;int main() &#123; int a = 10; int b = 10; //调用add函数 int sum = add(a, b);//调用时的a，b称为实际参数，简称实参 cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; a = 100; b = 100; sum = add(a, b); cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参 6.4 值传递 所谓值传递，就是函数调用时实参将数值传入给形参 值传递时，如果形参发生，并不会影响实参 示例： 12345678910111213141516171819202122232425262728293031void swap(int num1, int num2)&#123; cout &lt;&lt; \"交换前：\" &lt;&lt; endl; cout &lt;&lt; \"num1 = \" &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; \"num2 = \" &lt;&lt; num2 &lt;&lt; endl; int temp = num1; num1 = num2; num2 = temp; cout &lt;&lt; \"交换后：\" &lt;&lt; endl; cout &lt;&lt; \"num1 = \" &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; \"num2 = \" &lt;&lt; num2 &lt;&lt; endl; //return ; 当函数声明时候，不需要返回值，可以不写return&#125;int main() &#123; int a = 10; int b = 20; swap(a, b); cout &lt;&lt; \"mian中的 a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"mian中的 b = \" &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结： 值传递时，形参是修饰不了实参的 6.5 函数的常见样式常见的函数样式有4种 无参无返 有参无返 无参有返 有参有返 示例： 123456789101112131415161718192021222324252627282930//函数常见样式//1、 无参无返void test01()&#123; //void a = 10; //无类型不可以创建变量,原因无法分配内存 cout &lt;&lt; \"this is test01\" &lt;&lt; endl; //test01(); 函数调用&#125;//2、 有参无返void test02(int a)&#123; cout &lt;&lt; \"this is test02\" &lt;&lt; endl; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl;&#125;//3、无参有返int test03()&#123; cout &lt;&lt; \"this is test03 \" &lt;&lt; endl; return 10;&#125;//4、有参有返int test04(int a, int b)&#123; cout &lt;&lt; \"this is test04 \" &lt;&lt; endl; int sum = a + b; return sum;&#125; 6.6 函数的声明作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数的声明可以多次，但是函数的定义只能有一次 示例： 123456789101112131415161718192021//声明可以多次，定义只能一次//声明int max(int a, int b);int max(int a, int b);//定义int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main() &#123; int a = 100; int b = 200; cout &lt;&lt; max(a, b) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 6.7 函数的分文件编写作用：让代码结构更加清晰 函数分文件编写一般有4个步骤 创建后缀名为.h的头文件 创建后缀名为.cpp的源文件 在头文件中写函数的声明 在源文件中写函数的定义 示例： 123456//swap.h文件#include&lt;iostream&gt;using namespace std;//实现两个数字交换的函数声明void swap(int a, int b); 123456789101112//swap.cpp文件#include \"swap.h\"void swap(int a, int b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;&#125; 123456789101112//main函数文件#include \"swap.h\"int main() &#123; int a = 100; int b = 200; swap(a, b); system(\"pause\"); return 0;&#125; 7 指针7.1 指针的基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 7.2 指针变量的定义和使用指针变量定义语法： 数据类型 * 变量名； 示例： 123456789101112131415161718192021int main() &#123; //1、指针的定义 int a = 10; //定义整型变量a //指针定义语法： 数据类型 * 变量名 ; int * p; //指针变量赋值 p = &amp;a; //指针指向变量a的地址 cout &lt;&lt; &amp;a &lt;&lt; endl; //打印数据a的地址 cout &lt;&lt; p &lt;&lt; endl; //打印指针变量p //2、指针的使用 //通过*操作指针变量指向的内存 cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; endl; system(\"pause\"); return 0;&#125; 指针变量和普通变量的区别 普通变量存放的是数据,指针变量存放的是地址 指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用 总结1： 我们可以通过 &amp; 符号 获取变量的地址 总结2：利用指针可以记录地址 总结3：对指针变量解引用，可以操作指针指向的内存 7.3 指针所占内存空间提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？ 示例： 1234567891011121314151617int main() &#123; int a = 10; int * p; p = &amp;a; //指针指向数据a的地址 cout &lt;&lt; *p &lt;&lt; endl; //* 解引用 cout &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; sizeof(double *) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：所有指针类型在32位操作系统下是4个字节 7.4 空指针和野指针空指针：指针变量指向内存中编号为0的空间 用途：初始化指针变量 注意：空指针指向的内存是不可以访问的 示例1：空指针 12345678910111213int main() &#123; //指针变量p指向内存地址编号为0的空间 int * p = NULL; //访问空指针报错 //内存编号0 ~255为系统占用内存，不允许用户访问 cout &lt;&lt; *p &lt;&lt; endl; system(\"pause\"); return 0;&#125; 野指针：指针变量指向非法的内存空间 示例2：野指针 123456789101112int main() &#123; //指针变量p指向内存地址编号为0x1100的空间 int * p = (int *)0x1100; //访问野指针报错 cout &lt;&lt; *p &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：空指针和野指针都不是我们申请的空间，因此不要访问。 7.5 const修饰指针const修饰指针有三种情况 const修饰指针 — 常量指针 const修饰常量 — 指针常量 const即修饰指针，又修饰常量 示例： 12345678910111213141516171819202122232425int main() &#123; int a = 10; int b = 10; //const修饰的是指针，指针指向可以改，指针指向的值不可以更改 const int * p1 = &amp;a; p1 = &amp;b; //正确 //*p1 = 100; 报错 //const修饰的是常量，指针指向不可以改，指针指向的值可以更改 int * const p2 = &amp;a; //p2 = &amp;b; //错误 *p2 = 100; //正确 //const既修饰指针又修饰常量 const int * const p3 = &amp;a; //p3 = &amp;b; //错误 //*p3 = 100; //错误 system(\"pause\"); return 0;&#125; 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量 7.6 指针和数组作用：利用指针访问数组中元素 示例： 1234567891011121314151617181920int main() &#123; int arr[] = &#123; 1,2,3,4,5,6,7,8,9,10 &#125;; int * p = arr; //指向数组的指针 cout &lt;&lt; \"第一个元素： \" &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; \"指针访问第一个元素： \" &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; //利用指针遍历数组 cout &lt;&lt; *p &lt;&lt; endl; p++; &#125; system(\"pause\"); return 0;&#125; 7.7 指针和函数作用：利用指针作函数参数，可以修改实参的值 示例： 12345678910111213141516171819202122232425262728293031//值传递void swap1(int a ,int b)&#123; int temp = a; a = b; b = temp;&#125;//地址传递void swap2(int * p1, int *p2)&#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;int main() &#123; int a = 10; int b = 20; swap1(a, b); // 值传递不会改变实参 swap2(&amp;a, &amp;b); //地址传递会改变实参 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递 7.8 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 }; 示例： 123456789101112131415161718192021222324252627282930313233343536373839//冒泡排序函数void bubbleSort(int * arr, int len) //int * arr 也可以写为int arr[]&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组函数void printArray(int arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;int main() &#123; int arr[10] = &#123; 4,3,6,9,1,2,10,8,7,5 &#125;; int len = sizeof(arr) / sizeof(int); bubbleSort(arr, len); printArray(arr, len); system(\"pause\"); return 0;&#125; 总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针 8 结构体8.1 结构体基本概念结构体属于用户 自定义的数据类型，允许用户存储不同的数据类型 8.2 结构体定义和使用语法：struct 结构体名 { 结构体成员列表 }； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 = { 成员1值 ， 成员2值…} 定义结构体时顺便创建变量 示例： 1234567891011121314151617181920212223242526272829303132333435363738//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;stu3; //结构体变量创建方式3 int main() &#123; //结构体变量创建方式1 struct student stu1; //struct 关键字可以省略 stu1.name = \"张三\"; stu1.age = 18; stu1.score = 100; cout &lt;&lt; \"姓名：\" &lt;&lt; stu1.name &lt;&lt; \" 年龄：\" &lt;&lt; stu1.age &lt;&lt; \" 分数：\" &lt;&lt; stu1.score &lt;&lt; endl; //结构体变量创建方式2 struct student stu2 = &#123; \"李四\",19,60 &#125;; cout &lt;&lt; \"姓名：\" &lt;&lt; stu2.name &lt;&lt; \" 年龄：\" &lt;&lt; stu2.age &lt;&lt; \" 分数：\" &lt;&lt; stu2.score &lt;&lt; endl; stu3.name = \"王五\"; stu3.age = 18; stu3.score = 80; cout &lt;&lt; \"姓名：\" &lt;&lt; stu3.name &lt;&lt; \" 年龄：\" &lt;&lt; stu3.age &lt;&lt; \" 分数：\" &lt;&lt; stu3.score &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结1：定义结构体时的关键字是struct，不可省略 总结2：创建结构体变量时，关键字struct可以省略 总结3：结构体变量利用操作符 ‘’.’’ 访问成员 8.3 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法：struct 结构体名 数组名[元素个数] = { {} , {} , ... {} } 示例： 12345678910111213141516171819202122232425262728//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;int main() &#123; //结构体数组 struct student arr[3]= &#123; &#123;\"张三\",18,80 &#125;, &#123;\"李四\",19,60 &#125;, &#123;\"王五\",20,70 &#125; &#125;; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; \"姓名：\" &lt;&lt; arr[i].name &lt;&lt; \" 年龄：\" &lt;&lt; arr[i].age &lt;&lt; \" 分数：\" &lt;&lt; arr[i].score &lt;&lt; endl; &#125; system(\"pause\"); return 0;&#125; 8.4 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt;可以通过结构体指针访问结构体属性 示例： 123456789101112131415161718192021222324//结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;int main() &#123; struct student stu = &#123; \"张三\",18,100, &#125;; struct student * p = &amp;stu; p-&gt;score = 80; //指针通过 -&gt; 操作符可以访问成员 cout &lt;&lt; \"姓名：\" &lt;&lt; p-&gt;name &lt;&lt; \" 年龄：\" &lt;&lt; p-&gt;age &lt;&lt; \" 分数：\" &lt;&lt; p-&gt;score &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员 8.5 结构体嵌套结构体作用： 结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 示例： 123456789101112131415161718192021222324252627282930313233343536373839//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//教师结构体定义struct teacher&#123; //成员列表 int id; //职工编号 string name; //教师姓名 int age; //教师年龄 struct student stu; //子结构体 学生&#125;;int main() &#123; struct teacher t1; t1.id = 10000; t1.name = \"老王\"; t1.age = 40; t1.stu.name = \"张三\"; t1.stu.age = 18; t1.stu.score = 100; cout &lt;&lt; \"教师 职工编号： \" &lt;&lt; t1.id &lt;&lt; \" 姓名： \" &lt;&lt; t1.name &lt;&lt; \" 年龄： \" &lt;&lt; t1.age &lt;&lt; endl; cout &lt;&lt; \"辅导学员 姓名： \" &lt;&lt; t1.stu.name &lt;&lt; \" 年龄：\" &lt;&lt; t1.stu.age &lt;&lt; \" 考试分数： \" &lt;&lt; t1.stu.score &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题 8.6 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 示例： 12345678910111213141516171819202122232425262728293031323334353637383940//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//值传递void printStudent(student stu )&#123; stu.age = 28; cout &lt;&lt; \"子函数中 姓名：\" &lt;&lt; stu.name &lt;&lt; \" 年龄： \" &lt;&lt; stu.age &lt;&lt; \" 分数：\" &lt;&lt; stu.score &lt;&lt; endl;&#125;//地址传递void printStudent2(student *stu)&#123; stu-&gt;age = 28; cout &lt;&lt; \"子函数中 姓名：\" &lt;&lt; stu-&gt;name &lt;&lt; \" 年龄： \" &lt;&lt; stu-&gt;age &lt;&lt; \" 分数：\" &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu = &#123; \"张三\",18,100&#125;; //值传递 printStudent(stu); cout &lt;&lt; \"主函数中 姓名：\" &lt;&lt; stu.name &lt;&lt; \" 年龄： \" &lt;&lt; stu.age &lt;&lt; \" 分数：\" &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; \"主函数中 姓名：\" &lt;&lt; stu.name &lt;&lt; \" 年龄： \" &lt;&lt; stu.age &lt;&lt; \" 分数：\" &lt;&lt; stu.score &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递 8.7 结构体中 const使用场景作用：用const来防止误操作 示例： 123456789101112131415161718192021222324252627//学生结构体定义struct student&#123; //成员列表 string name; //姓名 int age; //年龄 int score; //分数&#125;;//const使用场景void printStudent(const student *stu) //加const防止函数体中的误操作&#123; //stu-&gt;age = 100; //操作失败，因为加了const修饰 cout &lt;&lt; \"姓名：\" &lt;&lt; stu-&gt;name &lt;&lt; \" 年龄：\" &lt;&lt; stu-&gt;age &lt;&lt; \" 分数：\" &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu = &#123; \"张三\",18,100 &#125;; printStudent(&amp;stu); system(\"pause\"); return 0;&#125; 8.8 结构体案例8.8.1 案例1案例描述： 学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值 最终打印出老师数据以及老师所带的学生数据。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct Student&#123; string name; int score;&#125;;struct Teacher&#123; string name; Student sArray[5];&#125;;void allocateSpace(Teacher tArray[] , int len)&#123; string tName = \"教师\"; string sName = \"学生\"; string nameSeed = \"ABCDE\"; for (int i = 0; i &lt; len; i++) &#123; tArray[i].name = tName + nameSeed[i]; for (int j = 0; j &lt; 5; j++) &#123; tArray[i].sArray[j].name = sName + nameSeed[j]; tArray[i].sArray[j].score = rand() % 61 + 40; &#125; &#125;&#125;void printTeachers(Teacher tArray[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; tArray[i].name &lt;&lt; endl; for (int j = 0; j &lt; 5; j++) &#123; cout &lt;&lt; \"\\t姓名：\" &lt;&lt; tArray[i].sArray[j].name &lt;&lt; \" 分数：\" &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; srand((unsigned int)time(NULL)); //随机数种子 头文件 #include &lt;ctime&gt; Teacher tArray[3]; //老师数组 int len = sizeof(tArray) / sizeof(Teacher); allocateSpace(tArray, len); //创建数据 printTeachers(tArray, len); //打印数据 system(\"pause\"); return 0;&#125; 8.8.2 案例2案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 五名英雄信息如下： 12345&#123;\"刘备\",23,\"男\"&#125;,&#123;\"关羽\",22,\"男\"&#125;,&#123;\"张飞\",20,\"男\"&#125;,&#123;\"赵云\",21,\"男\"&#125;,&#123;\"貂蝉\",19,\"女\"&#125;, 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//英雄结构体struct hero&#123; string name; int age; string sex;&#125;;//冒泡排序void bubbleSort(hero arr[] , int len)&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j].age &gt; arr[j + 1].age) &#123; hero temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组void printHeros(hero arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; arr[i].name &lt;&lt; \" 性别： \" &lt;&lt; arr[i].sex &lt;&lt; \" 年龄： \" &lt;&lt; arr[i].age &lt;&lt; endl; &#125;&#125;int main() &#123; struct hero arr[5] = &#123; &#123;\"刘备\",23,\"男\"&#125;, &#123;\"关羽\",22,\"男\"&#125;, &#123;\"张飞\",20,\"男\"&#125;, &#123;\"赵云\",21,\"男\"&#125;, &#123;\"貂蝉\",19,\"女\"&#125;, &#125;; int len = sizeof(arr) / sizeof(hero); //获取数组元素个数 bubbleSort(arr, len); //排序 printHeros(arr, len); //打印 system(\"pause\"); return 0;&#125; 义struct student{ //成员列表 string name; //姓名 int age; //年龄 int score; //分数}; //值传递void printStudent(student stu ){ stu.age = 28; cout &lt;&lt; “子函数中 姓名：” &lt;&lt; stu.name &lt;&lt; “ 年龄： “ &lt;&lt; stu.age &lt;&lt; “ 分数：” &lt;&lt; stu.score &lt;&lt; endl;} //地址传递void printStudent2(student *stu){ stu-&gt;age = 28; cout &lt;&lt; “子函数中 姓名：” &lt;&lt; stu-&gt;name &lt;&lt; “ 年龄： “ &lt;&lt; stu-&gt;age &lt;&lt; “ 分数：” &lt;&lt; stu-&gt;score &lt;&lt; endl;} int main() { student stu = { &quot;张三&quot;,18,100}; //值传递 printStudent(stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; cout &lt;&lt; endl; //地址传递 printStudent2(&amp;stu); cout &lt;&lt; &quot;主函数中 姓名：&quot; &lt;&lt; stu.name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stu.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu.score &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243&gt; 总结：如果不想修改主函数中的数据，用值传递，反之用地址传递### 8.7 结构体中 const使用场景**作用：**用const来防止误操作**示例：**&#96;&#96;&#96;C++&#x2F;&#x2F;学生结构体定义struct student&#123; &#x2F;&#x2F;成员列表 string name; &#x2F;&#x2F;姓名 int age; &#x2F;&#x2F;年龄 int score; &#x2F;&#x2F;分数&#125;;&#x2F;&#x2F;const使用场景void printStudent(const student *stu) &#x2F;&#x2F;加const防止函数体中的误操作&#123; &#x2F;&#x2F;stu-&gt;age &#x3D; 100; &#x2F;&#x2F;操作失败，因为加了const修饰 cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; stu-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; stu-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; stu-&gt;score &lt;&lt; endl;&#125;int main() &#123; student stu &#x3D; &#123; &quot;张三&quot;,18,100 &#125;; printStudent(&amp;stu); system(&quot;pause&quot;); return 0;&#125;","categories":[],"tags":[]},{"title":"C++提高编程","slug":"C++提高编程","date":"2020-03-20T14:37:52.681Z","updated":"2020-03-20T15:03:10.638Z","comments":true,"path":"2020/03/20/C++提高编程/","link":"","permalink":"http://yoursite.com/2020/03/20/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/","excerpt":"","text":"C++提高编程 本阶段主要针对C++泛型编程和STL技术做详细讲解，探讨C++更深层的使用 1 模板1.1 模板的概念模板就是建立通用的模具，大大提高复用性 例如生活中的模板 一寸照片模板： PPT模板： 模板的特点： 模板不可以直接使用，它只是一个框架 模板的通用并不是万能的 1.2 函数模板 C++另一种编程思想称为 泛型编程 ，主要利用的技术就是模板 C++提供两种模板机制:函数模板和类模板 1.2.1 函数模板语法函数模板作用： 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12template&lt;typename T&gt;函数声明或定义 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//交换整型函数void swapInt(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;//交换浮点型函数void swapDouble(double&amp; a, double&amp; b) &#123; double temp = a; a = b; b = temp;&#125;//利用模板提供通用的交换函数template&lt;typename T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; //swapInt(a, b); //利用模板实现交换 //1、自动类型推导 mySwap(a, b); //2、显示指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 函数模板利用关键字 template 使用函数模板有两种方式：自动类型推导、显示指定类型 模板的目的是为了提高复用性，将类型参数化 1.2.2 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T,才可以使用 模板必须要确定出T的数据类型，才可以使用 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//利用模板提供通用的交换函数template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用void test01()&#123; int a = 10; int b = 20; char c = 'c'; mySwap(a, b); // 正确，可以推导出一致的T //mySwap(a, c); // 错误，推导不出一致的T类型&#125;// 2、模板必须要确定出T的数据类型，才可以使用template&lt;class T&gt;void func()&#123; cout &lt;&lt; \"func 调用\" &lt;&lt; endl;&#125;void test02()&#123; //func(); //错误，模板不能独立使用，必须确定出T的类型 func&lt;int&gt;(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型 1.2.3 函数模板案例案例描述： 利用函数模板封装一个排序的函数，可以对不同数据类型数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//交换的函数模板template&lt;typename T&gt;void mySwap(T &amp;a, T&amp;b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt; // 也可以替换成typename//利用选择排序，进行对数组从大到小的排序void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; //最大数的下标 for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) //如果最大数的下标不是i，交换两者 &#123; mySwap(arr[max], arr[i]); &#125; &#125;&#125;template&lt;typename T&gt;void printArray(T arr[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //测试char数组 char charArr[] = \"bdcfeagh\"; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; //测试int数组 int intArr[] = &#123; 7, 5, 8, 1, 3, 9, 2, 4, 6 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结：模板可以提高代码复用，需要熟练掌握 1.2.4 普通函数与函数模板的区别普通函数与函数模板区别： 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 示例： 1234567891011121314151617181920212223242526272829303132333435//普通函数int myAdd01(int a, int b)&#123; return a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b) &#123; return a + b;&#125;//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换void test01()&#123; int a = 10; int b = 20; char c = 'c'; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的'c'隐式转换为int类型 'c' 对应 ASCII码 99 //myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换 myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T 1.2.5 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以产生更好的匹配,优先调用函数模板 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//普通函数与函数模板调用规则void myPrint(int a, int b)&#123; cout &lt;&lt; \"调用的普通函数\" &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b) &#123; cout &lt;&lt; \"调用的模板\" &lt;&lt; endl;&#125;template&lt;typename T&gt;void myPrint(T a, T b, T c) &#123; cout &lt;&lt; \"调用重载的模板\" &lt;&lt; endl; &#125;void test01()&#123; //1、如果函数模板和普通函数都可以实现，优先调用普通函数 // 注意 如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到 int a = 10; int b = 20; myPrint(a, b); //调用普通函数 //2、可以通过空模板参数列表来强制调用函数模板 myPrint&lt;&gt;(a, b); //调用函数模板 //3、函数模板也可以发生重载 int c = 30; myPrint(a, b, c); //调用重载的函数模板 //4、 如果函数模板可以产生更好的匹配,优先调用函数模板 char c1 = 'a'; char c2 = 'b'; myPrint(c1, c2); //调用函数模板&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性 1.2.6 模板的局限性局限性： 模板的通用性并不是万能的 例如： 12345template&lt;class T&gt;void f(T a, T b)&#123; a = b; &#125; 在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了 再例如： 12345template&lt;class T&gt;void f(T a, T b)&#123; if(a &gt; b) &#123; ... &#125; &#125; 在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行 因此C++为了解决这种问题，提供模板的重载，可以为这些特定的类型提供具体化的模板 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;using namespace std;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;//普通函数模板template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型//具体化优先于常规模板template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)&#123; if ( p1.m_Name == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123; return true; &#125; else &#123; return false; &#125;&#125;void test01()&#123; int a = 10; int b = 20; //内置数据类型可以直接使用通用的函数模板 bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; \"a == b \" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"a != b \" &lt;&lt; endl; &#125;&#125;void test02()&#123; Person p1(\"Tom\", 10); Person p2(\"Tom\", 10); //自定义数据类型，不会调用普通的函数模板 //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型 bool ret = myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; \"p1 == p2 \" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"p1 != p2 \" &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板 1.3 类模板1.3.1 类模板语法类模板作用： 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型来代表。 语法： 12template&lt;typename T&gt;类 解释： template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;mName &lt;&lt; \" age: \" &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;void test01()&#123; // 指定NameType 为string类型，AgeType 为 int类型 Person&lt;string, int&gt;P1(\"孙悟空\", 999); P1.showPerson();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板 1.3.2 类模板与函数模板区别类模板与函数模板区别主要有两点： 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;mName &lt;&lt; \" age: \" &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、类模板没有自动类型推导的使用方式void test01()&#123; // Person p(\"孙悟空\", 1000); // 错误 类模板使用时候，不可以用自动类型推导 Person &lt;string ,int&gt;p(\"孙悟空\", 1000); //必须使用显示指定类型的方式，使用类模板 p.showPerson();&#125;//2、类模板在模板参数列表中可以有默认参数void test02()&#123; Person &lt;string&gt; p(\"猪八戒\", 999); //类模板中的模板参数列表 可以指定默认参数 p.showPerson();&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 类模板使用只能用显示指定类型方式 类模板中的模板参数列表可以有默认参数 1.3.3 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的： 普通类中的成员函数一开始就可以创建 类模板中的成员函数在调用时才创建 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Person1&#123;public: void showPerson1() &#123; cout &lt;&lt; \"Person1 show\" &lt;&lt; endl; &#125;&#125;;class Person2&#123;public: void showPerson2() &#123; cout &lt;&lt; \"Person2 show\" &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;class MyClass&#123;public: T obj; //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成 void fun1() &#123; obj.showPerson1(); &#125; void fun2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123; MyClass&lt;Person1&gt; m; m.fun1(); //m.fun2();//编译会出错，说明函数调用才会去创建成员函数&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建 1.3.4 类模板对象做函数参数学习目标： 类模板实例化出的对象，向函数传参的方式 一共有三种传入方式： 指定传入的类型 — 直接显示对象的数据类型 参数模板化 — 将对象中的参数变为模板进行传递 整个类模板化 — 将这个对象类型 模板化进行传递 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;string&gt;//类模板template&lt;class NameType, class AgeType = int&gt; class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;mName = name; this-&gt;mAge = age; &#125; void showPerson() &#123; cout &lt;&lt; \"name: \" &lt;&lt; this-&gt;mName &lt;&lt; \" age: \" &lt;&lt; this-&gt;mAge &lt;&lt; endl; &#125;public: NameType mName; AgeType mAge;&#125;;//1、指定传入的类型void printPerson1(Person&lt;string, int&gt; &amp;p) &#123; p.showPerson();&#125;void test01()&#123; Person &lt;string, int &gt;p(\"孙悟空\", 100); printPerson1(p);&#125;//2、参数模板化template &lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; \"T1的类型为： \" &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; \"T2的类型为： \" &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123; Person &lt;string, int &gt;p(\"猪八戒\", 90); printPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T &amp; p)&#123; cout &lt;&lt; \"T的类型为： \" &lt;&lt; typeid(T).name() &lt;&lt; endl; p.showPerson();&#125;void test03()&#123; Person &lt;string, int &gt;p(\"唐僧\", 30); printPerson3(p);&#125;int main() &#123; test01(); test02(); test03(); system(\"pause\"); return 0;&#125; 总结： 通过类模板创建的对象，可以有三种方式向函数中进行传参 使用比较广泛是第一种：指定传入的类型 1.3.5 类模板与继承当类模板碰到继承时，需要注意一下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;class T&gt;class Base&#123; T m;&#125;;//class Son:public Base //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承class Son :public Base&lt;int&gt; //必须指定一个类型&#123;&#125;;void test01()&#123; Son c;&#125;//类模板继承类模板 ,可以用T2指定父类中的T类型template&lt;class T1, class T2&gt;class Son2 :public Base&lt;T2&gt;&#123;public: Son2() &#123; cout &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125;&#125;;void test02()&#123; Son2&lt;int, char&gt; child1;&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结：如果父类是类模板，子类需要指定出父类中T的数据类型 1.3.6 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数类外实现 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;string&gt;//类模板中成员函数类外实现template&lt;class T1, class T2&gt;class Person &#123;public: //成员函数类内声明 Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; \"姓名: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" 年龄:\" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; Person&lt;string, int&gt; p(\"Tom\", 20); p.showPerson();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：类模板中成员函数类外实现时，需要加上模板参数列表 1.3.7 类模板分文件编写学习目标： 掌握类模板成员函数分文件编写产生的问题以及解决方式 问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 示例： person.hpp中代码： 123456789101112131415161718192021222324252627#pragma once#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;template&lt;class T1, class T2&gt;class Person &#123;public: Person(T1 name, T2 age); void showPerson();public: T1 m_Name; T2 m_Age;&#125;;//构造函数 类外实现template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数 类外实现template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson() &#123; cout &lt;&lt; \"姓名: \" &lt;&lt; this-&gt;m_Name &lt;&lt; \" 年龄:\" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; 类模板分文件编写.cpp中代码 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;//#include \"person.h\"#include \"person.cpp\" //解决方式1，包含cpp源文件//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp#include \"person.hpp\"void test01()&#123; Person&lt;string, int&gt; p(\"Tom\", 10); p.showPerson();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp 1.3.8 类模板与友元学习目标： 掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可 全局函数类外实现 - 需要提前让编译器知道全局函数的存在 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;string&gt;//2、全局函数配合友元 类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元template&lt;class T1, class T2&gt; class Person;//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt; &amp; p)&#123; cout &lt;&lt; \"类外实现 ---- 姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄：\" &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1, class T2&gt;class Person&#123; //1、全局函数配合友元 类内实现 friend void printPerson(Person&lt;T1, T2&gt; &amp; p) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄：\" &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //全局函数配合友元 类外实现 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123; Person &lt;string, int &gt;p(\"Tom\", 20); printPerson(p);&#125;//2、全局函数在类外实现void test02()&#123; Person &lt;string, int &gt;p(\"Jerry\", 30); printPerson2(p);&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别 1.3.9 类模板案例案例描述: 实现一个通用的数组类，要求如下： 可以对内置数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator=防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 示例： myArray.hpp中代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#pragma once#include &lt;iostream&gt;using namespace std;template&lt;class T&gt;class MyArray&#123;public: //构造函数 MyArray(int capacity) &#123; this-&gt;m_Capacity = capacity; this-&gt;m_Size = 0; pAddress = new T[this-&gt;m_Capacity]; &#125; //拷贝构造 MyArray(const MyArray &amp; arr) &#123; this-&gt;m_Capacity = arr.m_Capacity; this-&gt;m_Size = arr.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值， // 普通类型可以直接= 但是指针类型需要深拷贝 this-&gt;pAddress[i] = arr.pAddress[i]; &#125; &#125; //重载= 操作符 防止浅拷贝问题 MyArray&amp; operator=(const MyArray&amp; myarray) &#123; if (this-&gt;pAddress != NULL) &#123; delete[] this-&gt;pAddress; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; &#125; this-&gt;m_Capacity = myarray.m_Capacity; this-&gt;m_Size = myarray.m_Size; this-&gt;pAddress = new T[this-&gt;m_Capacity]; for (int i = 0; i &lt; this-&gt;m_Size; i++) &#123; this-&gt;pAddress[i] = myarray[i]; &#125; return *this; &#125; //重载[] 操作符 arr[0] T&amp; operator [](int index) &#123; return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理 &#125; //尾插法 void Push_back(const T &amp; val) &#123; if (this-&gt;m_Capacity == this-&gt;m_Size) &#123; return; &#125; this-&gt;pAddress[this-&gt;m_Size] = val; this-&gt;m_Size++; &#125; //尾删法 void Pop_back() &#123; if (this-&gt;m_Size == 0) &#123; return; &#125; this-&gt;m_Size--; &#125; //获取数组容量 int getCapacity() &#123; return this-&gt;m_Capacity; &#125; //获取数组大小 int getSize() &#123; return this-&gt;m_Size; &#125; //析构 ~MyArray() &#123; if (this-&gt;pAddress != NULL) &#123; delete[] this-&gt;pAddress; this-&gt;pAddress = NULL; this-&gt;m_Capacity = 0; this-&gt;m_Size = 0; &#125; &#125;private: T * pAddress; //指向一个堆空间，这个空间存储真正的数据 int m_Capacity; //容量 int m_Size; // 大小&#125;; 类模板案例—数组类封装.cpp中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include \"myArray.hpp\"#include &lt;string&gt;void printIntArray(MyArray&lt;int&gt;&amp; arr) &#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//测试内置数据类型void test01()&#123; MyArray&lt;int&gt; array1(10); for (int i = 0; i &lt; 10; i++) &#123; array1.Push_back(i); &#125; cout &lt;&lt; \"array1打印输出：\" &lt;&lt; endl; printIntArray(array1); cout &lt;&lt; \"array1的大小：\" &lt;&lt; array1.getSize() &lt;&lt; endl; cout &lt;&lt; \"array1的容量：\" &lt;&lt; array1.getCapacity() &lt;&lt; endl; cout &lt;&lt; \"--------------------------\" &lt;&lt; endl; MyArray&lt;int&gt; array2(array1); array2.Pop_back(); cout &lt;&lt; \"array2打印输出：\" &lt;&lt; endl; printIntArray(array2); cout &lt;&lt; \"array2的大小：\" &lt;&lt; array2.getSize() &lt;&lt; endl; cout &lt;&lt; \"array2的容量：\" &lt;&lt; array2.getCapacity() &lt;&lt; endl;&#125;//测试自定义数据类型class Person &#123;public: Person() &#123;&#125; Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; personArr)&#123; for (int i = 0; i &lt; personArr.getSize(); i++) &#123; cout &lt;&lt; \"姓名：\" &lt;&lt; personArr[i].m_Name &lt;&lt; \" 年龄： \" &lt;&lt; personArr[i].m_Age &lt;&lt; endl; &#125;&#125;void test02()&#123; //创建数组 MyArray&lt;Person&gt; pArray(10); Person p1(\"孙悟空\", 30); Person p2(\"韩信\", 20); Person p3(\"妲己\", 18); Person p4(\"王昭君\", 15); Person p5(\"赵云\", 24); //插入数据 pArray.Push_back(p1); pArray.Push_back(p2); pArray.Push_back(p3); pArray.Push_back(p4); pArray.Push_back(p5); printPersonArray(pArray); cout &lt;&lt; \"pArray的大小：\" &lt;&lt; pArray.getSize() &lt;&lt; endl; cout &lt;&lt; \"pArray的容量：\" &lt;&lt; pArray.getCapacity() &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 能够利用所学知识点实现通用的数组 2 STL初识2.1 STL的诞生 长久以来，软件界一直希望建立一种可重复利用的东西 C++的面向对象和泛型编程思想，目的就是复用性的提升 大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作 为了建立数据结构和算法的一套标准,诞生了STL ​ 2.2 STL基本概念 STL(Standard Template Library,标准模板库) STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator) 容器和算法之间通过迭代器进行无缝连接。 STL 几乎所有的代码都采用了模板类或者模板函数 2.3 STL六大组件STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。 算法：各种常用的算法，如sort、find、copy、for_each等 迭代器：扮演了容器与算法之间的胶合剂。 仿函数：行为类似函数，可作为算法的某种策略。 适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。 空间配置器：负责空间的配置与管理。 2.4 STL中容器、算法、迭代器容器：置物之所也 STL容器就是将运用最广泛的一些数据结构实现出来 常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等 这些容器分为序列式容器和关联式容器两种: ​ 序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系 算法：问题之解法也 有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms) 算法分为:质变算法和非质变算法。 质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等 非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等 迭代器：容器和算法之间粘合剂 提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。 每个容器都有自己专属的迭代器 迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针 迭代器种类： 种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、==、！= 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、==、！= 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、–， 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;= 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器 2.5 容器算法迭代器初识了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力 STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器 2.5.1 vector存放内置数据类型容器： vector 算法： for_each 迭代器： vector&lt;int&gt;::iterator 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;vector&gt;#include &lt;algorithm&gt;void MyPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;void test01() &#123; //创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型 vector&lt;int&gt; v; //向容器中放数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素 //v.begin()返回迭代器，这个迭代器指向容器中第一个数据 //v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置 //vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型 vector&lt;int&gt;::iterator pBegin = v.begin(); vector&lt;int&gt;::iterator pEnd = v.end(); //第一种遍历方式： while (pBegin != pEnd) &#123; cout &lt;&lt; *pBegin &lt;&lt; endl; pBegin++; &#125; //第二种遍历方式： for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; cout &lt;&lt; endl; //第三种遍历方式： //使用STL提供标准遍历算法 头文件 algorithm for_each(v.begin(), v.end(), MyPrint);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 2.5.2 Vector存放自定义数据类型学习目标：vector中存放自定义数据类型，并打印输出 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;vector&gt;#include &lt;string&gt;//自定义数据类型class Person &#123;public: Person(string name, int age) &#123; mName = name; mAge = age; &#125;public: string mName; int mAge;&#125;;//存放对象void test01() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); Person p5(\"eee\", 50); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; \"Name:\" &lt;&lt; (*it).mName &lt;&lt; \" Age:\" &lt;&lt; (*it).mAge &lt;&lt; endl; &#125;&#125;//放对象指针void test02() &#123; vector&lt;Person*&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); Person p5(\"eee\", 50); v.push_back(&amp;p1); v.push_back(&amp;p2); v.push_back(&amp;p3); v.push_back(&amp;p4); v.push_back(&amp;p5); for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; Person * p = (*it); cout &lt;&lt; \"Name:\" &lt;&lt; p-&gt;mName &lt;&lt; \" Age:\" &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 2.5.3 Vector容器嵌套容器学习目标：容器中嵌套容器，我们将所有数据进行遍历输出 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;vector&gt;//容器嵌套容器void test01() &#123; vector&lt; vector&lt;int&gt; &gt; v; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; v3; vector&lt;int&gt; v4; for (int i = 0; i &lt; 4; i++) &#123; v1.push_back(i + 1); v2.push_back(i + 2); v3.push_back(i + 3); v4.push_back(i + 4); &#125; //将容器元素插入到vector v中 v.push_back(v1); v.push_back(v2); v.push_back(v3); v.push_back(v4); for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123; cout &lt;&lt; *vit &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 3 STL- 常用容器3.1 string容器3.1.1 string基本概念本质： string是C++风格的字符串，而string本质上是一个类 string和char * 区别： char * 是一个指针 string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 特点： string 类内部封装了很多成员方法 例如：查找find，拷贝copy，删除delete 替换replace，插入insert string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责 3.1.2 string构造函数构造函数原型： string(); //创建一个空的字符串 例如: string str; string(const char* s); //使用字符串s初始化 string(const string&amp; str); //使用一个string对象初始化另一个string对象 string(int n, char c); //使用n个字符c初始化 示例： 123456789101112131415161718192021222324252627#include &lt;string&gt;//string构造void test01()&#123; string s1; //创建空字符串，调用无参构造函数 cout &lt;&lt; \"str1 = \" &lt;&lt; s1 &lt;&lt; endl; const char* str = \"hello world\"; string s2(str); //把c_string转换成了string cout &lt;&lt; \"str2 = \" &lt;&lt; s2 &lt;&lt; endl; string s3(s2); //调用拷贝构造函数 cout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl; string s4(10, 'a'); cout &lt;&lt; \"str3 = \" &lt;&lt; s3 &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：string的多种构造方式没有可比性，灵活使用即可 3.1.3 string赋值操作功能描述： 给string字符串进行赋值 赋值的函数原型： string&amp; operator=(const char* s); //char*类型字符串 赋值给当前的字符串 string&amp; operator=(const string &amp;s); //把字符串s赋给当前的字符串 string&amp; operator=(char c); //字符赋值给当前的字符串 string&amp; assign(const char *s); //把字符串s赋给当前的字符串 string&amp; assign(const char *s, int n); //把字符串s的前n个字符赋给当前的字符串 string&amp; assign(const string &amp;s); //把字符串s赋给当前字符串 string&amp; assign(int n, char c); //用n个字符c赋给当前字符串 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//赋值void test01()&#123; string str1; str1 = \"hello world\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2; str2 = str1; cout &lt;&lt; \"str2 = \" &lt;&lt; str2 &lt;&lt; endl; string str3; str3 = 'a'; cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl; string str4; str4.assign(\"hello c++\"); cout &lt;&lt; \"str4 = \" &lt;&lt; str4 &lt;&lt; endl; string str5; str5.assign(\"hello c++\",5); cout &lt;&lt; \"str5 = \" &lt;&lt; str5 &lt;&lt; endl; string str6; str6.assign(str5); cout &lt;&lt; \"str6 = \" &lt;&lt; str6 &lt;&lt; endl; string str7; str7.assign(5, 'x'); cout &lt;&lt; \"str7 = \" &lt;&lt; str7 &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： ​ string的赋值方式很多，operator= 这种方式是比较实用的 3.1.4 string字符串拼接功能描述： 实现在字符串末尾拼接字符串 函数原型： string&amp; operator+=(const char* str); //重载+=操作符 string&amp; operator+=(const char c); //重载+=操作符 string&amp; operator+=(const string&amp; str); //重载+=操作符 string&amp; append(const char *s); //把字符串s连接到当前字符串结尾 string&amp; append(const char *s, int n); //把字符串s的前n个字符连接到当前字符串结尾 string&amp; append(const string &amp;s); //同operator+=(const string&amp; str) string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾 示例： 12345678910111213141516171819202122232425262728293031323334//字符串拼接void test01()&#123; string str1 = \"我\"; str1 += \"爱玩游戏\"; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; str1 += ':'; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str2 = \"LOL DNF\"; str1 += str2; cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl; string str3 = \"I\"; str3.append(\" love \"); str3.append(\"game abcde\", 4); //str3.append(str2); str3.append(str2, 4, 3); // 从下标4位置开始 ，截取3个字符，拼接到字符串末尾 cout &lt;&lt; \"str3 = \" &lt;&lt; str3 &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：字符串拼接的重载版本很多，初学阶段记住几种即可 3.1.5 string查找和替换功能描述： 查找：查找指定字符串是否存在 替换：在指定的位置替换字符串 函数原型： int find(const string&amp; str, int pos = 0) const; //查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos = 0) const; //查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos = 0) const; //查找字符c第一次出现位置 int rfind(const string&amp; str, int pos = npos) const; //查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos = npos) const; //查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const; //从pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos = 0) const; //查找字符c最后一次出现位置 string&amp; replace(int pos, int n, const string&amp; str); //替换从pos开始n个字符为字符串str string&amp; replace(int pos, int n,const char* s); //替换从pos开始的n个字符为字符串s 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142//查找和替换void test01()&#123; //查找 string str1 = \"abcdefgde\"; int pos = str1.find(\"de\"); if (pos == -1) &#123; cout &lt;&lt; \"未找到\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl; &#125; pos = str1.rfind(\"de\"); cout &lt;&lt; \"pos = \" &lt;&lt; pos &lt;&lt; endl;&#125;void test02()&#123; //替换 string str1 = \"abcdefgde\"; str1.replace(1, 3, \"1111\"); cout &lt;&lt; \"str1 = \" &lt;&lt; str1 &lt;&lt; endl;&#125;int main() &#123; //test01(); //test02(); system(\"pause\"); return 0;&#125; 总结： find查找是从左往后，rfind从右往左 find找到字符串后返回查找的第一个字符位置，找不到返回-1 replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串 3.1.6 string字符串比较功能描述： 字符串之间的比较 比较方式： 字符串比较是按字符的ASCII码进行对比 = 返回 0 &gt; 返回 1 &lt; 返回 -1 函数原型： int compare(const string &amp;s) const; //与字符串s比较 int compare(const char *s) const; //与字符串s比较 示例： 12345678910111213141516171819202122232425262728293031//字符串比较void test01()&#123; string s1 = \"hello\"; string s2 = \"aello\"; int ret = s1.compare(s2); if (ret == 0) &#123; cout &lt;&lt; \"s1 等于 s2\" &lt;&lt; endl; &#125; else if (ret &gt; 0) &#123; cout &lt;&lt; \"s1 大于 s2\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"s1 小于 s2\" &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大 3.1.7 string字符存取string中单个字符存取方式有两种 char&amp; operator[](int n); //通过[]方式取字符 char&amp; at(int n); //通过at方法获取字符 示例： 1234567891011121314151617181920212223242526272829303132void test01()&#123; string str = \"hello world\"; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; str.size(); i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //字符修改 str[0] = 'x'; str.at(1) = 'x'; cout &lt;&lt; str &lt;&lt; endl; &#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at 3.1.8 string插入和删除功能描述： 对string字符串进行插入和删除字符操作 函数原型： string&amp; insert(int pos, const char* s); //插入字符串 string&amp; insert(int pos, const string&amp; str); //插入字符串 string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符c string&amp; erase(int pos, int n = npos); //删除从Pos开始的n个字符 示例： 12345678910111213141516171819//字符串插入和删除void test01()&#123; string str = \"hello\"; str.insert(1, \"111\"); cout &lt;&lt; str &lt;&lt; endl; str.erase(1, 3); //从1号位置开始3个字符 cout &lt;&lt; str &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：插入和删除的起始下标都是从0开始 3.1.9 string子串功能描述： 从字符串中获取想要的子串 函数原型： string substr(int pos = 0, int n = npos) const; //返回由pos开始的n个字符组成的字符串 示例： 1234567891011121314151617181920212223//子串void test01()&#123; string str = \"abcdefg\"; string subStr = str.substr(1, 3); cout &lt;&lt; \"subStr = \" &lt;&lt; subStr &lt;&lt; endl; string email = \"hello@sina.com\"; int pos = email.find(\"@\"); string username = email.substr(0, pos); cout &lt;&lt; \"username: \" &lt;&lt; username &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：灵活的运用求子串功能，可以在实际开发中获取有效的信息 3.2 vector容器3.2.1 vector基本概念功能： vector数据结构和数组非常相似，也称为单端数组 vector与普通数组区别： 不同之处在于数组是静态空间，而vector可以动态扩展 动态扩展： 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间 vector容器的迭代器是支持随机访问的迭代器 3.2.2 vector构造函数功能描述： 创建vector容器 函数原型： vector&lt;T&gt; v; //采用模板实现类实现，默认构造函数 vector(v.begin(), v.end()); //将v[begin(), end())区间中的元素拷贝给本身。 vector(n, elem); //构造函数将n个elem拷贝给本身。 vector(const vector &amp;vec); //拷贝构造函数。 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt; v2(v1.begin(), v1.end()); printVector(v2); vector&lt;int&gt; v3(10, 100); printVector(v3); vector&lt;int&gt; v4(v3); printVector(v4);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：vector的多种构造方式没有可比性，灵活使用即可 3.2.3 vector赋值操作功能描述： 给vector容器进行赋值 函数原型： vector&amp; operator=(const vector &amp;vec);//重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123; vector&lt;int&gt; v1; //无参构造 for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; v2 = v1; printVector(v2); vector&lt;int&gt;v3; v3.assign(v1.begin(), v1.end()); printVector(v3); vector&lt;int&gt;v4; v4.assign(10, 100); printVector(v4);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： vector赋值方式比较简单，使用operator=，或者assign都可以 3.2.4 vector容量和大小功能描述： 对vector容器的容量和大小操作 函数原型： empty(); //判断容器是否为空 capacity(); //容器的容量 size(); //返回容器中元素的个数 resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); if (v1.empty()) &#123; cout &lt;&lt; \"v1为空\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"v1不为空\" &lt;&lt; endl; cout &lt;&lt; \"v1的容量 = \" &lt;&lt; v1.capacity() &lt;&lt; endl; cout &lt;&lt; \"v1的大小 = \" &lt;&lt; v1.size() &lt;&lt; endl; &#125; //resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充 v1.resize(15,10); printVector(v1); //resize 重新指定大小 ，若指定的更小，超出部分元素被删除 v1.resize(5); printVector(v1);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 判断是否为空 — empty 返回元素个数 — size 返回容器容量 — capacity 重新指定大小 — resize 3.2.5 vector插入和删除功能描述： 对vector容器进行插入、删除操作 函数原型： push_back(ele); //尾部插入元素ele pop_back(); //删除最后一个元素 insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素ele erase(const_iterator pos); //删除迭代器指向的元素 erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素 clear(); //删除容器中所有元素 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; vector&lt;int&gt; v1; //尾插 v1.push_back(10); v1.push_back(20); v1.push_back(30); v1.push_back(40); v1.push_back(50); printVector(v1); //尾删 v1.pop_back(); printVector(v1); //插入 v1.insert(v1.begin(), 100); printVector(v1); v1.insert(v1.begin(), 2, 1000); printVector(v1); //删除 v1.erase(v1.begin()); printVector(v1); //清空 v1.erase(v1.begin(), v1.end()); v1.clear(); printVector(v1);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 尾插 — push_back 尾删 — pop_back 插入 — insert (位置迭代器) 删除 — erase （位置迭代器） 清空 — clear 3.2.6 vector数据存取功能描述： 对vector中的数据的存取操作 函数原型： at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; v1.size(); i++) &#123; cout &lt;&lt; v1.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; cout &lt;&lt; \"v1的第一个元素为： \" &lt;&lt; v1.front() &lt;&lt; endl; cout &lt;&lt; \"v1的最后一个元素为： \" &lt;&lt; v1.back() &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 除了用迭代器获取vector容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.2.7 vector互换容器功能描述： 实现两个容器内元素进行互换 函数原型： swap(vec); // 将vec与本身的元素互换 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;vector&gt;void printVector(vector&lt;int&gt;&amp; v) &#123; for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; vector&lt;int&gt;v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); &#125; printVector(v1); vector&lt;int&gt;v2; for (int i = 10; i &gt; 0; i--) &#123; v2.push_back(i); &#125; printVector(v2); //互换容器 cout &lt;&lt; \"互换后\" &lt;&lt; endl; v1.swap(v2); printVector(v1); printVector(v2);&#125;void test02()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); &#125; cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl; v.resize(3); cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl; //收缩内存 vector&lt;int&gt;(v).swap(v); //匿名对象 cout &lt;&lt; \"v的容量为：\" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; \"v的大小为：\" &lt;&lt; v.size() &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结：swap可以使两个容器互换，可以达到实用的收缩内存效果 3.2.8 vector预留空间功能描述： 减少vector在动态扩展容量时的扩展次数 函数原型： reserve(int len);//容器预留len个元素长度，预留位置不初始化，元素不可访问。 ​ 示例： 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; //预留空间 v.reserve(100000); int num = 0; int* p = NULL; for (int i = 0; i &lt; 100000; i++) &#123; v.push_back(i); if (p != &amp;v[0]) &#123; p = &amp;v[0]; num++; &#125; &#125; cout &lt;&lt; \"num:\" &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：如果数据量较大，可以一开始利用reserve预留空间 3.3 deque容器3.3.1 deque容器基本概念功能： 双端数组，可以对头端进行插入删除操作 deque与vector区别： vector对于头部的插入删除效率低，数据量越大，效率越低 deque相对而言，对头部的插入删除速度回比vector快 vector访问元素时的速度会比deque快,这和两者内部实现有关 deque内部工作原理: deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据 中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间 deque容器的迭代器也是支持随机访问的 3.3.2 deque构造函数功能描述： deque容器构造 函数原型： deque&lt;T&gt; deqT; //默认构造形式 deque(beg, end); //构造函数将[beg, end)区间中的元素拷贝给本身。 deque(n, elem); //构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); //拷贝构造函数 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//deque构造void test01() &#123; deque&lt;int&gt; d1; //无参构造函数 for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt; d2(d1.begin(),d1.end()); printDeque(d2); deque&lt;int&gt;d3(10,100); printDeque(d3); deque&lt;int&gt;d4 = d3; printDeque(d4);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：deque容器和vector容器的构造方式几乎一致，灵活使用即可 3.3.3 deque赋值操作功能描述： 给deque容器进行赋值 函数原型： deque&amp; operator=(const deque &amp;deq); //重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//赋值操作void test01()&#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); deque&lt;int&gt;d2; d2 = d1; printDeque(d2); deque&lt;int&gt;d3; d3.assign(d1.begin(), d1.end()); printDeque(d3); deque&lt;int&gt;d4; d4.assign(10, 100); printDeque(d4);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：deque赋值操作也与vector相同，需熟练掌握 3.3.4 deque大小操作功能描述： 对deque容器的大小进行操作 函数原型： deque.empty(); //判断容器是否为空 deque.size(); //返回容器中元素的个数 deque.resize(num); //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 ​ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//大小操作void test01()&#123; deque&lt;int&gt; d1; for (int i = 0; i &lt; 10; i++) &#123; d1.push_back(i); &#125; printDeque(d1); //判断容器是否为空 if (d1.empty()) &#123; cout &lt;&lt; \"d1为空!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"d1不为空!\" &lt;&lt; endl; //统计大小 cout &lt;&lt; \"d1的大小为：\" &lt;&lt; d1.size() &lt;&lt; endl; &#125; //重新指定大小 d1.resize(15, 1); printDeque(d1); d1.resize(5); printDeque(d1);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： deque没有容量的概念 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.3.5 deque 插入和删除功能描述： 向deque容器中插入和删除数据 函数原型： 两端插入操作： push_back(elem); //在容器尾部添加一个数据 push_front(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 指定位置操作： insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 clear(); //清空容器的所有数据 erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos); //删除pos位置的数据，返回下一个数据的位置。 ​ ​ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//两端操作void test01()&#123; deque&lt;int&gt; d; //尾插 d.push_back(10); d.push_back(20); //头插 d.push_front(100); d.push_front(200); printDeque(d); //尾删 d.pop_back(); //头删 d.pop_front(); printDeque(d);&#125;//插入void test02()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.insert(d.begin(), 1000); printDeque(d); d.insert(d.begin(), 2,10000); printDeque(d); deque&lt;int&gt;d2; d2.push_back(1); d2.push_back(2); d2.push_back(3); d.insert(d.begin(), d2.begin(), d2.end()); printDeque(d);&#125;//删除void test03()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); d.erase(d.begin()); printDeque(d); d.erase(d.begin(), d.end()); d.clear(); printDeque(d);&#125;int main() &#123; //test01(); //test02(); test03(); system(\"pause\"); return 0;&#125; 总结： 插入和删除提供的位置是迭代器！ 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 3.3.6 deque 数据存取功能描述： 对deque 中的数据的存取操作 函数原型： at(int idx); //返回索引idx所指的数据 operator[]; //返回索引idx所指的数据 front(); //返回容器中第一个数据元素 back(); //返回容器中最后一个数据元素 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;deque&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//数据存取void test01()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; for (int i = 0; i &lt; d.size(); i++) &#123; cout &lt;&lt; d.at(i) &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; cout &lt;&lt; \"front:\" &lt;&lt; d.front() &lt;&lt; endl; cout &lt;&lt; \"back:\" &lt;&lt; d.back() &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 除了用迭代器获取deque容器中元素，[ ]和at也可以 front返回容器第一个元素 back返回容器最后一个元素 3.3.7 deque 排序功能描述： 利用算法实现对deque容器进行排序 算法： sort(iterator beg, iterator end) //对beg和end区间内元素进行排序 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;deque&gt;#include &lt;algorithm&gt;void printDeque(const deque&lt;int&gt;&amp; d) &#123; for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; deque&lt;int&gt; d; d.push_back(10); d.push_back(20); d.push_front(100); d.push_front(200); printDeque(d); sort(d.begin(), d.end()); printDeque(d);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：sort算法非常实用，使用时包含头文件 algorithm即可 3.4 案例-评委打分3.4.1 案例描述有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。 3.4.2 实现步骤 创建五名选手，放到vector中 遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中 sort算法对deque容器中分数排序，去除最高和最低分 deque容器遍历一遍，累加总分 获取平均分 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//选手类class Person&#123;public: Person(string name, int score) &#123; this-&gt;m_Name = name; this-&gt;m_Score = score; &#125; string m_Name; //姓名 int m_Score; //平均分&#125;;void createPerson(vector&lt;Person&gt;&amp;v)&#123; string nameSeed = \"ABCDE\"; for (int i = 0; i &lt; 5; i++) &#123; string name = \"选手\"; name += nameSeed[i]; int score = 0; Person p(name, score); //将创建的person对象 放入到容器中 v.push_back(p); &#125;&#125;//打分void setScore(vector&lt;Person&gt;&amp;v)&#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //将评委的分数 放入到deque容器中 deque&lt;int&gt;d; for (int i = 0; i &lt; 10; i++) &#123; int score = rand() % 41 + 60; // 60 ~ 100 d.push_back(score); &#125; //cout &lt;&lt; \"选手： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 打分： \" &lt;&lt; endl; //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) //&#123; // cout &lt;&lt; *dit &lt;&lt; \" \"; //&#125; //cout &lt;&lt; endl; //排序 sort(d.begin(), d.end()); //去除最高和最低分 d.pop_back(); d.pop_front(); //取平均分 int sum = 0; for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++) &#123; sum += *dit; //累加每个评委的分数 &#125; int avg = sum / d.size(); //将平均分 赋值给选手身上 it-&gt;m_Score = avg; &#125;&#125;void showScore(vector&lt;Person&gt;&amp;v)&#123; for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 平均分： \" &lt;&lt; it-&gt;m_Score &lt;&lt; endl; &#125;&#125;int main() &#123; //随机数种子 srand((unsigned int)time(NULL)); //1、创建5名选手 vector&lt;Person&gt;v; //存放选手容器 createPerson(v); //测试 //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) //&#123; // cout &lt;&lt; \"姓名： \" &lt;&lt; (*it).m_Name &lt;&lt; \" 分数： \" &lt;&lt; (*it).m_Score &lt;&lt; endl; //&#125; //2、给5名选手打分 setScore(v); //3、显示最后得分 showScore(v); system(\"pause\"); return 0;&#125; 总结： 选取不同的容器操作数据，可以提升代码的效率 3.5 stack容器3.5.1 stack 基本概念概念：stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口 栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为 栈中进入数据称为 — 入栈 push 栈中弹出数据称为 — 出栈 pop 生活中的栈： 3.5.2 stack 常用接口功能描述：栈容器常用的对外接口 构造函数： stack&lt;T&gt; stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack &amp;stk); //拷贝构造函数 赋值操作： stack&amp; operator=(const stack &amp;stk); //重载等号操作符 数据存取： push(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top(); //返回栈顶元素 大小操作： empty(); //判断堆栈是否为空 size(); //返回栈的大小 示例： 12345678910111213141516171819202122232425262728293031#include &lt;stack&gt;//栈容器常用接口void test01()&#123; //创建栈容器 栈容器必须符合先进后出 stack&lt;int&gt; s; //向栈中添加元素，叫做 压栈 入栈 s.push(10); s.push(20); s.push(30); while (!s.empty()) &#123; //输出栈顶元素 cout &lt;&lt; \"栈顶元素为： \" &lt;&lt; s.top() &lt;&lt; endl; //弹出栈顶元素 s.pop(); &#125; cout &lt;&lt; \"栈的大小为：\" &lt;&lt; s.size() &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 入栈 — push 出栈 — pop 返回栈顶 — top 判断栈是否为空 — empty 返回栈大小 — size 3.6 queue 容器3.6.1 queue 基本概念概念：Queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口 队列容器允许从一端新增元素，从另一端移除元素 队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为 队列中进数据称为 — 入队 push 队列中出数据称为 — 出队 pop 生活中的队列： 3.6.2 queue 常用接口功能描述：栈容器常用的对外接口 构造函数： queue&lt;T&gt; que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue &amp;que); //拷贝构造函数 赋值操作： queue&amp; operator=(const queue &amp;que); //重载等号操作符 数据存取： push(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front(); //返回第一个元素 大小操作： empty(); //判断堆栈是否为空 size(); //返回栈的大小 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;queue&gt;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;void test01() &#123; //创建队列 queue&lt;Person&gt; q; //准备数据 Person p1(\"唐僧\", 30); Person p2(\"孙悟空\", 1000); Person p3(\"猪八戒\", 900); Person p4(\"沙僧\", 800); //向队列中添加元素 入队操作 q.push(p1); q.push(p2); q.push(p3); q.push(p4); //队列不提供迭代器，更不支持随机访问 while (!q.empty()) &#123; //输出队头元素 cout &lt;&lt; \"队头元素-- 姓名： \" &lt;&lt; q.front().m_Name &lt;&lt; \" 年龄： \"&lt;&lt; q.front().m_Age &lt;&lt; endl; cout &lt;&lt; \"队尾元素-- 姓名： \" &lt;&lt; q.back().m_Name &lt;&lt; \" 年龄： \" &lt;&lt; q.back().m_Age &lt;&lt; endl; cout &lt;&lt; endl; //弹出队头元素 q.pop(); &#125; cout &lt;&lt; \"队列大小为：\" &lt;&lt; q.size() &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 入队 — push 出队 — pop 返回队头元素 — front 返回队尾元素 — back 判断队是否为空 — empty 返回队列大小 — size 3.7 list容器3.7.1 list基本概念功能：将数据进行链式存储 链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的 链表的组成：链表由一系列结点组成 结点的组成：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域 STL中的链表是一个双向循环链表 由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器 list的优点： 采用动态存储分配，不会造成内存浪费和溢出 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素 list的缺点： 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大 List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。 总结：STL中List和vector是两个最常被使用的容器，各有优缺点 3.7.2 list构造函数功能描述： 创建list容器 函数原型： list&lt;T&gt; lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list &amp;lst); //拷贝构造函数。 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); list&lt;int&gt;L2(L1.begin(),L1.end()); printList(L2); list&lt;int&gt;L3(L2); printList(L3); list&lt;int&gt;L4(10, 1000); printList(L4);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：list构造方式同其他几个STL常用容器，熟练掌握即可 3.7.3 list 赋值和交换功能描述： 给list容器进行赋值，以及交换list容器 函数原型： assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 list&amp; operator=(const list &amp;lst); //重载等号操作符 swap(lst); //将lst与本身的元素互换。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//赋值和交换void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); printList(L1); //赋值 list&lt;int&gt;L2; L2 = L1; printList(L2); list&lt;int&gt;L3; L3.assign(L2.begin(), L2.end()); printList(L3); list&lt;int&gt;L4; L4.assign(10, 100); printList(L4);&#125;//交换void test02()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); list&lt;int&gt;L2; L2.assign(10, 100); cout &lt;&lt; \"交换前： \" &lt;&lt; endl; printList(L1); printList(L2); cout &lt;&lt; endl; L1.swap(L2); cout &lt;&lt; \"交换后： \" &lt;&lt; endl; printList(L1); printList(L2);&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：list赋值和交换操作能够灵活运用即可 3.7.4 list 大小操作功能描述： 对list容器的大小进行操作 函数原型： size(); //返回容器中元素的个数 empty(); //判断容器是否为空 resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ​ //如果容器变短，则末尾超出容器长度的元素被删除。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//大小操作void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); if (L1.empty()) &#123; cout &lt;&lt; \"L1为空\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"L1不为空\" &lt;&lt; endl; cout &lt;&lt; \"L1的大小为： \" &lt;&lt; L1.size() &lt;&lt; endl; &#125; //重新指定大小 L1.resize(10); printList(L1); L1.resize(2); printList(L1);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 判断是否为空 — empty 返回元素个数 — size 重新指定个数 — resize 3.7.5 list 插入和删除功能描述： 对list容器进行数据的插入和删除 函数原型： push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;list&gt;void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; list&lt;int&gt; L; //尾插 L.push_back(10); L.push_back(20); L.push_back(30); //头插 L.push_front(100); L.push_front(200); L.push_front(300); printList(L); //尾删 L.pop_back(); printList(L); //头删 L.pop_front(); printList(L); //插入 list&lt;int&gt;::iterator it = L.begin(); L.insert(++it, 1000); printList(L); //删除 it = L.begin(); L.erase(++it); printList(L); //移除 L.push_back(10000); L.push_back(10000); L.push_back(10000); printList(L); L.remove(10000); printList(L); //清空 L.clear(); printList(L);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 尾插 — push_back 尾删 — pop_back 头插 — push_front 头删 — pop_front 插入 — insert 删除 — erase 移除 — remove 清空 — clear 3.7.6 list 数据存取功能描述： 对list容器中数据进行存取 函数原型： front(); //返回第一个元素。 back(); //返回最后一个元素。 示例： 123456789101112131415161718192021222324252627282930#include &lt;list&gt;//数据存取void test01()&#123; list&lt;int&gt;L1; L1.push_back(10); L1.push_back(20); L1.push_back(30); L1.push_back(40); //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据 //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误 不支持[]方式访问数据 cout &lt;&lt; \"第一个元素为： \" &lt;&lt; L1.front() &lt;&lt; endl; cout &lt;&lt; \"最后一个元素为： \" &lt;&lt; L1.back() &lt;&lt; endl; //list容器的迭代器是双向迭代器，不支持随机访问 list&lt;int&gt;::iterator it = L1.begin(); //it = it + 1;//错误，不可以跳跃访问，即使是+1&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： list容器中不可以通过[]或者at方式访问数据 返回第一个元素 — front 返回最后一个元素 — back 3.7.7 list 反转和排序功能描述： 将容器中的元素反转，以及将容器中的数据进行排序 函数原型： reverse(); //反转链表 sort(); //链表排序 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243void printList(const list&lt;int&gt;&amp; L) &#123; for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;bool myCompare(int val1 , int val2)&#123; return val1 &gt; val2;&#125;//反转和排序void test01()&#123; list&lt;int&gt; L; L.push_back(90); L.push_back(30); L.push_back(20); L.push_back(70); printList(L); //反转容器的元素 L.reverse(); printList(L); //排序 L.sort(); //默认的排序规则 从小到大 printList(L); L.sort(myCompare); //指定规则，从大到小 printList(L);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 反转 — reverse 排序 — sort （成员函数） 3.7.8 排序案例案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高 排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;list&gt;#include &lt;string&gt;class Person &#123;public: Person(string name, int age , int height) &#123; m_Name = name; m_Age = age; m_Height = height; &#125;public: string m_Name; //姓名 int m_Age; //年龄 int m_Height; //身高&#125;;bool ComparePerson(Person&amp; p1, Person&amp; p2) &#123; if (p1.m_Age == p2.m_Age) &#123; return p1.m_Height &gt; p2.m_Height; &#125; else &#123; return p1.m_Age &lt; p2.m_Age; &#125;&#125;void test01() &#123; list&lt;Person&gt; L; Person p1(\"刘备\", 35 , 175); Person p2(\"曹操\", 45 , 180); Person p3(\"孙权\", 40 , 170); Person p4(\"赵云\", 25 , 190); Person p5(\"张飞\", 35 , 160); Person p6(\"关羽\", 35 , 200); L.push_back(p1); L.push_back(p2); L.push_back(p3); L.push_back(p4); L.push_back(p5); L.push_back(p6); for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄： \" &lt;&lt; it-&gt;m_Age &lt;&lt; \" 身高： \" &lt;&lt; it-&gt;m_Height &lt;&lt; endl; &#125; cout &lt;&lt; \"---------------------------------\" &lt;&lt; endl; L.sort(ComparePerson); //排序 for (list&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄： \" &lt;&lt; it-&gt;m_Age &lt;&lt; \" 身高： \" &lt;&lt; it-&gt;m_Height &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序 高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂 3.8 set/ multiset 容器3.8.1 set基本概念简介： 所有元素都会在插入时自动被排序 本质： set/multiset属于关联式容器，底层结构是用二叉树实现。 set和multiset区别： set不允许容器中有重复的元素 multiset允许容器中有重复的元素 3.8.2 set构造和赋值功能描述：创建set容器以及赋值 构造： set&lt;T&gt; st; //默认构造函数： set(const set &amp;st); //拷贝构造函数 赋值： set&amp; operator=(const set &amp;st); //重载等号操作符 示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//构造和赋值void test01()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //拷贝构造 set&lt;int&gt;s2(s1); printSet(s2); //赋值 set&lt;int&gt;s3; s3 = s2; printSet(s3);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： set容器插入数据时用insert set容器插入数据的数据会自动排序 3.8.3 set大小和交换功能描述： 统计set容器大小以及交换set容器 函数原型： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//大小void test01()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); if (s1.empty()) &#123; cout &lt;&lt; \"s1为空\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"s1不为空\" &lt;&lt; endl; cout &lt;&lt; \"s1的大小为： \" &lt;&lt; s1.size() &lt;&lt; endl; &#125;&#125;//交换void test02()&#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); set&lt;int&gt; s2; s2.insert(100); s2.insert(300); s2.insert(200); s2.insert(400); cout &lt;&lt; \"交换前\" &lt;&lt; endl; printSet(s1); printSet(s2); cout &lt;&lt; endl; cout &lt;&lt; \"交换后\" &lt;&lt; endl; s1.swap(s2); printSet(s1); printSet(s2);&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.8.4 set插入和删除功能描述： set容器进行插入数据和删除数据 函数原型： insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;set&gt;void printSet(set&lt;int&gt; &amp; s)&#123; for (set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;//插入和删除void test01()&#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); printSet(s1); //删除 s1.erase(s1.begin()); printSet(s1); s1.erase(30); printSet(s1); //清空 //s1.erase(s1.begin(), s1.end()); s1.clear(); printSet(s1);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 插入 — insert 删除 — erase 清空 — clear 3.8.5 set查找和统计功能描述： 对set容器进行查找数据以及统计数据 函数原型： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;set&gt;//查找和统计void test01()&#123; set&lt;int&gt; s1; //插入 s1.insert(10); s1.insert(30); s1.insert(20); s1.insert(40); //查找 set&lt;int&gt;::iterator pos = s1.find(30); if (pos != s1.end()) &#123; cout &lt;&lt; \"找到了元素 ： \" &lt;&lt; *pos &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"未找到元素\" &lt;&lt; endl; &#125; //统计 int num = s1.count(30); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 查找 — find （返回的是迭代器） 统计 — count （对于set，结果为0或者1） 3.8.6 set和multiset区别学习目标： 掌握set和multiset的区别 区别： set不可以插入重复数据，而multiset可以 set插入数据的同时会返回插入结果，表示插入是否成功 multiset不会检测数据，因此可以插入重复数据 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;set&gt;//set和multiset区别void test01()&#123; set&lt;int&gt; s; pair&lt;set&lt;int&gt;::iterator, bool&gt; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; \"第一次插入成功!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"第一次插入失败!\" &lt;&lt; endl; &#125; ret = s.insert(10); if (ret.second) &#123; cout &lt;&lt; \"第二次插入成功!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"第二次插入失败!\" &lt;&lt; endl; &#125; //multiset multiset&lt;int&gt; ms; ms.insert(10); ms.insert(10); for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 如果不允许插入重复数据可以利用set 如果需要插入重复数据利用multiset 3.8.7 pair对组创建功能描述： 成对出现的数据，利用对组可以返回两个数据 两种创建方式： pair&lt;type, type&gt; p ( value1, value2 ); pair&lt;type, type&gt; p = make_pair( value1, value2 ); 示例： 1234567891011121314151617181920#include &lt;string&gt;//对组创建void test01()&#123; pair&lt;string, int&gt; p(string(\"Tom\"), 20); cout &lt;&lt; \"姓名： \" &lt;&lt; p.first &lt;&lt; \" 年龄： \" &lt;&lt; p.second &lt;&lt; endl; pair&lt;string, int&gt; p2 = make_pair(\"Jerry\", 10); cout &lt;&lt; \"姓名： \" &lt;&lt; p2.first &lt;&lt; \" 年龄： \" &lt;&lt; p2.second &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 两种方式都可以创建对组，记住一种即可 3.8.8 set容器排序学习目标： set容器默认排序规则为从小到大，掌握如何改变排序规则 主要技术点： 利用仿函数，可以改变排序规则 示例一 set存放内置数据类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;set&gt;class MyCompare &#123;public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01() &#123; set&lt;int&gt; s1; s1.insert(10); s1.insert(40); s1.insert(20); s1.insert(30); s1.insert(50); //默认从小到大 for (set&lt;int&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //指定排序规则 set&lt;int,MyCompare&gt; s2; s2.insert(10); s2.insert(40); s2.insert(20); s2.insert(30); s2.insert(50); for (set&lt;int, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：利用仿函数可以指定set容器的排序规则 示例二 set存放自定义数据类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;set&gt;#include &lt;string&gt;class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class comparePerson&#123;public: bool operator()(const Person&amp; p1, const Person &amp;p2) &#123; //按照年龄进行排序 降序 return p1.m_Age &gt; p2.m_Age; &#125;&#125;;void test01()&#123; set&lt;Person, comparePerson&gt; s; Person p1(\"刘备\", 23); Person p2(\"关羽\", 27); Person p3(\"张飞\", 25); Person p4(\"赵云\", 21); s.insert(p1); s.insert(p2); s.insert(p3); s.insert(p4); for (set&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄： \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 对于自定义数据类型，set必须指定排序规则才可以插入数据 3.9 map/ multimap容器3.9.1 map基本概念简介： map中所有元素都是pair pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质： map/multimap属于关联式容器，底层结构是用二叉树实现。 优点： 可以根据key值快速找到value值 map和multimap区别： map不允许容器中有重复key值元素 multimap允许容器中有重复key值元素 3.9.2 map构造和赋值功能描述： 对map容器进行构造和赋值操作 函数原型： 构造： map&lt;T1, T2&gt; mp; //map默认构造函数: map(const map &amp;mp); //拷贝构造函数 赋值： map&amp; operator=(const map &amp;mp); //重载等号操作符 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; \"key = \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; map&lt;int,int&gt;m; //默认构造 m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); printMap(m); map&lt;int, int&gt;m2(m); //拷贝构造 printMap(m2); map&lt;int, int&gt;m3; m3 = m2; //赋值 printMap(m3);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：map中所有元素都是成对出现，插入数据时候要使用对组 3.9.3 map大小和交换功能描述： 统计map容器大小以及交换map容器 函数原型： size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; \"key = \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); if (m.empty()) &#123; cout &lt;&lt; \"m为空\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"m不为空\" &lt;&lt; endl; cout &lt;&lt; \"m的大小为： \" &lt;&lt; m.size() &lt;&lt; endl; &#125;&#125;//交换void test02()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); map&lt;int, int&gt;m2; m2.insert(pair&lt;int, int&gt;(4, 100)); m2.insert(pair&lt;int, int&gt;(5, 200)); m2.insert(pair&lt;int, int&gt;(6, 300)); cout &lt;&lt; \"交换前\" &lt;&lt; endl; printMap(m); printMap(m2); cout &lt;&lt; \"交换后\" &lt;&lt; endl; m.swap(m2); printMap(m); printMap(m2);&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 统计大小 — size 判断是否为空 — empty 交换容器 — swap 3.9.4 map插入和删除功能描述： map容器进行插入数据和删除数据 函数原型： insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中值为key的元素。 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;map&gt;void printMap(map&lt;int,int&gt;&amp;m)&#123; for (map&lt;int, int&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; \"key = \" &lt;&lt; it-&gt;first &lt;&lt; \" value = \" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; //插入 map&lt;int, int&gt; m; //第一种插入方式 m.insert(pair&lt;int, int&gt;(1, 10)); //第二种插入方式 m.insert(make_pair(2, 20)); //第三种插入方式 m.insert(map&lt;int, int&gt;::value_type(3, 30)); //第四种插入方式 m[4] = 40; printMap(m); //删除 m.erase(m.begin()); printMap(m); m.erase(3); printMap(m); //清空 m.erase(m.begin(),m.end()); m.clear(); printMap(m);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： map插入方式很多，记住其一即可 插入 — insert 删除 — erase 清空 — clear 3.9.5 map查找和统计功能描述： 对map容器进行查找数据以及统计数据 函数原型： find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;map&gt;//查找和统计void test01()&#123; map&lt;int, int&gt;m; m.insert(pair&lt;int, int&gt;(1, 10)); m.insert(pair&lt;int, int&gt;(2, 20)); m.insert(pair&lt;int, int&gt;(3, 30)); //查找 map&lt;int, int&gt;::iterator pos = m.find(3); if (pos != m.end()) &#123; cout &lt;&lt; \"找到了元素 key = \" &lt;&lt; (*pos).first &lt;&lt; \" value = \" &lt;&lt; (*pos).second &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"未找到元素\" &lt;&lt; endl; &#125; //统计 int num = m.count(3); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 查找 — find （返回的是迭代器） 统计 — count （对于map，结果为0或者1） 3.9.6 map容器排序学习目标： map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 主要技术点: 利用仿函数，可以改变排序规则 示例： 123456789101112131415161718192021222324252627282930313233#include &lt;map&gt;class MyCompare &#123;public: bool operator()(int v1, int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01() &#123; //默认从小到大排序 //利用仿函数实现从大到小排序 map&lt;int, int, MyCompare&gt; m; m.insert(make_pair(1, 10)); m.insert(make_pair(2, 20)); m.insert(make_pair(3, 30)); m.insert(make_pair(4, 40)); m.insert(make_pair(5, 50)); for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123; cout &lt;&lt; \"key:\" &lt;&lt; it-&gt;first &lt;&lt; \" value:\" &lt;&lt; it-&gt;second &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 利用仿函数可以指定map容器的排序规则 对于自定义数据类型，map必须要指定排序规则,同set容器 3.10 案例-员工分组3.10.1 案例描述 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发 随机给10名员工分配部门和工资 通过multimap进行信息的插入 key(部门编号) value(员工) 分部门显示员工信息 3.10.2 实现步骤 创建10名员工，放到vector中 遍历vector容器，取出每个员工，进行随机分组 分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中 分部门显示员工信息 案例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;using namespace std;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;ctime&gt;/*- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作- 员工信息有: 姓名 工资组成；部门分为：策划、美术、研发- 随机给10名员工分配部门和工资- 通过multimap进行信息的插入 key(部门编号) value(员工)- 分部门显示员工信息*/#define CEHUA 0#define MEISHU 1#define YANFA 2class Worker&#123;public: string m_Name; int m_Salary;&#125;;void createWorker(vector&lt;Worker&gt;&amp;v)&#123; string nameSeed = \"ABCDEFGHIJ\"; for (int i = 0; i &lt; 10; i++) &#123; Worker worker; worker.m_Name = \"员工\"; worker.m_Name += nameSeed[i]; worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999 //将员工放入到容器中 v.push_back(worker); &#125;&#125;//员工分组void setGroup(vector&lt;Worker&gt;&amp;v,multimap&lt;int,Worker&gt;&amp;m)&#123; for (vector&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; //产生随机部门编号 int deptId = rand() % 3; // 0 1 2 //将员工插入到分组中 //key部门编号，value具体员工 m.insert(make_pair(deptId, *it)); &#125;&#125;void showWorkerByGourp(multimap&lt;int,Worker&gt;&amp;m)&#123; // 0 A B C 1 D E 2 F G ... cout &lt;&lt; \"策划部门：\" &lt;&lt; endl; multimap&lt;int,Worker&gt;::iterator pos = m.find(CEHUA); int count = m.count(CEHUA); // 统计具体人数 int index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" 工资： \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; cout &lt;&lt; \"----------------------\" &lt;&lt; endl; cout &lt;&lt; \"美术部门： \" &lt;&lt; endl; pos = m.find(MEISHU); count = m.count(MEISHU); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" 工资： \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125; cout &lt;&lt; \"----------------------\" &lt;&lt; endl; cout &lt;&lt; \"研发部门： \" &lt;&lt; endl; pos = m.find(YANFA); count = m.count(YANFA); // 统计具体人数 index = 0; for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++) &#123; cout &lt;&lt; \"姓名： \" &lt;&lt; pos-&gt;second.m_Name &lt;&lt; \" 工资： \" &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl; &#125;&#125;int main() &#123; srand((unsigned int)time(NULL)); //1、创建员工 vector&lt;Worker&gt;vWorker; createWorker(vWorker); //2、员工分组 multimap&lt;int, Worker&gt;mWorker; setGroup(vWorker, mWorker); //3、分组显示员工 showWorkerByGourp(mWorker); ////测试 //for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++) //&#123; // cout &lt;&lt; \"姓名： \" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 工资： \" &lt;&lt; it-&gt;m_Salary &lt;&lt; endl; //&#125; system(\"pause\"); return 0;&#125; 总结： 当数据以键值对形式存在，可以考虑用map 或 multimap 4 STL- 函数对象4.1 函数对象4.1.1 函数对象概念概念： 重载函数调用操作符的类，其对象常称为函数对象 函数对象使用重载的()时，行为类似函数调用，也叫仿函数 本质： 函数对象(仿函数)是一个类，不是一个函数 4.1.2 函数对象使用特点： 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值 函数对象超出普通函数的概念，函数对象可以有自己的状态 函数对象可以作为参数传递 示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;string&gt;//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值class MyAdd&#123;public : int operator()(int v1,int v2) &#123; return v1 + v2; &#125;&#125;;void test01()&#123; MyAdd myAdd; cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;&#125;//2、函数对象可以有自己的状态class MyPrint&#123;public: MyPrint() &#123; count = 0; &#125; void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; count++; //统计使用次数 &#125; int count; //内部自己的状态&#125;;void test02()&#123; MyPrint myPrint; myPrint(\"hello world\"); myPrint(\"hello world\"); myPrint(\"hello world\"); cout &lt;&lt; \"myPrint调用次数为： \" &lt;&lt; myPrint.count &lt;&lt; endl;&#125;//3、函数对象可以作为参数传递void doPrint(MyPrint &amp;mp , string test)&#123; mp(test);&#125;void test03()&#123; MyPrint myPrint; doPrint(myPrint, \"Hello C++\");&#125;int main() &#123; //test01(); //test02(); test03(); system(\"pause\"); return 0;&#125; 总结： 仿函数写法非常灵活，可以作为参数进行传递。 4.2 谓词4.2.1 谓词概念概念： 返回bool类型的仿函数称为谓词 如果operator()接受一个参数，那么叫做一元谓词 如果operator()接受两个参数，那么叫做二元谓词 4.2.2 一元谓词示例： 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;algorithm&gt;//1.一元谓词struct GreaterFive&#123; bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; \"没找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：参数只有一个的谓词，称为一元谓词 4.2.3 二元谓词示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;//二元谓词class MyCompare&#123;public: bool operator()(int num1, int num2) &#123; return num1 &gt; num2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(40); v.push_back(20); v.push_back(30); v.push_back(50); //默认从小到大 sort(v.begin(), v.end()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; cout &lt;&lt; \"----------------------------\" &lt;&lt; endl; //使用函数对象改变算法策略，排序从大到小 sort(v.begin(), v.end(), MyCompare()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：参数只有两个的谓词，称为二元谓词 4.3 内建函数对象4.3.1 内建函数对象意义概念： STL内建了一些函数对象 分类: 算术仿函数 关系仿函数 逻辑仿函数 用法： 这些仿函数所产生的对象，用法和一般函数完全相同 使用内建函数对象，需要引入头文件 #include&lt;functional&gt; 4.3.2 算术仿函数功能描述： 实现四则运算 其中negate是一元运算，其他都是二元运算 仿函数原型： template&lt;class T&gt; T plus&lt;T&gt; //加法仿函数 template&lt;class T&gt; T minus&lt;T&gt; //减法仿函数 template&lt;class T&gt; T multiplies&lt;T&gt; //乘法仿函数 template&lt;class T&gt; T divides&lt;T&gt; //除法仿函数 template&lt;class T&gt; T modulus&lt;T&gt; //取模仿函数 template&lt;class T&gt; T negate&lt;T&gt; //取反仿函数 示例： 123456789101112131415161718192021222324#include &lt;functional&gt;//negatevoid test01()&#123; negate&lt;int&gt; n; cout &lt;&lt; n(50) &lt;&lt; endl;&#125;//plusvoid test02()&#123; plus&lt;int&gt; p; cout &lt;&lt; p(10, 20) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 总结：使用内建函数对象时，需要引入头文件 #include &lt;functional&gt; 4.3.3 关系仿函数功能描述： 实现关系对比 仿函数原型： template&lt;class T&gt; bool equal_to&lt;T&gt; //等于 template&lt;class T&gt; bool not_equal_to&lt;T&gt; //不等于 template&lt;class T&gt; bool greater&lt;T&gt; //大于 template&lt;class T&gt; bool greater_equal&lt;T&gt; //大于等于 template&lt;class T&gt; bool less&lt;T&gt; //小于 template&lt;class T&gt; bool less_equal&lt;T&gt; //小于等于 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class MyCompare&#123;public: bool operator()(int v1,int v2) &#123; return v1 &gt; v2; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(40); v.push_back(20); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //自己实现仿函数 //sort(v.begin(), v.end(), MyCompare()); //STL内建仿函数 大于仿函数 sort(v.begin(), v.end(), greater&lt;int&gt;()); for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：关系仿函数中最常用的就是greater&lt;&gt;大于 4.3.4 逻辑仿函数功能描述： 实现逻辑运算 函数原型： template&lt;class T&gt; bool logical_and&lt;T&gt; //逻辑与 template&lt;class T&gt; bool logical_or&lt;T&gt; //逻辑或 template&lt;class T&gt; bool logical_not&lt;T&gt; //逻辑非 示例： 123456789101112131415161718192021222324252627282930313233343536#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;algorithm&gt;void test01()&#123; vector&lt;bool&gt; v; v.push_back(true); v.push_back(false); v.push_back(true); v.push_back(false); for (vector&lt;bool&gt;::iterator it = v.begin();it!= v.end();it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; //逻辑非 将v容器搬运到v2中，并执行逻辑非运算 vector&lt;bool&gt; v2; v2.resize(v.size()); transform(v.begin(), v.end(), v2.begin(), logical_not&lt;bool&gt;()); for (vector&lt;bool&gt;::iterator it = v2.begin(); it != v2.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; \" \"; &#125; cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：逻辑仿函数实际应用较少，了解即可 5 STL- 常用算法概述: 算法主要是由头文件&lt;algorithm&gt; &lt;functional&gt; &lt;numeric&gt;组成。 &lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等 &lt;numeric&gt;体积很小，只包括几个在序列上面进行简单数学运算的模板函数 &lt;functional&gt;定义了一些模板类,用以声明函数对象。 5.1 常用遍历算法学习目标： 掌握常用的遍历算法 算法简介： for_each //遍历容器 transform //搬运容器到另一个容器中 5.1.1 for_each功能描述： 实现遍历容器 函数原型： for_each(iterator beg, iterator end, _func); // 遍历算法 遍历容器元素 // beg 开始迭代器 // end 结束迭代器 // _func 函数或者函数对象 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;vector&gt;//普通函数void print01(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \";&#125;//函数对象class print02 &#123; public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;//for_each算法基本用法void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //遍历算法 for_each(v.begin(), v.end(), print01); cout &lt;&lt; endl; for_each(v.begin(), v.end(), print02()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：for_each在实际开发中是最常用遍历算法，需要熟练掌握 5.1.2 transform功能描述： 搬运容器到另一个容器中 函数原型： transform(iterator beg1, iterator end1, iterator beg2, _func); //beg1 源容器开始迭代器 //end1 源容器结束迭代器 //beg2 目标容器开始迭代器 //_func 函数或者函数对象 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;vector&gt;#include&lt;algorithm&gt;//常用遍历算法 搬运 transformclass TransForm&#123;public: int operator()(int val) &#123; return val; &#125;&#125;;class MyPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; vector&lt;int&gt;vTarget; //目标容器 vTarget.resize(v.size()); // 目标容器需要提前开辟空间 transform(v.begin(), v.end(), vTarget.begin(), TransForm()); for_each(vTarget.begin(), vTarget.end(), MyPrint());&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 搬运的目标容器必须要提前开辟空间，否则无法正常搬运 5.2 常用查找算法学习目标： 掌握常用的查找算法 算法简介： find //查找元素 find_if //按条件查找元素 adjacent_find //查找相邻重复元素 binary_search //二分查找法 count //统计元素个数 count_if //按条件统计元素个数 5.2.1 find功能描述： 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型： find(iterator beg, iterator end, value); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // value 查找的元素 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; //查找容器中是否有 5 这个元素 vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125;class Person &#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; //重载== bool operator==(const Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125;public: string m_Name; int m_Age;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到姓名:\" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125; 总结： 利用find可以在容器中找指定的元素，返回值是迭代器 5.2.2 find_if功能描述： 按条件查找元素 函数原型： find_if(iterator beg, iterator end, _Pred); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // _Pred 函数或者谓词（返回bool类型的仿函数） 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;//内置数据类型class GreaterFive&#123;public: bool operator()(int val) &#123; return val &gt; 5; &#125;&#125;;void test01() &#123; vector&lt;int&gt; v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i + 1); &#125; vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive()); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到大于5的数字:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125;//自定义数据类型class Person &#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;public: string m_Name; int m_Age;&#125;;class Greater20&#123;public: bool operator()(Person &amp;p) &#123; return p.m_Age &gt; 20; &#125;&#125;;void test02() &#123; vector&lt;Person&gt; v; //创建数据 Person p1(\"aaa\", 10); Person p2(\"bbb\", 20); Person p3(\"ccc\", 30); Person p4(\"ddd\", 40); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20()); if (it == v.end()) &#123; cout &lt;&lt; \"没有找到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到姓名:\" &lt;&lt; it-&gt;m_Name &lt;&lt; \" 年龄: \" &lt;&lt; it-&gt;m_Age &lt;&lt; endl; &#125;&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略 5.2.3 adjacent_find功能描述： 查找相邻重复元素 函数原型： adjacent_find(iterator beg, iterator end); // 查找相邻重复元素,返回相邻元素的第一个位置的迭代器 // beg 开始迭代器 // end 结束迭代器 ​ 示例： 1234567891011121314151617181920212223#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(5); v.push_back(2); v.push_back(4); v.push_back(4); v.push_back(3); //查找相邻重复元素 vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end()); if (it == v.end()) &#123; cout &lt;&lt; \"找不到!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"找到相邻重复元素为:\" &lt;&lt; *it &lt;&lt; endl; &#125;&#125; 总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法 5.2.4 binary_search功能描述： 查找指定元素是否存在 函数原型： bool binary_search(iterator beg, iterator end, value); // 查找指定的元素，查到 返回true 否则false // 注意: 在无序序列中不可用 // beg 开始迭代器 // end 结束迭代器 // value 查找的元素 示例： 12345678910111213141516171819202122232425262728293031#include &lt;algorithm&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt;v; for (int i = 0; i &lt; 10; i++) &#123; v.push_back(i); &#125; //二分查找 bool ret = binary_search(v.begin(), v.end(),2); if (ret) &#123; cout &lt;&lt; \"找到了\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"未找到\" &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列 5.2.5 count功能描述： 统计元素个数 函数原型： count(iterator beg, iterator end, value); // 统计元素出现次数 // beg 开始迭代器 // end 结束迭代器 // value 统计的元素 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;algorithm&gt;#include &lt;vector&gt;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count(v.begin(), v.end(), 4); cout &lt;&lt; \"4的个数为： \" &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; bool operator==(const Person &amp; p) &#123; if (this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; string m_Name; int m_Age;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(\"刘备\", 35); Person p2(\"关羽\", 35); Person p3(\"张飞\", 35); Person p4(\"赵云\", 30); Person p5(\"曹操\", 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); Person p(\"诸葛亮\",35); int num = count(v.begin(), v.end(), p); cout &lt;&lt; \"num = \" &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结： 统计自定义数据类型时候，需要配合重载 operator== 5.2.6 count_if功能描述： 按条件统计元素个数 函数原型： count_if(iterator beg, iterator end, _Pred); // 按条件统计元素出现次数 // beg 开始迭代器 // end 结束迭代器 // _Pred 谓词 ​ 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;algorithm&gt;#include &lt;vector&gt;class Greater4&#123;public: bool operator()(int val) &#123; return val &gt;= 4; &#125;&#125;;//内置数据类型void test01()&#123; vector&lt;int&gt; v; v.push_back(1); v.push_back(2); v.push_back(4); v.push_back(5); v.push_back(3); v.push_back(4); v.push_back(4); int num = count_if(v.begin(), v.end(), Greater4()); cout &lt;&lt; \"大于4的个数为： \" &lt;&lt; num &lt;&lt; endl;&#125;//自定义数据类型class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;class AgeLess35&#123;public: bool operator()(const Person &amp;p) &#123; return p.m_Age &lt; 35; &#125;&#125;;void test02()&#123; vector&lt;Person&gt; v; Person p1(\"刘备\", 35); Person p2(\"关羽\", 35); Person p3(\"张飞\", 35); Person p4(\"赵云\", 30); Person p5(\"曹操\", 25); v.push_back(p1); v.push_back(p2); v.push_back(p3); v.push_back(p4); v.push_back(p5); int num = count_if(v.begin(), v.end(), AgeLess35()); cout &lt;&lt; \"小于35岁的个数：\" &lt;&lt; num &lt;&lt; endl;&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：按值统计用count，按条件统计用count_if 5.3 常用排序算法学习目标： 掌握常用的排序算法 算法简介： sort //对容器内元素进行排序 random_shuffle //洗牌 指定范围内的元素随机调整次序 merge // 容器元素合并，并存储到另一容器中 reverse // 反转指定范围的元素 5.3.1 sort功能描述： 对容器内元素进行排序 函数原型： sort(iterator beg, iterator end, _Pred); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // _Pred 谓词 示例： 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;vector&gt;void myPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; \" \";&#125;void test01() &#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); //sort默认从小到大排序 sort(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl; //从大到小排序 sort(v.begin(), v.end(), greater&lt;int&gt;()); for_each(v.begin(), v.end(), myPrint); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：sort属于开发中最常用的算法之一，需熟练掌握 5.3.2 random_shuffle功能描述： 洗牌 指定范围内的元素随机调整次序 函数原型： random_shuffle(iterator beg, iterator end); // 指定范围内的元素随机调整次序 // beg 开始迭代器 // end 结束迭代器 ​ 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;ctime&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; srand((unsigned int)time(NULL)); vector&lt;int&gt; v; for(int i = 0 ; i &lt; 10;i++) &#123; v.push_back(i); &#125; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //打乱顺序 random_shuffle(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：random_shuffle洗牌算法比较实用，使用时记得加随机数种子 5.3.3 merge功能描述： 两个容器元素合并，并存储到另一容器中 函数原型： merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 容器元素合并，并存储到另一容器中 // 注意: 两个容器必须是有序的 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 ​ 示例： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10 ; i++) &#123; v1.push_back(i); v2.push_back(i + 1); &#125; vector&lt;int&gt; vtarget; //目标容器需要提前开辟空间 vtarget.resize(v1.size() + v2.size()); //合并 需要两个有序序列 merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin()); for_each(vtarget.begin(), vtarget.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：merge合并的两个容器必须的有序序列 5.3.4 reverse功能描述： 将容器内元素进行反转 函数原型： reverse(iterator beg, iterator end); // 反转指定范围的元素 // beg 开始迭代器 // end 结束迭代器 ​ 示例： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(30); v.push_back(50); v.push_back(20); v.push_back(40); cout &lt;&lt; \"反转前： \" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"反转后： \" &lt;&lt; endl; reverse(v.begin(), v.end()); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：reverse反转区间内元素，面试题可能涉及到 5.4 常用拷贝和替换算法学习目标： 掌握常用的拷贝和替换算法 算法简介： copy // 容器内指定范围的元素拷贝到另一容器中 replace // 将容器内指定范围的旧元素修改为新元素 replace_if // 容器内指定范围满足条件的元素替换为新元素 swap // 互换两个容器的元素 5.4.1 copy功能描述： 容器内指定范围的元素拷贝到另一容器中 函数原型： copy(iterator beg, iterator end, iterator dest); // 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置 // beg 开始迭代器 // end 结束迭代器 // dest 目标起始迭代器 示例： 12345678910111213141516171819202122232425262728293031323334#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i + 1); &#125; vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：利用copy算法在拷贝时，目标容器记得提前开辟空间 5.4.2 replace功能描述： 将容器内指定范围的旧元素修改为新元素 函数原型： replace(iterator beg, iterator end, oldvalue, newvalue); // 将区间内旧元素 替换成 新元素 // beg 开始迭代器 // end 结束迭代器 // oldvalue 旧元素 // newvalue 新元素 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; \"替换前：\" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中的20 替换成 2000 cout &lt;&lt; \"替换后：\" &lt;&lt; endl; replace(v.begin(), v.end(), 20,2000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：replace会替换区间内满足条件的元素 5.4.3 replace_if功能描述: 将区间内满足条件的元素，替换成指定元素 函数原型： replace_if(iterator beg, iterator end, _pred, newvalue); // 按条件替换元素，满足条件的替换成指定元素 // beg 开始迭代器 // end 结束迭代器 // _pred 谓词 // newvalue 替换的新元素 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;class ReplaceGreater30&#123;public: bool operator()(int val) &#123; return val &gt;= 30; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.push_back(20); v.push_back(30); v.push_back(20); v.push_back(40); v.push_back(50); v.push_back(10); v.push_back(20); cout &lt;&lt; \"替换前：\" &lt;&lt; endl; for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl; //将容器中大于等于的30 替换成 3000 cout &lt;&lt; \"替换后：\" &lt;&lt; endl; replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：replace_if按条件查找，可以利用仿函数灵活筛选满足的条件 5.4.4 swap功能描述： 互换两个容器的元素 函数原型： swap(container c1, container c2); // 互换两个容器的元素 // c1容器1 // c2容器2 ​ 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;algorithm&gt;#include &lt;vector&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+100); &#125; cout &lt;&lt; \"交换前： \" &lt;&lt; endl; for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"交换后： \" &lt;&lt; endl; swap(v1, v2); for_each(v1.begin(), v1.end(), myPrint()); cout &lt;&lt; endl; for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：swap交换容器时，注意交换的容器要同种类型 5.5 常用算术生成算法学习目标： 掌握常用的算术生成算法 注意： 算术生成算法属于小型算法，使用时包含的头文件为 #include &lt;numeric&gt; 算法简介： accumulate // 计算容器元素累计总和 fill // 向容器中添加元素 ​ 5.5.1 accumulate功能描述： 计算区间内 容器元素累计总和 函数原型： accumulate(iterator beg, iterator end, value); // 计算容器元素累计总和 // beg 开始迭代器 // end 结束迭代器 // value 起始值 示例： 12345678910111213141516171819202122#include &lt;numeric&gt;#include &lt;vector&gt;void test01()&#123; vector&lt;int&gt; v; for (int i = 0; i &lt;= 100; i++) &#123; v.push_back(i); &#125; int total = accumulate(v.begin(), v.end(), 0); cout &lt;&lt; \"total = \" &lt;&lt; total &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：accumulate使用时头文件注意是 numeric，这个算法很实用 5.5.2 fill功能描述： 向容器中填充指定的元素 函数原型： fill(iterator beg, iterator end, value); // 向容器中填充元素 // beg 开始迭代器 // end 结束迭代器 // value 填充的值 示例： 123456789101112131415161718192021222324252627282930313233#include &lt;numeric&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v; v.resize(10); //填充 fill(v.begin(), v.end(), 100); for_each(v.begin(), v.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：利用fill可以将容器区间内元素填充为 指定的值 5.6 常用集合算法学习目标： 掌握常用的集合算法 算法简介： set_intersection // 求两个容器的交集 set_union // 求两个容器的并集 set_difference // 求两个容器的差集 ​ 5.6.1 set_intersection功能描述： 求两个容器的交集 函数原型： set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个集合的交集 // 注意:两个集合必须是有序序列 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较小的值给目标容器开辟空间 vTarget.resize(min(v1.size(), v2.size())); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 求交集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器中取小值 set_intersection返回值既是交集中最后一个元素的位置 5.6.2 set_union功能描述： 求两个集合的并集 函数原型： set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个集合的并集 // 注意:两个集合必须是有序序列 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 ​ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个容器的和给目标容器开辟空间 vTarget.resize(v1.size() + v2.size()); //返回目标容器的最后一个元素的迭代器地址 vector&lt;int&gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 求并集的两个集合必须的有序序列 目标容器开辟空间需要两个容器相加 set_union返回值既是并集中最后一个元素的位置 5.6.3 set_difference功能描述： 求两个集合的差集 函数原型： set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); // 求两个集合的差集 // 注意:两个集合必须是有序序列 // beg1 容器1开始迭代器// end1 容器1结束迭代器// beg2 容器2开始迭代器// end2 容器2结束迭代器// dest 目标容器开始迭代器 ​ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;vector&gt;#include &lt;algorithm&gt;class myPrint&#123;public: void operator()(int val) &#123; cout &lt;&lt; val &lt;&lt; \" \"; &#125;&#125;;void test01()&#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i); v2.push_back(i+5); &#125; vector&lt;int&gt; vTarget; //取两个里面较大的值给目标容器开辟空间 vTarget.resize( max(v1.size() , v2.size())); //返回目标容器的最后一个元素的迭代器地址 cout &lt;&lt; \"v1与v2的差集为： \" &lt;&lt; endl; vector&lt;int&gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl; cout &lt;&lt; \"v2与v1的差集为： \" &lt;&lt; endl; itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin()); for_each(vTarget.begin(), itEnd, myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 求差集的两个集合必须的有序序列 目标容器开辟空间需要从两个容器取较大值 12345678910111213141516171819202122id test01()&#123; vector&lt;int&gt; v1; for (int i = 0; i &lt; 10; i++) &#123; v1.push_back(i + 1); &#125; vector&lt;int&gt; v2; v2.resize(v1.size()); copy(v1.begin(), v1.end(), v2.begin()); for_each(v2.begin(), v2.end(), myPrint()); cout &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：利用copy算法在拷贝时，目标容器记得提前开辟空间","categories":[],"tags":[]},{"title":"C++核心编程","slug":"C++核心编程","date":"2020-03-20T14:24:17.885Z","updated":"2020-03-20T14:24:24.999Z","comments":true,"path":"2020/03/20/C++核心编程/","link":"","permalink":"http://yoursite.com/2020/03/20/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/","excerpt":"","text":"C++核心编程本阶段主要针对C++面向对象编程技术做详细讲解，探讨C++中的核心和精髓。 1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收 内存四区意义： 不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程 1.1 程序运行前​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 ​ 代码区： ​ 存放 CPU 执行的机器指令 ​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可 ​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 ​ 全局区： ​ 全局变量和静态变量存放在此. ​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此. ​ 该区域的数据在程序结束后由操作系统释放. 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243//全局变量int g_a = 10;int g_b = 10;//全局常量const int c_g_a = 10;const int c_g_b = 10;int main() &#123; //局部变量 int a = 10; int b = 10; //打印地址 cout &lt;&lt; \"局部变量a地址为： \" &lt;&lt; (int)&amp;a &lt;&lt; endl; cout &lt;&lt; \"局部变量b地址为： \" &lt;&lt; (int)&amp;b &lt;&lt; endl; cout &lt;&lt; \"全局变量g_a地址为： \" &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; \"全局变量g_b地址为： \" &lt;&lt; (int)&amp;g_b &lt;&lt; endl; //静态变量 static int s_a = 10; static int s_b = 10; cout &lt;&lt; \"静态变量s_a地址为： \" &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; \"静态变量s_b地址为： \" &lt;&lt; (int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; \"字符串常量地址为： \" &lt;&lt; (int)&amp;\"hello world\" &lt;&lt; endl; cout &lt;&lt; \"字符串常量地址为： \" &lt;&lt; (int)&amp;\"hello world1\" &lt;&lt; endl; cout &lt;&lt; \"全局常量c_g_a地址为： \" &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; \"全局常量c_g_b地址为： \" &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl; const int c_l_a = 10; const int c_l_b = 10; cout &lt;&lt; \"局部常量c_l_a地址为： \" &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; cout &lt;&lt; \"局部常量c_l_b地址为： \" &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl; system(\"pause\"); return 0;&#125; 打印结果： 总结： C++中在程序运行前分为全局区和代码区 代码区特点是共享和只读 全局区中存放全局变量、静态变量、常量 常量区中存放 const修饰的全局常量 和 字符串常量 1.2 程序运行后​ 栈区： ​ 由编译器自动分配释放, 存放函数的参数值,局部变量等 ​ 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 示例： 1234567891011121314151617int * func()&#123; int a = 10; return &amp;a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(\"pause\"); return 0;&#125; ​ 堆区： ​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收 ​ 在C++中主要利用new在堆区开辟内存 示例： 1234567891011121314151617int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结： 堆区数据由程序员管理开辟和释放 堆区数据利用new关键字进行开辟内存 1.3 new操作符​ C++中利用new操作符在堆区开辟数据 ​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete ​ 语法：new 数据类型 ​ 利用new创建的数据，会返回该数据对应的类型的指针 示例1： 基本语法 12345678910111213141516171819202122int* func()&#123; int* a = new int(10); return a;&#125;int main() &#123; int *p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; //利用delete释放堆区数据 delete p; //cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问 system(\"pause\"); return 0;&#125; 示例2：开辟数组 123456789101112131415161718192021//堆区开辟数组int main() &#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; //释放数组 delete 后加 [] delete[] arr; system(\"pause\"); return 0;&#125; 2 引用2.1 引用的基本使用*作用： *给变量起别名 语法： 数据类型 &amp;别名 = 原名 示例： 1234567891011121314151617int main() &#123; int a = 10; int &amp;b = a; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0;&#125; 2.2 引用注意事项 引用必须初始化 引用在初始化后，不可以改变 示例： 12345678910111213141516int main() &#123; int a = 10; int b = 20; //int &amp;c; //错误，引用必须初始化 int &amp;c = a; //一旦初始化后，就不可以更改 c = b; //这是赋值操作，不是更改引用 cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; system(\"pause\"); return 0;&#125; 2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 示例： 123456789101112131415161718192021222324252627282930313233343536373839//1. 值传递void mySwap01(int a, int b) &#123; int temp = a; a = b; b = temp;&#125;//2. 地址传递void mySwap02(int* a, int* b) &#123; int temp = *a; *a = *b; *b = temp;&#125;//3. 引用传递void mySwap03(int&amp; a, int&amp; b) &#123; int temp = a; a = b; b = temp;&#125;int main() &#123; int a = 10; int b = 20; mySwap01(a, b); cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl; mySwap02(&amp;a, &amp;b); cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl; mySwap03(a, b); cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; \" b:\" &lt;&lt; b &lt;&lt; endl; system(\"pause\"); return 0;&#125; 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单 2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 示例： 123456789101112131415161718192021222324252627282930313233//返回局部变量引用int&amp; test01() &#123; int a = 10; //局部变量 return a;&#125;//返回静态变量引用int&amp; test02() &#123; static int a = 20; return a;&#125;int main() &#123; //不能返回局部变量的引用 int&amp; ref = test01(); cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; endl; //如果函数做左值，那么必须返回引用 int&amp; ref2 = test02(); cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; test02() = 1000; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; cout &lt;&lt; \"ref2 = \" &lt;&lt; ref2 &lt;&lt; endl; system(\"pause\"); return 0;&#125; ​ 2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量. 讲解示例： 1234567891011121314151617//发现是引用，转换为 int* const ref = &amp;a;void func(int&amp; ref)&#123; ref = 100; // ref是引用，转换为*ref = 100&#125;int main()&#123; int a = 10; //自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改 int&amp; ref = a; ref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20; cout &lt;&lt; \"a:\" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"ref:\" &lt;&lt; ref &lt;&lt; endl; func(a); return 0;&#125; 结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了 2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作 在函数形参列表中，可以加const修饰形参，防止形参改变实参 示例： 1234567891011121314151617181920212223//引用使用的场景，通常用来修饰形参void showValue(const int&amp; v) &#123; //v += 10; cout &lt;&lt; v &lt;&lt; endl;&#125;int main() &#123; //int&amp; ref = 10; 引用本身需要一个合法的内存空间，因此这行错误 //加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp; const int&amp; ref = 10; //ref = 100; //加入const后不可以修改变量 cout &lt;&lt; ref &lt;&lt; endl; //函数中利用常量引用防止误操作修改实参 int a = 10; showValue(a); system(\"pause\"); return 0;&#125; 3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。 语法：返回值类型 函数名 （参数= 默认值）{} 示例： 1234567891011121314151617181920int func(int a, int b = 10, int c = 10) &#123; return a + b + c;&#125;//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数int func2(int a = 10, int b = 10);int func2(int a, int b) &#123; return a + b;&#125;int main() &#123; cout &lt;&lt; \"ret = \" &lt;&lt; func(20, 20) &lt;&lt; endl; cout &lt;&lt; \"ret = \" &lt;&lt; func(100) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置 语法： 返回值类型 函数名 (数据类型){} 在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术 示例： 12345678910111213//函数占位参数 ，占位参数也可以有默认参数void func(int a, int) &#123; cout &lt;&lt; \"this is func\" &lt;&lt; endl;&#125;int main() &#123; func(10,10); //占位参数必须填补 system(\"pause\"); return 0;&#125; 3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或者 顺序不同 注意: 函数的返回值不可以作为函数重载的条件 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041//函数重载需要函数都在同一个作用域下void func()&#123; cout &lt;&lt; \"func 的调用！\" &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; \"func (int a) 的调用！\" &lt;&lt; endl;&#125;void func(double a)&#123; cout &lt;&lt; \"func (double a)的调用！\" &lt;&lt; endl;&#125;void func(int a ,double b)&#123; cout &lt;&lt; \"func (int a ,double b) 的调用！\" &lt;&lt; endl;&#125;void func(double a ,int b)&#123; cout &lt;&lt; \"func (double a ,int b)的调用！\" &lt;&lt; endl;&#125;//函数返回值不可以作为函数重载条件//int func(double a, int b)//&#123;// cout &lt;&lt; \"func (double a ,int b)的调用！\" &lt;&lt; endl;//&#125;int main() &#123; func(); func(10); func(3.14); func(10,3.14); func(3.14 , 10); system(\"pause\"); return 0;&#125; 3.3.2 函数重载注意事项 引用作为重载条件 函数重载碰到函数默认参数 示例： 123456789101112131415161718192021222324252627282930313233343536373839//函数重载注意事项//1、引用作为重载条件void func(int &amp;a)&#123; cout &lt;&lt; \"func (int &amp;a) 调用 \" &lt;&lt; endl;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; \"func (const int &amp;a) 调用 \" &lt;&lt; endl;&#125;//2、函数重载碰到函数默认参数void func2(int a, int b = 10)&#123; cout &lt;&lt; \"func2(int a, int b = 10) 调用\" &lt;&lt; endl;&#125;void func2(int a)&#123; cout &lt;&lt; \"func2(int a) 调用\" &lt;&lt; endl;&#125;int main() &#123; int a = 10; func(a); //调用无const func(10);//调用有const //func2(10); //碰到默认参数产生歧义，需要避免 system(\"pause\"); return 0;&#125; 4 类和对象C++面向对象的三大特性为：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如： ​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌… ​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调… ​ 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类 4.1 封装4.1.1 封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装意义一： ​ 在设计类的时候，属性和行为写在一起，表现事物 语法： class 类名{ 访问权限： 属性 / 行为 }; 示例1：设计一个圆类，求圆的周长 示例代码： 123456789101112131415161718192021222324252627282930313233343536373839//圆周率const double PI = 3.14;//1、封装的意义//将属性和行为作为一个整体，用来表现生活中的事物//封装一个圆类，求圆的周长//class代表设计一个类，后面跟着的是类名class Circle&#123;public: //访问权限 公共的权限 //属性 int m_r;//半径 //行为 //获取到圆的周长 double calculateZC() &#123; //2 * pi * r //获取圆的周长 return 2 * PI * m_r; &#125;&#125;;int main() &#123; //通过圆类，创建圆的对象 // c1就是一个具体的圆 Circle c1; c1.m_r = 10; //给圆对象的半径 进行赋值操作 //2 * pi * 10 = = 62.8 cout &lt;&lt; \"圆的周长为： \" &lt;&lt; c1.calculateZC() &lt;&lt; endl; system(\"pause\"); return 0;&#125; 示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号 示例2代码： 1234567891011121314151617181920212223242526272829//学生类class Student &#123;public: void setName(string name) &#123; m_name = name; &#125; void setID(int id) &#123; m_id = id; &#125; void showStudent() &#123; cout &lt;&lt; \"name:\" &lt;&lt; m_name &lt;&lt; \" ID:\" &lt;&lt; m_id &lt;&lt; endl; &#125;public: string m_name; int m_id;&#125;;int main() &#123; Student stu; stu.setName(\"德玛西亚\"); stu.setID(250); stu.showStudent(); system(\"pause\"); return 0;&#125; 封装意义二： 类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 示例： 123456789101112131415161718192021222324252627282930313233343536373839//三种权限//公共权限 public 类内可以访问 类外可以访问//保护权限 protected 类内可以访问 类外不可以访问//私有权限 private 类内可以访问 类外不可以访问class Person&#123; //姓名 公共权限public: string m_Name; //汽车 保护权限protected: string m_Car; //银行卡密码 私有权限private: int m_Password;public: void func() &#123; m_Name = \"张三\"; m_Car = \"拖拉机\"; m_Password = 123456; &#125;&#125;;int main() &#123; Person p; p.m_Name = \"李四\"; //p.m_Car = \"奔驰\"; //保护权限类外访问不到 //p.m_Password = 123; //私有权限类外访问不到 system(\"pause\"); return 0;&#125; 4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同 区别： struct 默认权限为公共 class 默认权限为私有 12345678910111213141516171819202122class C1&#123; int m_A; //默认是私有权限&#125;;struct C2&#123; int m_A; //默认是公共权限&#125;;int main() &#123; C1 c1; c1.m_A = 10; //错误，访问权限是私有 C2 c2; c2.m_A = 10; //正确，访问权限是公共 system(\"pause\"); return 0;&#125; 4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 优点2：对于写权限，我们可以检测数据的有效性 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Person &#123;public: //姓名设置可读可写 void setName(string name) &#123; m_Name = name; &#125; string getName() &#123; return m_Name; &#125; //获取年龄 int getAge() &#123; return m_Age; &#125; //设置年龄 void setAge(int age) &#123; if (age &lt; 0 || age &gt; 150) &#123; cout &lt;&lt; \"你个老妖精!\" &lt;&lt; endl; return; &#125; m_Age = age; &#125; //情人设置为只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: string m_Name; //可读可写 姓名 int m_Age; //只读 年龄 string m_Lover; //只写 情人&#125;;int main() &#123; Person p; //姓名设置 p.setName(\"张三\"); cout &lt;&lt; \"姓名： \" &lt;&lt; p.getName() &lt;&lt; endl; //年龄设置 p.setAge(50); cout &lt;&lt; \"年龄： \" &lt;&lt; p.getAge() &lt;&lt; endl; //情人设置 p.setLover(\"苍井\"); //cout &lt;&lt; \"情人： \" &lt;&lt; p.m_Lover &lt;&lt; endl; //只写属性，不可以读取 system(\"pause\"); return 0;&#125; 练习案例1：设计立方体类 设计立方体类(Cube) 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等。 练习案例2：点和圆的关系 设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。 4.2 对象的初始化和清理 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全 C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。 4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 ​ 一个对象或者变量没有初始状态，对其使用后果是未知 ​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题 c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供 编译器提供的构造函数和析构函数是空实现。 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。 构造函数语法：类名(){} 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次 析构函数语法： ~类名(){} 析构函数，没有返回值也不写void 函数名称与类名相同,在名称前加上符号 ~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次 1234567891011121314151617181920212223242526272829class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; \"Person的构造函数调用\" &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; \"Person的析构函数调用\" &lt;&lt; endl; &#125;&#125;;void test01()&#123; Person p;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.2.2 构造函数的分类及调用两种分类方式： ​ 按参数分为： 有参构造和无参构造 ​ 按类型分为： 普通构造和拷贝构造 三种调用方式： ​ 括号法 ​ 显示法 ​ 隐式转换法 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//1、构造函数分类// 按照参数分类分为 有参和无参构造 无参又称为默认构造函数// 按照类型分类分为 普通构造和拷贝构造class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; &#125;public: int age;&#125;;//2、构造函数的调用//调用无参构造函数void test01() &#123; Person p; //调用无参构造函数&#125;//调用有参的构造函数void test02() &#123; //2.1 括号法，常用 Person p1(10); //注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明 //Person p2(); //2.2 显式法 Person p2 = Person(10); Person p3 = Person(p2); //Person(10)单独写就是匿名对象 当前行结束之后，马上析构 //2.3 隐式转换法 Person p4 = 10; // Person p4 = Person(10); Person p5 = p4; // Person p5 = Person(p4); //注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明 //Person p5(p4);&#125;int main() &#123; test01(); //test02(); system(\"pause\"); return 0;&#125; 4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个已经创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person &#123;public: Person() &#123; cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; mAge = 0; &#125; Person(int age) &#123; cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; mAge = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; mAge = p.mAge; &#125; //析构函数在释放内存之前调用 ~Person() &#123; cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; &#125;public: int mAge;&#125;;//1. 使用一个已经创建完毕的对象来初始化一个新对象void test01() &#123; Person man(100); //p对象已经创建完毕 Person newman(man); //调用拷贝构造函数 Person newman2 = man; //拷贝构造 //Person newman3; //newman3 = man; //不是调用拷贝构造函数，赋值操作&#125;//2. 值传递的方式给函数参数传值//相当于Person p1 = p;void doWork(Person p1) &#123;&#125;void test02() &#123; Person p; //无参构造函数 doWork(p);&#125;//3. 以值方式返回局部对象Person doWork2()&#123; Person p1; cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl; return p1;&#125;void test03()&#123; Person p = doWork2(); cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;&#125;int main() &#123; //test01(); //test02(); test03(); system(\"pause\"); return 0;&#125; 4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数 1．默认构造函数(无参，函数体为空) 2．默认析构函数(无参，函数体为空) 3．默认拷贝构造函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造 如果用户定义拷贝构造函数，c++不会再提供其他构造函数 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; &#125; //有参构造函数 Person(int a) &#123; age = a; cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; age = p.age; cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; &#125; //析构函数 ~Person() &#123; cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; &#125;public: int age;&#125;;void test01()&#123; Person p1(18); //如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作 Person p2(p1); cout &lt;&lt; \"p2的年龄为： \" &lt;&lt; p2.age &lt;&lt; endl;&#125;void test02()&#123; //如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造 Person p1; //此时如果用户自己没有提供默认构造，会出错 Person p2(10); //用户提供的有参 Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供 //如果用户提供拷贝构造，编译器不会提供其他构造函数 Person p4; //此时如果用户自己没有提供默认构造，会出错 Person p5(10); //此时如果用户自己没有提供有参，会出错 Person p6(p5); //用户自己提供拷贝构造&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑 浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Person &#123;public: //无参（默认）构造函数 Person() &#123; cout &lt;&lt; \"无参构造函数!\" &lt;&lt; endl; &#125; //有参构造函数 Person(int age ,int height) &#123; cout &lt;&lt; \"有参构造函数!\" &lt;&lt; endl; m_age = age; m_height = new int(height); &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; cout &lt;&lt; \"拷贝构造函数!\" &lt;&lt; endl; //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题 m_age = p.m_age; m_height = new int(*p.m_height); &#125; //析构函数 ~Person() &#123; cout &lt;&lt; \"析构函数!\" &lt;&lt; endl; if (m_height != NULL) &#123; delete m_height; &#125; &#125;public: int m_age; int* m_height;&#125;;void test01()&#123; Person p1(18, 180); Person p2(p1); cout &lt;&lt; \"p1的年龄： \" &lt;&lt; p1.m_age &lt;&lt; \" 身高： \" &lt;&lt; *p1.m_height &lt;&lt; endl; cout &lt;&lt; \"p2的年龄： \" &lt;&lt; p2.m_age &lt;&lt; \" 身高： \" &lt;&lt; *p2.m_height &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 4.2.6 初始化列表作用： C++提供了初始化列表语法，用来初始化属性 语法：构造函数()：属性1(值1),属性2（值2）... {} 示例： 123456789101112131415161718192021222324252627282930313233class Person &#123;public: ////传统方式初始化 //Person(int a, int b, int c) &#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表方式初始化 Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125; void PrintPerson() &#123; cout &lt;&lt; \"mA:\" &lt;&lt; m_A &lt;&lt; endl; cout &lt;&lt; \"mB:\" &lt;&lt; m_B &lt;&lt; endl; cout &lt;&lt; \"mC:\" &lt;&lt; m_C &lt;&lt; endl; &#125;private: int m_A; int m_B; int m_C;&#125;;int main() &#123; Person p(1, 2, 3); p.PrintPerson(); system(\"pause\"); return 0;&#125; 4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员 例如： 12345class A &#123;&#125;class B&#123; A a；&#125; B类中有对象A作为成员，A为对象成员 那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？ 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Phone&#123;public: Phone(string name) &#123; m_PhoneName = name; cout &lt;&lt; \"Phone构造\" &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; \"Phone析构\" &lt;&lt; endl; &#125; string m_PhoneName;&#125;;class Person&#123;public: //初始化列表可以告诉编译器调用哪一个构造函数 Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; \"Person构造\" &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; \"Person析构\" &lt;&lt; endl; &#125; void playGame() &#123; cout &lt;&lt; m_Name &lt;&lt; \" 使用\" &lt;&lt; m_Phone.m_PhoneName &lt;&lt; \" 牌手机! \" &lt;&lt; endl; &#125; string m_Name; Phone m_Phone;&#125;;void test01()&#123; //当类中成员是其他类对象时，我们称该成员为 对象成员 //构造的顺序是 ：先调用对象成员的构造，再调用本类构造 //析构顺序与构造相反 Person p(\"张三\" , \"苹果X\"); p.playGame();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 示例1 ：静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Person&#123; public: static int m_A; //静态成员变量 //静态成员变量特点： //1 在编译阶段分配内存 //2 类内声明，类外初始化 //3 所有对象共享同一份数据private: static int m_B; //静态成员变量也是有访问权限的&#125;;int Person::m_A = 10;int Person::m_B = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.m_A = 100; cout &lt;&lt; \"p1.m_A = \" &lt;&lt; p1.m_A &lt;&lt; endl; Person p2; p2.m_A = 200; cout &lt;&lt; \"p1.m_A = \" &lt;&lt; p1.m_A &lt;&lt; endl; //共享同一份数据 cout &lt;&lt; \"p2.m_A = \" &lt;&lt; p2.m_A &lt;&lt; endl; //2、通过类名 cout &lt;&lt; \"m_A = \" &lt;&lt; Person::m_A &lt;&lt; endl; //cout &lt;&lt; \"m_B = \" &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 示例2：静态成员函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Person&#123;public: //静态成员函数特点： //1 程序共享一个函数 //2 静态成员函数只能访问静态成员变量 static void func() &#123; cout &lt;&lt; \"func调用\" &lt;&lt; endl; m_A = 100; //m_B = 100; //错误，不可以访问非静态成员变量 &#125; static int m_A; //静态成员变量 int m_B; // private: //静态成员函数也是有访问权限的 static void func2() &#123; cout &lt;&lt; \"func2调用\" &lt;&lt; endl; &#125;&#125;;int Person::m_A = 10;void test01()&#123; //静态成员变量两种访问方式 //1、通过对象 Person p1; p1.func(); //2、通过类名 Person::func(); //Person::func2(); //私有权限访问不到&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 1234567891011121314151617181920212223242526class Person &#123;public: Person() &#123; mA = 0; &#125; //非静态成员变量占对象空间 int mA; //静态成员变量不占对象空间 static int mB; //函数也不占对象空间，所有函数共享一个函数实例 void func() &#123; cout &lt;&lt; \"mA:\" &lt;&lt; this-&gt;mA &lt;&lt; endl; &#125; //静态成员函数也不占对象空间 static void sfunc() &#123; &#125;&#125;;int main() &#123; cout &lt;&lt; sizeof(Person) &lt;&lt; endl; system(\"pause\"); return 0;&#125; 4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢？ c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526272829303132333435363738class Person&#123;public: Person(int age) &#123; //1、当形参和成员变量同名时，可用this指针来区分 this-&gt;age = age; &#125; Person&amp; PersonAddPerson(Person p) &#123; this-&gt;age += p.age; //返回对象本身 return *this; &#125; int age;&#125;;void test01()&#123; Person p1(10); cout &lt;&lt; \"p1.age = \" &lt;&lt; p1.age &lt;&lt; endl; Person p2(10); p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1); cout &lt;&lt; \"p2.age = \" &lt;&lt; p2.age &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 示例： 12345678910111213141516171819202122232425262728293031323334//空指针访问成员函数class Person &#123;public: void ShowClassName() &#123; cout &lt;&lt; \"我是Person类!\" &lt;&lt; endl; &#125; void ShowPerson() &#123; if (this == NULL) &#123; return; &#125; cout &lt;&lt; mAge &lt;&lt; endl; &#125;public: int mAge;&#125;;void test01()&#123; Person * p = NULL; p-&gt;ShowClassName(); //空指针，可以调用成员函数 p-&gt;ShowPerson(); //但是如果成员函数中用到了this指针，就不可以了&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.3.4 const修饰成员函数常函数： 成员函数后加const后我们称为这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person &#123;public: Person() &#123; m_A = 0; m_B = 0; &#125; //this指针的本质是一个指针常量，指针的指向不可修改 //如果想让指针指向的值也不可以修改，需要声明常函数 void ShowPerson() const &#123; //const Type* const pointer; //this = NULL; //不能修改指针的指向 Person* const this; //this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的 //const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量 this-&gt;m_B = 100; &#125; void MyFunc() const &#123; //mA = 10000; &#125;public: int m_A; mutable int m_B; //可修改 可变的&#125;;//const修饰对象 常对象void test01() &#123; const Person person; //常量对象 cout &lt;&lt; person.m_A &lt;&lt; endl; //person.mA = 100; //常对象不能修改成员变量的值,但是可以访问 person.m_B = 100; //但是常对象可以修改mutable修饰成员变量 //常对象访问成员函数 person.MyFunc(); //常对象不能调用const的函数&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private) 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜好基友进去。 在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类 访问另一个类中私有成员 友元的关键字为 friend 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 4.4.1 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142class Building&#123; //告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容 friend void goodGay(Building * building);public: Building() &#123; this-&gt;m_SittingRoom = \"客厅\"; this-&gt;m_BedRoom = \"卧室\"; &#125;public: string m_SittingRoom; //客厅private: string m_BedRoom; //卧室&#125;;void goodGay(Building * building)&#123; cout &lt;&lt; \"好基友正在访问： \" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"好基友正在访问： \" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; Building b; goodGay(&amp;b);&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125; 4.4.2 类做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Building;class goodGay&#123;public: goodGay(); void visit();private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容 friend class goodGay;public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = \"客厅\"; this-&gt;m_BedRoom = \"卧室\";&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125; 4.4.3 成员函数做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Building;class goodGay&#123;public: goodGay(); void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容 void visit2(); private: Building *building;&#125;;class Building&#123; //告诉编译器 goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容 friend void goodGay::visit();public: Building();public: string m_SittingRoom; //客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; this-&gt;m_SittingRoom = \"客厅\"; this-&gt;m_BedRoom = \"卧室\";&#125;goodGay::goodGay()&#123; building = new Building;&#125;void goodGay::visit()&#123; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void goodGay::visit2()&#123; cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; \"好基友正在访问\" &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; goodGay gg; gg.visit();&#125;int main()&#123; test01(); system(\"pause\"); return 0;&#125; 4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Person &#123;public: Person() &#123;&#125;; Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数实现 + 号运算符重载 Person operator+(const Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125;public: int m_A; int m_B;&#125;;//全局函数实现 + 号运算符重载//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;// Person temp(0, 0);// temp.m_A = p1.m_A + p2.m_A;// temp.m_B = p1.m_B + p2.m_B;// return temp;//&#125;//运算符重载 可以发生函数重载 Person operator+(const Person&amp; p2, int val) &#123; Person temp; temp.m_A = p2.m_A + val; temp.m_B = p2.m_B + val; return temp;&#125;void test() &#123; Person p1(10, 10); Person p2(20, 20); //成员函数方式 Person p3 = p2 + p1; //相当于 p2.operaor+(p1) cout &lt;&lt; \"mA:\" &lt;&lt; p3.m_A &lt;&lt; \" mB:\" &lt;&lt; p3.m_B &lt;&lt; endl; Person p4 = p3 + 10; //相当于 operator+(p3,10) cout &lt;&lt; \"mA:\" &lt;&lt; p4.m_A &lt;&lt; \" mB:\" &lt;&lt; p4.m_B &lt;&lt; endl;&#125;int main() &#123; test(); system(\"pause\"); return 0;&#125; 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的 总结2：不要滥用运算符重载 4.5.2 左移运算符重载作用：可以输出自定义数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public: Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125;private: int m_A; int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; out &lt;&lt; \"a:\" &lt;&lt; p.m_A &lt;&lt; \" b:\" &lt;&lt; p.m_B; return out;&#125;void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; \"hello world\" &lt;&lt; endl; //链式编程&#125;int main() &#123; test(); system(\"pause\"); return 0;&#125; 总结：重载左移运算符配合友元可以实现输出自定义数据类型 4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class MyInteger &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //前置++ MyInteger&amp; operator++() &#123; //先++ m_Num++; //再返回 return *this; &#125; //后置++ MyInteger operator++(int) &#123; //先返回 MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++； m_Num++; return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123; out &lt;&lt; myint.m_Num; return out;&#125;//前置++ 先++ 再返回void test01() &#123; MyInteger myInt; cout &lt;&lt; ++myInt &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;//后置++ 先返回 再++void test02() &#123; MyInteger myInt; cout &lt;&lt; myInt++ &lt;&lt; endl; cout &lt;&lt; myInt &lt;&lt; endl;&#125;int main() &#123; test01(); //test02(); system(\"pause\"); return 0;&#125; 总结： 前置递增返回引用，后置递增返回值 4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数 默认构造函数(无参，函数体为空) 默认析构函数(无参，函数体为空) 默认拷贝构造函数，对属性进行值拷贝 赋值运算符 operator=, 对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Person&#123;public: Person(int age) &#123; //将年龄数据开辟到堆区 m_Age = new int(age); &#125; //重载赋值运算符 Person&amp; operator=(Person &amp;p) &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //编译器提供的代码是浅拷贝 //m_Age = p.m_Age; //提供深拷贝 解决浅拷贝的问题 m_Age = new int(*p.m_Age); //返回自身 return *this; &#125; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; //年龄的指针 int *m_Age;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; //赋值操作 cout &lt;&lt; \"p1的年龄为：\" &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; \"p2的年龄为：\" &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; \"p3的年龄为：\" &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); //int a = 10; //int b = 20; //int c = 30; //c = b = a; //cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; endl; //cout &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; endl; //cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl; system(\"pause\"); return 0;&#125; 4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;; bool operator==(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; else &#123; return false; &#125; &#125; bool operator!=(Person &amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; else &#123; return true; &#125; &#125; string m_Name; int m_Age;&#125;;void test01()&#123; //int a = 0; //int b = 0; Person a(\"孙悟空\", 18); Person b(\"孙悟空\", 18); if (a == b) &#123; cout &lt;&lt; \"a和b相等\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"a和b不相等\" &lt;&lt; endl; &#125; if (a != b) &#123; cout &lt;&lt; \"a和b不相等\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"a和b相等\" &lt;&lt; endl; &#125;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.5.6 函数调用运算符重载 函数调用运算符 () 也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyPrint&#123;public: void operator()(string text) &#123; cout &lt;&lt; text &lt;&lt; endl; &#125;&#125;;void test01()&#123; //重载的（）操作符 也称为仿函数 MyPrint myFunc; myFunc(\"hello world\");&#125;class MyAdd&#123;public: int operator()(int v1, int v2) &#123; return v1 + v2; &#125;&#125;;void test02()&#123; MyAdd add; int ret = add(10, 10); cout &lt;&lt; \"ret = \" &lt;&lt; ret &lt;&lt; endl; //匿名对象调用 cout &lt;&lt; \"MyAdd()(100,100) = \" &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main() &#123; test01(); test02(); system(\"pause\"); return 0;&#125; 4.6 继承继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，例如下图中： [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UfsAIlP7-1584713139403)(assets/1544861202252.png)] 我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。 这个时候我们就可以考虑利用继承的技术，减少重复代码 4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同 接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//Java页面class Java &#123;public: void header() &#123; cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; \"JAVA学科视频\" &lt;&lt; endl; &#125;&#125;;//Python页面class Python&#123;public: void header() &#123; cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; \"Python学科视频\" &lt;&lt; endl; &#125;&#125;;//C++页面class CPP &#123;public: void header() &#123; cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; \"C++学科视频\" &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; \"Java下载视频页面如下： \" &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //Python页面 cout &lt;&lt; \"Python下载视频页面如下： \" &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //C++页面 cout &lt;&lt; \"C++下载视频页面如下： \" &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 继承实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//公共页面class BasePage&#123;public: void header() &#123; cout &lt;&lt; \"首页、公开课、登录、注册...（公共头部）\" &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; \"帮助中心、交流合作、站内地图...(公共底部)\" &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; \"Java,Python,C++...(公共分类列表)\" &lt;&lt; endl; &#125;&#125;;//Java页面class Java : public BasePage&#123;public: void content() &#123; cout &lt;&lt; \"JAVA学科视频\" &lt;&lt; endl; &#125;&#125;;//Python页面class Python : public BasePage&#123;public: void content() &#123; cout &lt;&lt; \"Python学科视频\" &lt;&lt; endl; &#125;&#125;;//C++页面class CPP : public BasePage&#123;public: void content() &#123; cout &lt;&lt; \"C++学科视频\" &lt;&lt; endl; &#125;&#125;;void test01()&#123; //Java页面 cout &lt;&lt; \"Java下载视频页面如下： \" &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //Python页面 cout &lt;&lt; \"Python下载视频页面如下： \" &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; \"--------------------\" &lt;&lt; endl; //C++页面 cout &lt;&lt; \"C++下载视频页面如下： \" &lt;&lt; endl; CPP cp; cp.header(); cp.footer(); cp.left(); cp.content();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 继承的好处：可以减少重复的代码 class A : public B; A 类称为子类 或 派生类 B 类称为父类 或 基类 派生类中的成员，包含两大部分： 一类是从基类继承过来的，一类是自己增加的成员。 从基类继承过过来的表现其共性，而新增的成员体现了其个性。 4.6.2 继承方式继承的语法：class 子类 : 继承方式 父类 继承方式一共有三种： 公共继承 保护继承 私有继承 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Base1&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;//公共继承class Son1 :public Base1&#123;public: void func() &#123; m_A; //可访问 public权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125;&#125;;void myClass()&#123; Son1 s1; s1.m_A; //其他类只能访问到公共权限&#125;//保护继承class Base2&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son2:protected Base2&#123;public: void func() &#123; m_A; //可访问 protected权限 m_B; //可访问 protected权限 //m_C; //不可访问 &#125;&#125;;void myClass2()&#123; Son2 s; //s.m_A; //不可访问&#125;//私有继承class Base3&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son3:private Base3&#123;public: void func() &#123; m_A; //可访问 private权限 m_B; //可访问 private权限 //m_C; //不可访问 &#125;&#125;;class GrandSon3 :public Son3&#123;public: void func() &#123; //Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到 //m_A; //m_B; //m_C; &#125;&#125;; 4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？ 示例： 123456789101112131415161718192021222324252627282930class Base&#123;public: int m_A;protected: int m_B;private: int m_C; //私有成员只是被隐藏了，但是还是会继承下去&#125;;//公共继承class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; \"sizeof Son = \" &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 利用工具查看： 打开工具窗口后，定位到当前CPP文件的盘符 然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名 效果如下图： 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到 4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 问题：父类和子类的构造和析构顺序是谁先谁后？ 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142class Base &#123;public: Base() &#123; cout &lt;&lt; \"Base构造函数!\" &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; \"Base析构函数!\" &lt;&lt; endl; &#125;&#125;;class Son : public Base&#123;public: Son() &#123; cout &lt;&lt; \"Son构造函数!\" &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; \"Son析构函数!\" &lt;&lt; endl; &#125;&#125;;void test01()&#123; //继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 Son s;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反 4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Base &#123;public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; \"Base - func()调用\" &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; \"Base - func(int a)调用\" &lt;&lt; endl; &#125;public: int m_A;&#125;;class Son : public Base &#123;public: Son() &#123; m_A = 200; &#125; //当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数 //如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域 void func() &#123; cout &lt;&lt; \"Son - func()调用\" &lt;&lt; endl; &#125;public: int m_A;&#125;;void test01()&#123; Son s; cout &lt;&lt; \"Son下的m_A = \" &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; \"Base下的m_A = \" &lt;&lt; s.Base::m_A &lt;&lt; endl; s.func(); s.Base::func(); s.Base::func(10);&#125;int main() &#123; test01(); system(\"pause\"); return EXIT_SUCCESS;&#125; 总结： 子类对象可以直接访问到子类中同名成员 子类对象加作用域可以访问到父类同名成员 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数 4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？ 静态成员和非静态成员出现同名，处理方式一致 访问子类同名成员 直接访问即可 访问父类同名成员 需要加作用域 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Base &#123;public: static void func() &#123; cout &lt;&lt; \"Base - static void func()\" &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; \"Base - static void func(int a)\" &lt;&lt; endl; &#125; static int m_A;&#125;;int Base::m_A = 100;class Son : public Base &#123;public: static void func() &#123; cout &lt;&lt; \"Son - static void func()\" &lt;&lt; endl; &#125; static int m_A;&#125;;int Son::m_A = 200;//同名成员属性void test01()&#123; //通过对象访问 cout &lt;&lt; \"通过对象访问： \" &lt;&lt; endl; Son s; cout &lt;&lt; \"Son 下 m_A = \" &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; \"Base 下 m_A = \" &lt;&lt; s.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; \"通过类名访问： \" &lt;&lt; endl; cout &lt;&lt; \"Son 下 m_A = \" &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; \"Base 下 m_A = \" &lt;&lt; Son::Base::m_A &lt;&lt; endl;&#125;//同名成员函数void test02()&#123; //通过对象访问 cout &lt;&lt; \"通过对象访问： \" &lt;&lt; endl; Son s; s.func(); s.Base::func(); cout &lt;&lt; \"通过类名访问： \" &lt;&lt; endl; Son::func(); Son::Base::func(); //出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问 Son::Base::func(100);&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名） 4.6.7 多继承语法C++允许一个类继承多个类 语法：class 子类 ：继承方式 父类1 ， 继承方式 父类2... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议用多继承 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Base1 &#123;public: Base1() &#123; m_A = 100; &#125;public: int m_A;&#125;;class Base2 &#123;public: Base2() &#123; m_A = 200; //开始是m_B 不会出问题，但是改为mA就会出现不明确 &#125;public: int m_A;&#125;;//语法：class 子类：继承方式 父类1 ，继承方式 父类2 class Son : public Base2, public Base1 &#123;public: Son() &#123; m_C = 300; m_D = 400; &#125;public: int m_C; int m_D;&#125;;//多继承容易产生成员同名的情况//通过使用类名作用域可以区分调用哪一个基类的成员void test01()&#123; Son s; cout &lt;&lt; \"sizeof Son = \" &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域 4.6.8 菱形继承菱形继承概念： ​ 两个派生类继承同一个基类 ​ 又有某个类同时继承者两个派生类 ​ 这种继承被称为菱形继承，或者钻石继承 典型的菱形继承案例： 菱形继承问题： 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 示例： 1234567891011121314151617181920212223242526272829303132class Animal&#123;public: int m_Age;&#125;;//继承前加virtual关键字后，变为虚继承//此时公共的父类Animal称为虚基类class Sheep : virtual public Animal &#123;&#125;;class Tuo : virtual public Animal &#123;&#125;;class SheepTuo : public Sheep, public Tuo &#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 100; st.Tuo::m_Age = 200; cout &lt;&lt; \"st.Sheep::m_Age = \" &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.Tuo::m_Age = \" &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; cout &lt;&lt; \"st.m_Age = \" &lt;&lt; st.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义 利用虚继承可以解决菱形继承问题 4.7 多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一 多态分为两类 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名 动态多态: 派生类和虚函数实现运行时多态 静态多态和动态多态区别： 静态多态的函数地址早绑定 - 编译阶段确定函数地址 动态多态的函数地址晚绑定 - 运行阶段确定函数地址 下面通过案例进行讲解多态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Animal&#123;public: //Speak函数就是虚函数 //函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。 virtual void speak() &#123; cout &lt;&lt; \"动物在说话\" &lt;&lt; endl; &#125;&#125;;class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; \"小猫在说话\" &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; \"小狗在说话\" &lt;&lt; endl; &#125;&#125;;//我们希望传入什么对象，那么就调用什么对象的函数//如果函数地址在编译阶段就能确定，那么静态联编//如果函数地址在运行阶段才能确定，就是动态联编void DoSpeak(Animal &amp; animal)&#123; animal.speak();&#125;////多态满足条件： //1、有继承关系//2、子类重写父类中的虚函数//多态使用：//父类指针或引用指向子类对象void test01()&#123; Cat cat; DoSpeak(cat); Dog dog; DoSpeak(dog);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 多态满足条件 有继承关系 子类重写父类中的虚函数 多态使用条件 父类指针或引用指向子类对象 重写：函数返回值类型 函数名 参数列表 完全一致称为重写 4.7.2 多态案例一-计算器类案例描述： 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的扩展以及维护 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//普通实现class Calculator &#123;public: int getResult(string oper) &#123; if (oper == \"+\") &#123; return m_Num1 + m_Num2; &#125; else if (oper == \"-\") &#123; return m_Num1 - m_Num2; &#125; else if (oper == \"*\") &#123; return m_Num1 * m_Num2; &#125; //如果要提供新的运算，需要修改源码 &#125;public: int m_Num1; int m_Num2;&#125;;void test01()&#123; //普通实现测试 Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; \" + \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"+\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" - \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"-\") &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; \" * \" &lt;&lt; c.m_Num2 &lt;&lt; \" = \" &lt;&lt; c.getResult(\"*\") &lt;&lt; endl;&#125;//多态实现//抽象计算器类//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护class AbstractCalculator&#123;public : virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//加法计算器class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//减法计算器class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 - m_Num2; &#125;&#125;;//乘法计算器class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 * m_Num2; &#125;&#125;;void test02()&#123; //创建加法计算器 AbstractCalculator *abc = new AddCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" + \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //用完了记得销毁 //创建减法计算器 abc = new SubCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" - \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc; //创建乘法计算器 abc = new MulCalculator; abc-&gt;m_Num1 = 10; abc-&gt;m_Num2 = 10; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; \" * \" &lt;&lt; abc-&gt;m_Num2 &lt;&lt; \" = \" &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; delete abc;&#125;int main() &#123; //test01(); test02(); system(\"pause\"); return 0;&#125; 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多 4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ; 当类中有了纯虚函数，这个类也称为抽象类 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 示例： 123456789101112131415161718192021222324252627282930313233343536class Base&#123;public: //纯虚函数 //类中只要有一个纯虚函数就称为抽象类 //抽象类无法实例化对象 //子类必须重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;public: virtual void func() &#123; cout &lt;&lt; \"func调用\" &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Base * base = NULL; //base = new Base; // 错误，抽象类无法实例化对象 base = new Son; base-&gt;func(); delete base;//记得销毁&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.7.4 多态案例二-制作饮品案例描述： 制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//抽象制作饮品class AbstractDrinking &#123;public: //烧水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //规定流程 void MakeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;//制作咖啡class Coffee : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123; cout &lt;&lt; \"煮农夫山泉!\" &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; \"冲泡咖啡!\" &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; \"将咖啡倒入杯中!\" &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; \"加入牛奶!\" &lt;&lt; endl; &#125;&#125;;//制作茶水class Tea : public AbstractDrinking &#123;public: //烧水 virtual void Boil() &#123; cout &lt;&lt; \"煮自来水!\" &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; \"冲泡茶叶!\" &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; \"将茶水倒入杯中!\" &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; \"加入枸杞!\" &lt;&lt; endl; &#125;&#125;;//业务函数void DoWork(AbstractDrinking* drink) &#123; drink-&gt;MakeDrink(); delete drink;&#125;void test01() &#123; DoWork(new Coffee); cout &lt;&lt; \"--------------\" &lt;&lt; endl; DoWork(new Tea);&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别： 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名(){} 纯虚析构语法： virtual ~类名() = 0; 类名::~类名(){} 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Animal &#123;public: Animal() &#123; cout &lt;&lt; \"Animal 构造函数调用！\" &lt;&lt; endl; &#125; virtual void Speak() = 0; //析构函数加上virtual关键字，变成虚析构函数 //virtual ~Animal() //&#123; // cout &lt;&lt; \"Animal虚析构函数调用！\" &lt;&lt; endl; //&#125; virtual ~Animal() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; \"Animal 纯虚析构函数调用！\" &lt;&lt; endl;&#125;//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。class Cat : public Animal &#123;public: Cat(string name) &#123; cout &lt;&lt; \"Cat构造函数调用！\" &lt;&lt; endl; m_Name = new string(name); &#125; virtual void Speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; \"小猫在说话!\" &lt;&lt; endl; &#125; ~Cat() &#123; cout &lt;&lt; \"Cat析构函数调用!\" &lt;&lt; endl; if (this-&gt;m_Name != NULL) &#123; delete m_Name; m_Name = NULL; &#125; &#125;public: string *m_Name;&#125;;void test01()&#123; Animal *animal = new Cat(\"Tom\"); animal-&gt;Speak(); //通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏 //怎么解决？给基类增加一个虚析构函数 //虚析构函数就是用来解决通过父类指针释放子类对象 delete animal;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： ​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象 ​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构 ​ 3. 拥有纯虚析构函数的类也属于抽象类 4.7.6 多态案例三-电脑组装案例描述： 电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include&lt;iostream&gt;using namespace std;//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: //抽象的显示函数 virtual void display() = 0;&#125;;//抽象内存条类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//电脑类class Computer&#123;public: Computer(CPU * cpu, VideoCard * vc, Memory * mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放3个电脑零件 ~Computer() &#123; //释放CPU零件 if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; //释放显卡零件 if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; //释放内存条零件 if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU * m_cpu; //CPU的零件指针 VideoCard * m_vc; //显卡零件指针 Memory * m_mem; //内存条零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; \"Intel的CPU开始计算了！\" &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; \"Intel的显卡开始显示了！\" &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; \"Intel的内存条开始存储了！\" &lt;&lt; endl; &#125;&#125;;//Lenovo厂商class LenovoCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; \"Lenovo的CPU开始计算了！\" &lt;&lt; endl; &#125;&#125;;class LenovoVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; \"Lenovo的显卡开始显示了！\" &lt;&lt; endl; &#125;&#125;;class LenovoMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; \"Lenovo的内存条开始存储了！\" &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU * intelCpu = new IntelCPU; VideoCard * intelCard = new IntelVideoCard; Memory * intelMem = new IntelMemory; cout &lt;&lt; \"第一台电脑开始工作：\" &lt;&lt; endl; //创建第一台电脑 Computer * computer1 = new Computer(intelCpu, intelCard, intelMem); computer1-&gt;work(); delete computer1; cout &lt;&lt; \"-----------------------\" &lt;&lt; endl; cout &lt;&lt; \"第二台电脑开始工作：\" &lt;&lt; endl; //第二台电脑组装 Computer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);; computer2-&gt;work(); delete computer2; cout &lt;&lt; \"-----------------------\" &lt;&lt; endl; cout &lt;&lt; \"第三台电脑开始工作：\" &lt;&lt; endl; //第三台电脑组装 Computer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);; computer3-&gt;work(); delete computer3;&#125; 5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 &lt;fstream&gt; 文件类型分为两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类: ofstream：写操作 ifstream： 读操作 fstream ： 读写操作 5.1文本文件5.1.1写文件 写文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ofstream ofs; 打开文件 ofs.open(“文件路径”,打开方式); 写数据 ofs &lt;&lt; “写入的数据”; 关闭文件 ofs.close(); ​ 文件打开方式： 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意： 文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios:: out 示例： 12345678910111213141516171819202122#include &lt;fstream&gt;void test01()&#123; ofstream ofs; ofs.open(\"test.txt\", ios::out); ofs &lt;&lt; \"姓名：张三\" &lt;&lt; endl; ofs &lt;&lt; \"性别：男\" &lt;&lt; endl; ofs &lt;&lt; \"年龄：18\" &lt;&lt; endl; ofs.close();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 文件操作必须包含头文件 fstream 读文件可以利用 ofstream ，或者fstream类 打开文件时候需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多 读文件步骤如下： 包含头文件 #include &lt;fstream&gt; 创建流对象 ifstream ifs; 打开文件并判断文件是否打开成功 ifs.open(“文件路径”,打开方式); 读数据 四种方式读取 关闭文件 ifs.close(); 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;fstream&gt;#include &lt;string&gt;void test01()&#123; ifstream ifs; ifs.open(\"test.txt\", ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; return; &#125; //第一种方式 //char buf[1024] = &#123; 0 &#125;; //while (ifs &gt;&gt; buf) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第二种 //char buf[1024] = &#123; 0 &#125;; //while (ifs.getline(buf,sizeof(buf))) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; //第三种 //string buf; //while (getline(ifs, buf)) //&#123; // cout &lt;&lt; buf &lt;&lt; endl; //&#125; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; ifs.close();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 读文件可以利用 ifstream ，或者fstream类 利用is_open函数可以判断文件是否打开成功 close 关闭文件 5.2 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为 ios::binary 5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型 ：ostream&amp; write(const char * buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;//二进制文件 写文件void test01()&#123; //1、包含头文件 //2、创建输出流对象 ofstream ofs(\"person.txt\", ios::out | ios::binary); //3、打开文件 //ofs.open(\"person.txt\", ios::out | ios::binary); Person p = &#123;\"张三\" , 18&#125;; //4、写文件 ofs.write((const char *)&amp;p, sizeof(p)); //5、关闭文件 ofs.close();&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 总结： 文件输出流对象 可以通过write函数，以二进制方式写数据 5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char *buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 示例： 1234567891011121314151617181920212223242526272829303132#include &lt;fstream&gt;#include &lt;string&gt;class Person&#123;public: char m_Name[64]; int m_Age;&#125;;void test01()&#123; ifstream ifs(\"person.txt\", ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; &#125; Person p; ifs.read((char *)&amp;p, sizeof(p)); cout &lt;&lt; \"姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄： \" &lt;&lt; p.m_Age &lt;&lt; endl;&#125;int main() &#123; test01(); system(\"pause\"); return 0;&#125; 文件输入流对象 可以通过read函数，以二进制方式读数据","categories":[],"tags":[]},{"title":"Chrome好用的插件","slug":"Chrome好用的插件","date":"2020-03-20T06:57:27.136Z","updated":"2020-03-20T06:57:34.552Z","comments":true,"path":"2020/03/20/Chrome好用的插件/","link":"","permalink":"http://yoursite.com/2020/03/20/Chrome%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/","excerpt":"","text":"插件推荐1.tampermonkey(油猴) 最好用的插件，一件更比六件强。它能安装好多别人写好的脚本，达到很多不同的功能，如去广告、免费下载、免登录等，而且占用内存还不会增加。 2.谷歌上网助手科学上网最简单的方式，价格也还能接受。 3.FasterChrome 网页加速插件，效果明显，占用内存小。 4.The Great Suspender 上网查资料难免会打开很多标签页，哪个都有可能回顾，关了很难再找，不关又占用大量内存。此插件应运而生，将你长时间没看的标签页挂起，不在占用内存（相当于关掉了网页，但是保留标签页）。 5.go to tab 浏览你打开的所有标签页，当打开标签页过多，每个标签页内容便看不清，此插件可完整查看标签页名称。与插件4配合使用，效果惊人。 6.Infinity 轻量级新标签页美化插件，可以自动换壁纸，用的人超级多。 7.one tab 一键将所有打开的标签页收集于此插件，释放内存，保留名称，可再次打开。 8.vimium vim党福利，可以用键盘控制网页，释放鼠标。缺点是需要记住一些快捷键，且不是所有网页都支持该插件。有点鸡肋。 9.一键管理扩展 最小的插件管理插件，当安装插件过多时，会拖慢浏览器速度，这时便需要插件管理工具，有选择的使用插件。 10.Chrome清理大师很好用的清理工具。 插件安装方法 进入扩展程序界面 1.在地址栏输入chrome://extensions/，回车。2.点击浏览器右上角的自定义及控制》更多工具》扩展程序 安装插件 1.打开开发者模式2.下载好的插件都是 .crx 格式，可将其直接拖到扩展程序界面，完成安装。3.或者将crx文件重命名为rar文件或zip文件，并解压。在扩展程序界面点击加载已解压的扩展程序，找到刚才解压的文件夹，点击，即可完成安装。","categories":[],"tags":[]},{"title":"hexo + github 搭建个人博客","slug":"hexo + github 搭建个人博客","date":"2020-03-20T06:45:51.442Z","updated":"2020-03-20T06:45:58.780Z","comments":true,"path":"2020/03/20/hexo + github 搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/03/20/hexo%20+%20github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"参考1参考2 1.hexo安装由于hexo是基于node.js制作的一款博客管理工具，所以要按照hexo就需要事先安装node，nodejs下载安装，安装完成后打开==git bash==，执行下面命令: 12$ node -v$ npm -v 查看node和npm是否安装成功。 然后国内建议执行： 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm -v 安装cnpm，并查看版本。 然后全局安装hexo-cli，并查看版本： 12$ cnpm install -g hexo-cli$ hexo -v 2.hexo初始化安装hexo之后需要对hexo进行初始化，首先需要新建文件夹，进入到新建文件夹之后再进行初始化， 123$ mkdir blog$ cd blog$ hexo init 然后安装一些依赖包， 1$ npm install 3.部署到GitHub在GitHub上创建一个名为yourname.github.io的库。这里的==yourname==一定是你的GitHub用户名。 然后再blog目录下安装一个插件： 1$ cnpm install --save hexo-deployer-git 配置_config.yml文件，找到文件最下边的Deployment，添加三行：部署文件到GitHub 1$ hexo d 4.hexo使用前面提到过，hexo其实类似于git，通过一些命令来实现静态网页生成、部署等工作，我们在维护博客过程中主要使用的有如下几个命令， 12345$ hexo n blogname # 新建文章，例如，hexo n ComputerScience$ hexo clean # 清除缓存文件$ hexo g # 生成静态文件$ hexo s # 启动本地服务器，预览网页$ hexo d # 部署文件到指定的仓库 记住上述命令就可以进行日常的个人博客维护工作。 5.更换主题克隆主题yilia或next到themes中： 12$ git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia$ git clone https://github.com/theme-next/hexo-theme-next themes/next 修改blog根目录下的配置文件_config.yml：将theme: landscape改为==theme: next==。 然后执行： 1234$ hexo clean $ hexo g $ hexo s$ hexo d #推到GitHub上 完成撒花。","categories":[],"tags":[]},{"title":"论文阅读一（武汉加油、中国加油、不好的事必将过去）","slug":"论文阅读一（武汉加油、中国加油、不好的事必将过去）","date":"2020-03-05T04:56:24.107Z","updated":"2020-03-05T04:56:31.159Z","comments":true,"path":"2020/03/05/论文阅读一（武汉加油、中国加油、不好的事必将过去）/","link":"","permalink":"http://yoursite.com/2020/03/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E4%B8%80%EF%BC%88%E6%AD%A6%E6%B1%89%E5%8A%A0%E6%B2%B9%E3%80%81%E4%B8%AD%E5%9B%BD%E5%8A%A0%E6%B2%B9%E3%80%81%E4%B8%8D%E5%A5%BD%E7%9A%84%E4%BA%8B%E5%BF%85%E5%B0%86%E8%BF%87%E5%8E%BB%EF%BC%89/","excerpt":"","text":"一、MID-Fusion: Octree-based Object-Level Multi-Instance Dynamic SLAM主要贡献1）第一个使用体积表示法的RGB-D多实例动态SLAM系统；2）一种更鲁棒的跟踪方法，利用测量不确定性加权并重新设置参数以用于对象跟踪；3）一个集成了几何信息、光度信息和语义信息的分割方法；4）将语义分布和前景对象概率融合到基于八叉树的物体模型中。 A.系统概述图2显示了我们提出的系统的流程。它由四个部分组成： segmentation, tracking, fusion and raycasting。每个输入的RGB-D图像都由Mask R-CNN处理以执行实例分割，然后进行几何边缘分割和计算运动残差以优化蒙版边界（第IV-D节）。对于tracking，我们首先根据不包括人类蒙版区域的所有顶点计算相机位姿（第IV-B节），然后从该位姿进行光线投射，以找出哪些物体在当前帧中是可见的。这也可以帮助将局部对象蒙版与现有对象模型相关联。我们评估每个对象的运动残差以确定其是否处于运动状态，然后追踪运动物体（第IV-C节）并根据静态世界（包括当前的静态对象）改进相机的位姿（第IV-B节）。使用相机和物体的估计位姿，将深度和颜色信息以及预测的语义和前景概率融合到物体模型中（第IV-E节）。 IV-F节介绍了可见物体的检测以及射线投射。 B.RGB-D Camera tracking计算相机位姿分为两步 1.根据除人类外的所有模型的顶点计算相机位姿。 2.根据静态场景计算相机位姿。 通过最小化密集的点到面的ICP残差eg和光度（RGB）残差ep来进行这两个步骤，这些残差由单独的测量不确定度wg和wp加权。在初始化相机位姿之后，我们进行光线投射以在视图中找到可见的物体。 为了找到运动的物体，我们需要按公式7重新计算RGB残差，然后在当前帧上对Etrack（TWCL）进行最优的评估，并设定一个阈值（个人理解：小于阈值的点为inlier）。 如果物体的蒙版中的inlier比率低于0.9，则我们认为该物体正在移动并按照IV-C节中描述优化其位姿。 然后，通过使用相同的目标函数和优化策略仅根据静态物体来优化相机的位姿。 C.Object pose estimation根据公式8和公式9重新最小化公式1，即可求得运动物体的位姿。 D.Combined semantic-geometric-motion segmentation对于每个RGB-D帧，我们使用Mask R-CNN [16]进行实例分割，然后通过几何边缘优化来解决泄漏的Mask边界[14]。 然后，我们通过光线投射将每个地图物体的实例蒙版渲染到当前帧。 通过计算 IoU 与渲染蒙版的交集，我们将从Mask R-CNN和几何优化生成的局部分割蒙版与现有物体模型相关联。 在将分割蒙版与物体模型关联之后，我们将基于物体的运动残差进一步优化分割蒙版。根据公式10重新计算公式1，对于ICP和RGB残差过高的像素将被视为outlier，并在分割蒙版中滤除。 E.Object-level fusion将深度、颜色、语义、前景概率信息集成到物体模型 F.Raycasting光线投射方法是基于图像序列的直接体绘制算法。从图像的每一个像素，沿固定方向（通常是视线方向）发射一条光线，光线穿越整个图像序列，并在这个过程中，对图像序列进行采样获取颜色信息，同时依据光线吸收模型将颜色值进行累加，直至光线穿越整个图像序列，最后得到的颜色值就是渲染图像的颜色。 二、Improving Visual Localization Accuracy in Dynamic Environments Based on Dynamic Region Removal使用神经网络获得先验边界框，人为确定动态权重，权重低于0.5为静态区域。在静态区域中选择特征点，初步估算两帧之间的相对运动。根据得到的变换矩阵，将参考帧映射到当前帧。将当前帧划分网格，计算特征点对的距离，据此给各个网格分配动态权重，进而计算各个网格的动态概率。然后根据贝叶斯定理，更新动态概率。最后去掉动态区域，计算相机位姿。 三、DSOD: DSO in Dynamic EnvironmentsDSO详解 本文将语义分割网络与深度预测网络相结合，以提供先验的深度和语义信息。 我们提出的方法基于DSO。 因此，我们首先在III-A部分中简要描述DSO。 然后，我们提出的算法的整体方法在第III-B节中显示。深度预测和语义分割分别在第III-C节和第III-D节中介绍。 最后，我们在III-E节中介绍了检查运动一致性和滤除动态点的方法 A、BASELINE DSO METHOD最小化光度误差： B、DSOD FRAMEWORK![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207193525902.png#pic_center =3000x400)我们提出的方法的总体框架如图1所示。我们的方法的输入由RGB图像序列组成，这些RGB图像序列被分解为红色，绿色和蓝色通道。 将光度校准应用于三个通道，然后将它们合并。 校正后的RGB图像是深度预测和分割网络的输入。原始的RGB图像也将转换为灰度图像，进行光度校准，然后用作动态点选择的输入。 与DSO相反，在DSOD中引入了深度预测网络以提供初始深度并对点模式进行编码，以匹配投影的初始位置。 目的是加速深度的融合。网络在单目SLAM系统中在一定程度上补偿了尺度漂移。 此外，语义分割网络用于检查移动一致性，以减少动态环境中的错误。 最后，DSOD的输出是估计的位姿。 C、DEPTH PREDICTION NETWORKDSO仅从当前关键帧中选择像素。 因为它使用用不确定深度信息初始化的像素作为候选点，沿大范围沿对极线进行搜索时，可能会生成错误的投影对。 因此，我们将深度预测网络引入到我们的方法中。 我们使用无监督的单目深度估计来预测候选点的初始深度。 该估计通过单图像深度预测网络为候选点初始化过程提供了先验的深度信息。 在沿对极线对候选点模式的代码和搜索点模式的代码进行XOR操作之后，最相似的投影就是我们的目标模式。 第二步是执行高斯–牛顿迭代，以优化投影对并更新候选点的深度。 最后，我们确定经过1次迭代后候选点的深度（相对于参考系）是否收敛。 如果没有，则不应将该候选点用于姿势估计 D、SEMANTIC SEGMENTATION NETWORK在本文中，语义信息被用来标记动态环境中的潜在动态点。 为了提高分割的准确性，我们采用了可以提供像素级分割的分割网络。分割网络在COCO数据集上进行了训练[33]，它可以检测30类物体。其中，人，汽车，自行车，公共汽车和摩托车被定义为潜在的移动物体。 E、MOVEMENT CONSISTENCY CHECK用RANSAC方法和合适的特征点，确定基础矩阵。利用基础矩阵和参考帧的像素坐标计算极线。计算当前帧的像素点到极线的距离，若大于阈值则为动态点。 四、DS-SLAM: A Semantic Visual SLAM towards Dynamic Environments泡泡图灵智库解读一个兄弟的解读 A、主要贡献 基于ORB-SLAM2 提出了动态环境中的完整语义SLAM系统（DS-SLAM），可以减少动态对象对位姿估计的影响。 本文将一个实时语义分割网络放在一个独立的线程中，它将语义分割与移动一致性检查方法结合起来，过滤掉场景的动态部分，如走路的人。因此，在动态场景中，提升了定位模块和建图模块的稳定性和鲁棒性。 DS-SLAM创建了一个单独的线程来构建稠密的语义3D八叉树地图。稠密的语义三维八叉树地图采用优势对数计分法滤除不稳定体素并更新这些体素的语义。B、概述图1 DS-SLAM概述图。 原始RGB图像用于同时进行语义分割和移动一致性检查。 然后删除异常值并估计位姿。 基于位姿，深度图像和语义分割结果，在独立线程中构建语义八叉树地图。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207195846535.png#pic_center =3000x400)C、框架图2 DS-SLAM的框架图。 局部地图线程和回环检测线程与ORB-SLAM2相同。 前者处理新的关键帧并执行局部BA以在相机姿势的周围实现最佳重建，而后者搜索回环并在检测到回环时执行图优化。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200207200004739.png#pic_center =3000x400)D、semantic segmentation 使用的网络结构是SegNet，在caffe上使用VOC训练，共20个类别。 认为标签为行人的特征点最有可能是外点。E、Moving Consistency Check通过光流法匹配特征点若某对匹配的特征点接近边界，或其像素值与以它为中心的3x3区域内的像素值差别太大，就丢弃这对匹配。用RANSAC方法和合适的特征点，确定基础矩阵。利用基础矩阵和参考帧的像素坐标计算极线。计算当前帧的像素点到极线的距离，若大于阈值则为动态点。F、动态点剔除语义分割结果无法判断物体是否是动态的。运动一致性检查得到的点，不是这个物体包含的所有点，缺少精确轮廓因此，将这两个步骤的结果结合起来，如果在一个物体的语义分割边界内，有足够数量的由移动一致性检测得到的移动点，那么这个物体的所有点都被视为动态的。然后剔除动态点进行位姿估计。","categories":[],"tags":[]},{"title":"《机器学习》读书笔记","slug":"《机器学习》读书笔记","date":"2020-03-05T04:56:14.180Z","updated":"2020-03-05T04:56:21.227Z","comments":true,"path":"2020/03/05/《机器学习》读书笔记/","link":"","permalink":"http://yoursite.com/2020/03/05/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、绪论基本术语数据集（data set）、示例instance、样本sample、属性attribute、特征feature、属性值attribute value、属性空间attribute space、样本空间sample space、特征向量feature vector。 从数据中学得模型的过程称为“学习”（learning）或“训练”（training），这个过程通过执行某个学习算法来完成.训练过程中使用的数据称为“训练数据”（training data），其中每个样本称为一个“训练样本”（training sample），训练样本组成的集合称为“训练集”（training set）.学得模型对应了关于数据的某种潜在的规律，因此亦称“假设”（hypothesis）；这种潜在规律自身，则称为“真相”或“真实”（ground-truth），学习过程就是为了找出或逼近真相.有时将模型称为“学习器”（learner），可看作学习算法在给定数据和参数空间上的实例化。拥有了标记信息的示例，则称为“样例”（example）。 若我们欲预测的是离散值，此类学习任务称为“分类”（classification）；若欲预测的是连续值，此类学习任务称为“回归”（regression）.对只涉及两个类别的“二分类”（binary classification）任务，通常称其中一个类为“正类”（positive class），另一个类为“反类”（negative class）；涉及多个类别时，则称为“多分类”（multi-class classification）任务。 学得模型后，使用其进行预测的过程称为“测试”（testing），被预测的样本称为“测试样本”（testing sample）。我们还可以对西瓜做“聚类”（clustering），即将训练集中的西瓜分成若干组，每组称为一个“簇”（cluster）；这些自动形成的簇可能对应一些潜在的概念划分，例如“浅色瓜”“深色瓜”，甚至“本地瓜”“外地瓜”.这样的学习过程有助于我们了解数据内在的规律，能为更深入地分析数据建立基础.需说明的是，在聚类学习中，“浅色瓜”“本地瓜”这样的概念我们事先是不知道的，而且学习过程中使用的训练样本通常不拥有标记信息. 根据训练数据是否拥有标记信息，学习任务可大致划分为两大类：“监督学习”（supervised learning）和“无监督学习”（unsupervised learning），分类和回归是前者的代表，而聚类则是后者的代表. 学得模型适用于新样本的能力，称为“泛化”（generalization）能力 二、模型评估与选择三、线性模型在属性空间中拟合出一条满足所有样本的曲线。 四、决策树决策树（decision tree）是一类常见的机器学习方法.以二分类任务为例，我们希望从给定训练数据集学得一个模型用以对新示例进行分类，这个把样本分类的任务，可看作对“当前样本属于正类吗？”这个问题的“决策”或“判定”过程.顾名思义，决策树是基于树结构来进行决策的，这恰是人类在面临决策问题时一种很自然的处理机制，剪枝（pruning）是决策树学习算法对付“过拟合”的主要手段. 五、神经网络1、神经元模型1943年提出的M-P神经元模型：（此结构只能解决线性可分的问题，无法解决异或等非线性可分问题）![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211200929560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300)理想的激活函数是阶跃函数，但其数学性质不好，实际上多用sigmoid函数。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211201059281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300)把许多个这样的神经元按一定的层次结构连接起来，就得到了神经网络. 2、感知机与多层网络要解决非线性可分问题，需考虑使用多层功能神经元。例如图5.5中这个简单的两层感知机就能解决异或问题.在图5.5（a）中，输出层与输入层之间的一层神经元，被称为隐层或隐含层（hidden layer），隐含层和输出层神经元都是拥有激活函数的功能神经元。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211202700359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300)更一般的，常见的神经网络是形如图5.6所示的层级结构，每层神经元与下一层神经元全互连，神经元之间不存在同层连接，也不存在跨层连接.这样的神经网络结构通常称为“多层前馈神经网络”（multi-layer feedforward neural networks），其中输入层神经元接收外界输入，隐层与输出层神经元对信号进行加工，最终结果由输出层神经元输出；换言之，输入层神经元仅是接受输入，不进行函数处理，隐层与输出层包含功能神经元。因此，图5.6（a）通常被称为“两层网络”.为避免歧义，本书称其为“单隐层网络”.只需包含隐层，即可称为多层网络.神经网络的学习过程，就是根据训练数据来调整神经元之间的“连接权”（connection weight）以及每个功能神经元的阀值；换言之，神经网络“学”到的东西，蕴涵在连接权与阀值中.![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211202720537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300) 3、误差逆传播算法多层网络的学习能力比单层感知机强得多.欲训练多层网络，式（5.1）的简单感知机学习规则显然不够了，需要更强大的学习算法.误差逆传播（error BackPropagation，简称BP）算法就是其中最杰出的代表，它是迄今最成功的神经网络学习算法.现实任务中使用神经网络时，大多是在使用BP算法进行训练.值得指出的是，BP算法不仅可用于多层前馈神经网络，还可用于其他类型的神经网络，例如训练递归神经网络[Pineda，1987].但通常说“BP网络”时，一般是指用BP算法训练的多层前馈神经网络.![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211203707554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300)图5.8给出了BP算法的工作流程.对每个训练样例，BP算法执行以下操作：先将输入示例提供给输入层神经元，然后逐层将信号前传，直到产生输出层的结果；然后计算输出层的误差（第4-5行），再将误差逆向传播至隐层神经元（第6行），最后根据隐层神经元的误差来对连接权和阈值进行调整（第7行）.该迭代过程循环进行，直到达到某些停止条件为止，例如训练误差已达到一个很小的值.![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211203819522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =450x300) 4、深度学习典型的深度学习模型就是很深层的神经网络（深度学习模型通常有八九层甚至更多隐层）.显然，对神经网络模型，提高容量的办法是增加隐层的数目和通过单纯增加隐层神经元的数目，增加隐层的数目显然比增加隐层神经元的数目更有效，然而，多隐层神经网络难以直接用经典算法（例如标准BP算法）进行训练，因为误差在多隐层内逆传播时，往往会“发散”（diverge）而不能收敛到稳定状态. 无监督逐层训练（unsupervised layer-wise training）是多隐层网络训练的有效手段，其基本思想是每次训练一层隐结点，训练时将上一层隐结点的输出作为输入，而本层隐结点的输出作为下一层隐结点的输入，这称为“预训练”（pre-training）；在预训练全部完成后，再对整个网络进行“微调”（fine-tuning）训练. 事实上，“预训练+微调”的做法可视为将大量参数分组，对每组先找到局部看来比较好的设置，然后再基于这些局部较优的结果联合起来进行全局寻优.这样就在利用了模型大量参数所提供的自由度的同时，有效地节省了训练开销. 另一种节省训练开销的策略是“权共享”（weight sharing），即让一组神经元使用相同的连接权.这个策略在卷积神经网络（Convolutional Neural Network，简称 CNN）[LeCun and Bengio，1995；LeCun et al.，1998]中发挥了重要作用. 六、支持向量机![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211220723688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x300)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211220855668.png#pic_center =400x70)如图6.2所示，距离超平面最近的这几个训练样本点使式（6.3）的等号成立，它们被称为“支持向量”（support vector），两个异类支持向量到超平面的距离之和为![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211220937953.png#pic_center =400x70)它被称为“间隔”（margin）. 七、贝叶斯分类八、集成学习集成学习（ensemble learning）通过构建并结合多个学习器来完成学习任务，有时也被称为多分类器系统（multi-classifier system）、基于委员会的学习（committee-based learning）等. 图8.1显示出集成学习的一般结构：先产生一组“个体学习器”（individual learner），再用某种策略将它们结合起来.个体学习器通常由一个现有的学习算法从训练数据产生，例如C4.5决策树算法、BP神经网络算法等，此时集成中只包含同种类型的个体学习器，例如“决策树集成”中全是决策树，“神经网络集成”中全是神经网络，这样的集成是“同质”的（homogeneous）.同质集成中的个体学习器亦称“基学习器”（base learner），相应的学习算法称为“基学习算法”（base learning algorithm）.集成也可包含不同类型的个体学习器，例如同时包含决策树和神经网络，这样的集成是“异质”的（heterogenous）.异质集成中的个体学习器由不同的学习算法生成，这时就不再有基学习算法；相应的，个体学习器一般不称为基学习器，常称为“组件学习器”（component learner）或直接称为个体学习器.![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211221538253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x200)根据个体学习器的生成方式，目前的集成学习方法大致可分为两大类，即个体学习器间存在强依赖关系、必须串行生成的序列化方法，以及个体学习器间不存在强依赖关系、可同时生成的并行化方法；前者的代表是Boosting，后者的代表是Bagging和“随机森林”（Random Forest）. Boosting是一族可将弱学习器提升为强学习器的算法.这族算法的工作机制类似：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T，最终将这个基学习器进行加权结合. Bagging[Breiman，1996a]是并行式集成学习方法最著名的代表.从名字即可看出，它直接基于我们在2.2.3节介绍过的自助采样法（bootstrap sampling）.给定包含m个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现. 随机森林（Random Forest，简称RF）[Breiman，2001a]是Bagging的一个扩展变体.RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择.具体来说，传统决策树在选择划分属性时是在当前结点的属性集合（假定有d个属性）中选择一个最优属性；而在RF中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分.这里的参数k控制了随机性的引入程度：若令k=d，则基决策树的构建与传统决策树相同；若令k=1，则是随机选择一个属性用于划分；一般情况下，推荐值k=log2d. 九、聚类在“无监督学习”（unsupervised learning）中，训练样本的标记信息是未知的，目标是通过对无标记训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础.此类学习任务中研究最多、应用最广的是“聚类”（clustering）. 聚类试图将数据集中的样本划分为若干个通常是不相交的子集，每个子集称为一个“簇”（cluster）.通过这样的划分，每个簇可能对应于一些潜在的概念（类别）；需说明的是，这些概念对聚类算法而言事先是未知的，聚类过程仅能自动形成簇结构，簇所对应的概念语义需由使用者来把握和命名. 十、降维与度量学习十一、特征选择与稀疏学习我们将属性称为“特征”（feature），对当前学习任务有用的属性称为“相关特征”（relevant feature）、没什么用的属性称为“无关特征”（irrelevant feature）.从给定的特征集合中选择出相关特征子集的过程，称为“特征选择”（feature selection）. 特征选择是一个重要的“数据预处理”（data preprocessing）过程，在现实机器学习任务中，获得数据之后通常先进行特征选择，此后再训练学习器.那么，为什么要进行特征选择呢？ 有两个很重要的原因：首先，我们在现实任务中经常会遇到维数灾难问题，这是由于属性过多而造成的，若能从中选择出重要的特征，使得后续学习过程仅需在一部分特征上构建模型，则维数灾难问题会大为减轻.从这个意义上说，特征选择与第10章介绍的降维有相似的动机；事实上，它们是处理高维数据的两大主流技术.第二个原因是，去除不相关特征往往会降低学习任务的难度，这就像侦探破案一样，若将纷繁复杂的因素抽丝剥茧，只留下关键因素，则真相往往更易看清 十二、计算学习理论顾名思义，计算学习理论（computational learning theory）研究的是关于通过“计算”来进行“学习”的理论，即关于机器学习的理论基础，其目的是分析学习任务的困难本质，为学习算法提供理论保证，并根据分析结果指导算法设计. 十三、半监督学习事实上，未标记样本虽未直接包含标记信息，但若它们与有标记样本是从同样的数据源独立同分布采样而来，则它们所包含的关于数据分布的信息对建立模型将大有裨益.图13.1给出了一个直观的例示.若仅基于图中的一个正例和一个反例，则由于待判别样本恰位于两者正中间，大体上只能随机猜测；若能观察到图中的未标记样本，则将很有把握地判别为正例.![在这里插入图片描述](https://img-blog.csdnimg.cn/2020021122380129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x200)让学习器不依赖外界交互、自动地利用未标记样本来提升学习性能，就是半监督学习（semi-supervised learning）.半监督学习的现实需求非常强烈，因为在现实应用中往往能容易地收集到大量未标记样本，而获取“标记”却需耗费人力、物力.例如，在进行计算机辅助医学影像分析时，可以从医院获得大量医学影像，但若希望医学专家把影像中的病灶全都标识出来则是不现实的.“有标记数据少，未标记数据多”半监督学习恰是提供了一条利用“廉价”的未标记样本的途径. 要利用未标记样本，必然要做一些将未标记样本所揭示的数据分布信息与类别标记相联系的假设.最常见的是“聚类假设”（cluster assumption），即假设数据存在簇结构，同一个簇的样本属于同一个类别.图13.1就是基于聚类假设来利用未标记样本，由于待预测样本与正例样本通过未标记样本的“撮合”聚在一起，与相对分离的反例样本相比，待判别样本更可能属于正类.半监督学习中另一种常见的假设是“流形假设”（manifold assumption），即假设数据分布在一个流形结构上，邻近的样本拥有相似的输出值.“邻近”程度常用“相似”程度来刻画，因此，流形假设可看作聚类假设的推广，但流形假设对输出值没有限制，因此比聚类假设的适用范围更广，可用于更多类型的学习任务.事实上，无论聚类假设还是流形假设，其本质都是“相似的样本拥有相似的输出”这个基本假设. 十四、概率图模型机器学习最重要的任务，是根据一些已观察到的证据（例如训练样本）来对感兴趣的未知变量（例如类别标记）进行估计和推测.概率模型（probabilistic model）提供了一种描述框架，将学习任务归结于计算变量的概率分布.在概率模型中，利用已知变量推测未知变量的分布称为“推断”（inference），其核心是如何基于可观测变量推测出未知变量的条件分布. 概率图模型（probabilistic graphical model）是一类用图来表达变量相关关系的概率模型.它以图为表示工具，最常见的是用一个结点表示一个或一组随机变量，结点之间的边表示变量间的概率相关关系，即“变量关系图”.根据边的性质不同，概率图模型可大致分为两类：第一类是使用有向无环图表示变量间的依赖关系，称为有向图模型或贝叶斯网（Bayesian network）；第二类是使用无向图表示变量间的相关关系，称为无向图模型或马尔可夫网（Markov network）. 隐马尔可夫模型（Hidden Markov Model，简称HMM）是结构最简单的动态贝叶斯网（dynamic Bayesian network），这是一种著名的有向图模型，主要用于时序数据建模，在语音识别、自然语言处理等领域有广泛应用.![在这里插入图片描述](https://img-blog.csdnimg.cn/20200211224412234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x200) 十五、规则学习机器学习中的“规则”（rule）通常是指语义明确、能描述数据分布所隐含的客观规律或领域概念、可写成“若……，则……”形式的逻辑规则[Firnkranz et al.，2012].“规则学习”（rule learning）是从训练数据中学习出一组能用于对未见示例进行判别的规则. 与神经网络、支持向量机这样的“黑箱模型”相比，规则学习具有更好的可解释性，能使用户更直观地对判别过程有所了解.另一方面，数理逻辑具有极强的表达能力，绝大多数人类知识都能通过数理逻辑进行简洁的刻画和表达.规则学习能更自然地在学习过程中引入领域知识.此外，逻辑规则的抽象描述能力在处理一些高度复杂的AI任务时具有显著的优势，例如在问答系统中有时可能遇到非常多、甚至无穷种可能的答案，此时若能基于逻辑规则进行抽象表述或者推理，则将带来极大的便利. 十六、强化学习我们考虑一下如何种西瓜.种瓜有许多步骤，从一开始的选种，到定期浇水、施肥、除草、杀虫，经过一段时间才能收获西瓜.通常要等到收获后，我们才知道种出的瓜好不好.若将得到好瓜作为辛勤种瓜劳动的奖赏，则在种瓜过程中当我们执行某个操作（例如，施肥）时，并不能立即获得这个最终奖赏，甚至难以判断当前操作对最终奖赏的影响，仅能得到一个当前反馈（例如，瓜苗看起来更健壮了）.我们需多次种瓜，在种瓜过程中不断摸索，然后才能总结出较好的种瓜策略.这个过程抽象出来，就是“强化学习”（reinforcement learning）. 机器要做的是通过在环境中不断地尝试而学得一个“策略”（policy）π，根据这个策略，在状态x下就能得知要执行的动作a=π（x），例如看到瓜苗状态是缺水时，能返回动作“浇水”. 策略的优劣取决于长期执行这一策略后得到的累积奖赏，例如某个策略使得瓜苗枯死，它的累积奖赏会很小，另一个策略种出了好瓜，它的累积奖赏会很大.在强化学习任务中，学习的目的就是要找到能使长期累积奖赏最大化的策略长期累积奖赏有多种计算方式 读者也许已经感觉到强化学习与监督学习的差别.若将这里的“状态”对应为监督学习中的“示例”、“动作”对应为“标记”，则可看出，强化学习中的“策略”实际上就相当于监督学习中的“分类器”（当动作是离散的）或“回归器”（当动作是连续的），模型的形式并无差别.但不同的是，在强化学习中并没有监督学习中的有标记样本（即“示例-标记”对），换言之，没有人直接告诉机器在什么状态下应该做什么动作，只有等到最终结果揭晓，才能通过“反思”之前的动作是否正确来进行学习.因此，强化学习在某种意义上可看作具有“延迟标记信息”的监督学习问题","categories":[],"tags":[]},{"title":"卷积的理解","slug":"卷积的理解","date":"2020-03-05T04:56:00.232Z","updated":"2020-03-05T04:56:01.238Z","comments":true,"path":"2020/03/05/卷积的理解/","link":"","permalink":"http://yoursite.com/2020/03/05/%E5%8D%B7%E7%A7%AF%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"卷积的定义![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216134122403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300 ) 卷积大白话卷积是一种运算，比加减乘除稍复杂的运算。1.f(x)和g(y)是两个一元函数 // f(x)和g(y)分别是x和y的一个映射，这个映射是任意的。2.以x为横轴，y为纵轴建立直角坐标系3.定义：U(x,y) = f(x) * g(y) //函数U不是x、y的函数，而是x、y映射的函数，即f(x)、g(y)的函数4.求直线 y = -x + n 上的所有点，的U(x,y)，的和，这个和就叫f(x)和g(y)的卷积。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216140942733.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x500) 矩阵卷积向量的內积是向量变标量的一种运算方法矩阵的內积是矩阵变向量的一种运算方法矩阵的卷积是矩阵变标量的一种运算方法 举例图像处理中，图像可以表示为矩阵形式，如我们在原始图像矩阵中，取出像素（u,v）处的3x3矩阵：对图像的处理函数（如平滑，或者边缘提取），也可以用一个矩阵来表示，如：那么矩阵 f 和 g 在（u，v）处的卷积 ( f * g )(u,v) 该如何计算呢？ 即：1.把矩阵 g 旋转180^o^2.把矩阵 f 和矩阵 g 对应位置元素相乘，再相加。3.得到一个标量。","categories":[],"tags":[]},{"title":"理解上采样、下采样、池化","slug":"理解上采样、下采样、池化","date":"2020-03-05T04:55:40.174Z","updated":"2020-03-05T04:55:47.226Z","comments":true,"path":"2020/03/05/理解上采样、下采样、池化/","link":"","permalink":"http://yoursite.com/2020/03/05/%E7%90%86%E8%A7%A3%E4%B8%8A%E9%87%87%E6%A0%B7%E3%80%81%E4%B8%8B%E9%87%87%E6%A0%B7%E3%80%81%E6%B1%A0%E5%8C%96/","excerpt":"","text":"上采样、下采样缩小图像（或称为下采样（subsampled）或降采样（downsampled））主要目的有两个：1、使得图像符合显示区域的大小；2、生成对应图像的缩略图。 放大图像（或称为上采样（upsampling）或图像插值（interpolating））主要目的是：放大原图像,从而可以显示在更高分辨率的显示设备上。对图像的缩放操作并不能带来更多关于该图像的信息, 因此图像的质量将不可避免地受到影响。然而，确实有一些缩放方法能够增加图像的信息，从而使得缩放后的图像质量超过原图质量的。 原理下采样原理：对于一幅图像I尺寸为MN，对其进行s倍下采样，即得到(M/s)(N/s)尺寸的得分辨率图像，当然s应该是M和N的公约数才行，如果考虑的是矩阵形式的图像，就是把原始图像s*s窗口内的图像变成一个像素，这个像素点的值就是窗口内所有像素的均值： 上采样原理：图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。如最近邻插值，双线性插值，均值插值，中值插值等方法。各种插值方法都有各自的优缺点。 无论缩小图像（下采样）还是放大图像（上采样），采样方式有很多种。 池化池化（Pooling）是卷积神经网络中一个重要的概念，它实际上是一种形式的降采样。它会压缩输入的特征图，一方面减少了特征，导致了参数减少，进而简化了卷积网络计算时的复杂度；另一方面保持了特征的某种不变性（旋转、平移、伸缩等）。 池化操作主要有两种，一种是平均池化(Average Pooling)，即对邻域内的特征点求平均；另一种是最大池化(Max Pooling)，即对邻域内的特征点取最大。最大池化（Max pooling）是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。直觉上，这种机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的卷积层之间都会周期性地插入池化层。 池化层通常会分别作用于每个输入的特征并减小其大小。当前最常用形式的池化层是每隔2个元素从图像划分出2*2的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。池化方法特征提取误差主要来自两个部分：一是，邻域大小受限造成了估计值方差增大；二是，卷积层参数误差造成了估计均值的偏移。一般来说，在图像研究领域，对图像进行平均池化操作能减少第一种误差，同时更多地保留图像的背景信息；而另一方面，最大池化能减小第二种误差，更多地保留纹理信息。因此在进行卷积神经网络结构设计时，这两种池化方式往往交替使用。 简而言之，池化就是去除杂余信息，保留关键信息 池化的作用池化操作后的结果相比其输入缩小了。池化层的引入是仿照人的视觉系统对视觉输入对象进行降维和抽象。在卷积神经网络过去的工作中，研究者普遍认为池化层有如下三个功效： 1.特征不变形：池化操作是模型更加关注是否存在某些特征而不是特征具体的位置。2.特征降维：池化相当于在空间范围内做了维度约减，从而使模型可以抽取更加广范围的特征。同时减小了下一层的输入大小，进而减少计算量和参数个数。3.在一定程度上防止过拟合，更方便优化。","categories":[],"tags":[]},{"title":"初识语义分割","slug":"初识语义分割","date":"2020-03-05T04:55:30.926Z","updated":"2020-03-05T04:55:37.559Z","comments":true,"path":"2020/03/05/初识语义分割/","link":"","permalink":"http://yoursite.com/2020/03/05/%E5%88%9D%E8%AF%86%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/","excerpt":"","text":"语义分割基础知识在计算机视觉的语义感知部分主要分为图像分类、目标检测、语义分割、实例分割等。 语义分割是一种视觉场景理解任务，它从像素水平上理解、识别图片内容，然后根据语义信息进行图像分割；它是一种稠密标签，目的是预测输入图片中每一个像素的类别标签。 现有语义分割技术会出现分割图像边缘粗糙的现象，这在应用领域造成了一定的影响，尤其在对分割精确度要求较高的医学领域；而且在语义分割模型训练的过程中主要依赖人工标注的数据集样本，耗费较多的人力物力。因此，如何对分割图像边缘粗糙问题进行处理，提高分割精确度；如何降低语义分割模型训练对人工标注的数据集样本的依赖程度，提升网络的泛化能力，对语义分割技术的广泛应用具有非常重要的现实意义。 图像语义分割综述转载自这儿 什么是语义分割语义分割是在像素级别上的分类，属于同一类的像素都要被归为一类，因此语义分割是从像素级别来理解图像的。比如说如下的照片，属于人的像素都要分成一类，属于摩托车的像素也要分成一类，除此之外还有背景像素也被分为一类。注意语义分割不同于实例分割，举例来说，如果一张照片中有多个人，对于语义分割来说，只要将所由人的像素都归为一类，但是实例分割还要将不同人的像素归为不同的类。也就是说实例分割比语义分割更进一步。 语义分割的思路传统方法在深度学习方法流行之前，TextonForest和基于随机森林分类器等语义分割方法是用得比较多的方法。不过在深度卷积网络流行之后，深度学习方法比传统方法提升了很多，所以这里就不详细讲传统方法了。 深度学习方法深度学习方法在语义分割上得到了巨大成功，深度学习方法解决语义分割问题可以概括为几种思路。下面进行详细介绍。 1.Patch classification最初的深度学习方法应用于图像分割就是Patch classification。Patch classification方法，顾名思义，图像是切成块喂给深度模型的，然后对像素进行分类。使用图像块的主要原因是全连接层需要固定大小的图像。 2.全卷积方法2014年，全卷积网络（FCN）横空出世，FCN将网络全连接层用卷积取代，因此使任意图像大小的输入都变成可能，而且速度比Patch classification方法快很多。 尽管移除了全连接层，但是CNN模型用于语义分割还存在一个问题，就是下采样操作（比如，pooling）。pooling操作可以扩大感受野因而能够很好地整合上下文信息（context中文称为语境或者上下文，通俗的理解就是综合了更多的信息来进行决策），对high-level的任务（比如分类），这是很有效的。但同时，由于pooling下采样操作，使得分辨率降低，因此削弱了位置信息，而语义分割中需要score map和原图对齐，因此需要丰富的位置信息。 3.encoder-decoder架构encoder-decoder是基于FCN的架构。encoder由于pooling逐渐减少空间维度，而decoder逐渐恢复空间维度和细节信息。通常从encoder到decoder还有shortcut connetction（捷径连接，也就是跨层连接）。其中U-net就是这种架构很流行的一种，如下图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216121702929.png#pic_center =500x300)4.空洞卷积dilated/atrous （空洞卷积）架构，这种结构代替了pooling，一方面它可以保持空间分辨率，另外一方面它由于可以扩大感受野因而可以很好地整合上下文信息。如下图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216121135445.png#pic_center =500x300)5.条件随机场除了以上思路，还有一种对分割结果进行后处理的方法，那就是条件随机场(Conditional Random Fields (CRFs))后处理用来改善分割效果。DeepLab系列文章基本都采用这种后处理方法，可以较好地改善分割结果，如下图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216121319384.png#pic_center =500x300) 深度学习语义分割方法现在的深度学习语义分割模型基本上都是基于FCN发展而来的，它是开山鼻祖，一张图概括FCN的延伸方法：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216121544933.png#pic_center =500x300)各方法的详细信息 各方法的简要介绍下面简单总结一些从FCN进行改进的几种架构，关于每种架构的详细解读请看专栏中其他文章。 1.FCN Fully Convolutional Networks for Semantic SegmentationSubmitted on 14 Nov 2014 主要贡献 1.使端对端的卷积语义分割网络变得流行起来。2.通过deconvolutional layers进行上采样。3.通过skip connection改善了上采样的粗糙度。 概要 1.全卷积化(Fully Convolutional)：用于解决逐像素(pixel-wise)的预测问题。通过将基础网络(例如VGG)最后面几个全连接层换成卷积层，可实现任意大小的图像输入，并且输出图像大小与输入相对应；2.反卷积(deconvolution) ：上采样操作，用于恢复图片尺寸，方便后续进行逐像素预测;3.跳跃结构(skip architecture)：用于融合高低层特征信息。通过跨层连接的结构，结合了网络浅层的细(fine-grain)粒度信息信息以及深层的粗糙(coarse)信息，以实现精准的分割任务。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216123101449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x300)FCN是基于深度学习的语义分割的开山之作，尽管现在很多方法都超越了FCN，但它的思想仍然有很重要的意义。 2. Segnet SegNet: A Deep Convolutional Encoder-Decoder Architecture for Image SegmentationSubmitted on 2 Nov 2015 主要贡献 使用Maxpooling indices来增强位置信息。 简要概述 FCN的upconvolution层+shortcut connections产生的分割图比较粗糙，因此SegNet增加了更多的shortcut connections。不过，SegNet并不是直接将encoder的特征进行直接复制，而是对maxpooling中的indices进行复制，这使得SegNet的效率更高。 maxpooling 的indices复制原理如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216220438471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =300x)FCN和SegNet都是encoder-decoder架构。SegNet的benchmark表现太差了，不建议用这个网络。 3. Dilated convolution论文信息 Multi-Scale Context Aggregation by Dilated ConvolutionsSubmitted on 23 Nov 2015 创新点 1.使用空洞卷积用来进行稠密预测（dense prediction）。2.提出上下文模块（context module），使用空洞卷积（Dilated Convolutions）来进行多尺度信息的的整合。 简要解释 pooling操作可以增大感受野，对于图像分类任务来说这有很大好处，但由于pooling操作降低了分辨率，这对语义分割来说很不利。因此作者提出一种叫做dilated convolution的操作来解决这个问题。dilated卷积(在deeplab中称为atrous卷积)。可以很好地提升感受野的同时可以保持空间分辨率。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216220838429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x)网络架构有两种，一种是前端网络，另外一种是前端网络+上下文模块，分别介绍如下： 将VGG网络的最后两个pooling层给拿掉了，之后的卷积层被dilated 卷积取代。并且在pool3和pool4之间空洞卷积的空洞率=2，pool4之后的空洞卷积的空洞率=4。作者将这种架构称为前端（front-end）。 除了前端网络之外，作者还设计了一种叫做上下文模块（context module）的架构，加在前端网络之后。上下文模块中级联了多种不同空洞率的空洞卷积，使得多尺度的上下文信息可以得到整合，从而改善前端网络预测的效果。需要注意的是前端网络和上下文模块是分开训练的，因为作者在实验中发现，如果是联合在一起进行端对端的训练并不能改善性能。 需要特别注意的是，网络输出的分割图并不是和原始图像大小一样的，而是其1/8，需要对输出的分割图进行线性插值才能得到最终的分割结果。这种做法也是很多其他的方法都使用的。 4. DeepLab(v1,v2)论文信息 v1: Semantic Image Segmentation with Deep Convolutional Nets and Fully Connected CRFsSubmitted on 22 Dec 2014v2 : DeepLab: Semantic Image Segmentation with Deep Convolutional Nets, Atrous Convolution, and Fully Connected CRFsSubmitted on 2 Jun 2016 主要贡献 1.使用atrous卷积，也就是后来的空洞卷积，扩大感受野，保持分辨率。2.提出了atrous spatial pyramid pooling (ASPP)，整合多尺度信息。3.使用全连接条件随机场（fully connected CRF)进行后处理，改善分割结果。 简要概述 1.空洞卷积可以在不增加参数的情况下增加感受野。2.通过两种方式来进行多尺度的处理：A.将原始图像的多种尺度喂给网络进行训练。B.通过平行的不同空洞率的空洞卷积层来获得。3.通过全连接条件随机场来进行后处理，以改善分割结果。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216221235418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =700x) 5.RefineNet论文信息 RefineNet: Multi-Path Refinement Networks for High-Resolution Semantic SegmentationSubmitted on 20 Nov 2016 主要贡献 精心设计了encoder-decoder架构中的decoder部分，使得性能提升。整个网络的设计都遵循residual connections，网络表达能力更强，梯度更容易反向传播。 简要概述 作者提出空洞卷积方法应用于语义分割也是有缺点的，包括： 因为使用了大分辨率的feature map，因此计算代价大，并且需要大量的内存。对于这个问题，DeepLab的做法是只预测原始输入的1／8。本文提出使用encoder-decoder架构。encoder部分是RESNET-101。decoder具有RefineNet blocks，它将此前的RefineNet blocks的低分辨率特征和encoder部分高分辨率特征进行concatenate/fuse。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216221557410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =700x)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216221623130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =700x) 6. PSPNet论文信息 Pyramid Scene Parsing NetworkSubmitted on 4 Dec 2016 主要贡献 使用pyramid pooling整合context。使用auxiliary loss。 概要 骨架网络使用Resnet，并在此基础上加上pyramid pooling module。该模块用到了很多kernel大小不一的pooling 。将pooling的结果再上采样，经过concatenate进行融合。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216221725398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =700x)在RESNET的第四阶段（即输入到金字塔池模块）之后，应用auxiliary loss。这种方法在别的地方也被称为intermediate supervision。","categories":[],"tags":[]},{"title":"《视觉SLAM十四讲》笔记","slug":"《视觉SLAM十四讲》笔记","date":"2020-03-05T04:55:16.371Z","updated":"2020-03-05T04:55:22.622Z","comments":true,"path":"2020/03/05/《视觉SLAM十四讲》笔记/","link":"","permalink":"http://yoursite.com/2020/03/05/%E3%80%8A%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1. 视觉SLAM 系统概述SLAM 是Simultaneous Localization and Mapping 的缩写，中文译作“同时定位与地图构建” 。它是指搭载特定传感器的主体，在没有环境先验信息的情况下，于运动过程中建立环境的模型，同时估计自己的运动。如果这里的传感器主要为相机，那就称为“视觉SLAM”。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216222952173.png#pic_center =300x)视觉SLAM流程分为以下几步 传感器信息读取。在视觉SLAM 中主要为相机图像信息的读取和预处理。 视觉里程计。视觉里程计任务是估算相邻图像间相机的运动，以及局部地图的样子。 后端优化。后端接受不同时刻视觉里程计测量的相机位姿，以及回环检测的信息，对它们进行优化，得到全局一致的轨迹和地图。 回环检测。回环检测判断机器人是否曾经到达过先前的位置。如果检测到回环，它会把信息提供给后端进行处理。 建图。它根据估计的轨迹，建立与任务要求对应的地图。2. 前端视觉里程计视觉里程计根据相邻图像的信息，估计出粗略的相机运动，给后端提供较好的初始值。视觉里程计的算法主要分为两个大类：特征点法和直接法。基于特征点法的前端，长久以来（直到现在）被认为是视觉里程计的主流方法。它运行稳定，对光照、动态物体不敏感，是目前比较成熟的解决方案。核心问题：如何根据图像估计相机运动。 2.1. 特征点法特征点：由关键点和描述子两部分组成。关键点是指该特征点在图像里的位置，有些特征点还具有朝向、大小等信息。描述子通常是一个向量，按照某种人为设计的方式，描述了该关键点周围像素的信息。描述子是按照“外观相似的特征应该有相似的描述子”的原则设计的。 特征匹配：视觉SLAM 中极为关键的一步，特征匹配解决了SLAM 中的数据关联问题，即确定当前看到的路标与之前看到的路标之间的对应关系。通过对图像与图像，或者图像与地图之间的描述子进行准确的匹配，我们可以为后续的姿态估计，优化等操作减轻大量负担。匹配方法：暴力匹配等。 当相机为单目时，我们只知道2D 的像素坐标，因而问题是根据两组2D 点估计运动。该问题用对极几何来解决。 当相机为双目、RGB-D 时，或者我们通过某种方法得到了距离信息，那问题就是根据两组3D 点估计运动。该问题通常用ICP 来解决。 如果我们有3D 点和它们在相机的投影位置，也能估计相机的运动。该问题通过PnP求解。 2.1.1. 2D-2D: 对极几何假设我们从两张图像中，得到了一对配对好的特征点，如果我们有若干对这样的匹配点，就可以通过这些二维图像点的对应关系，恢复出在两帧之间摄像机的运动。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216223504198.png#pic_center =300x)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216223545251.png#pic_center =300x)八点法+奇异值分解即可求得旋转矩阵R和位移向量t。 2.1.2. 三角测量在得到运动之后，下一步我们需要用相机的运动估计特征点的空间位置。在单目SLAM 中，仅通过单张图像无法获得像素的深度信息，我们需要通过三角测量（Triangulation）（或三角化）的方法来估计地图点的深度。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216223738272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =300x)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216223807598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =300x) 2.1.3. 3D-2D: PnPPnP（Perspective-n-Point）是求解3D 到2D 点对运动的方法。它描述了当我们知道n 个3D 空间点以及它们的投影位置时，如何估计相机所在的位姿 如果两张图像中，其中一张特征点的3D 位置已知，那么最少只需三个点对（需要至少一个额外点验证结果）就可以估计相机运动 在双目或RGB-D 的视觉里程计中，我们可以直接使用PnP 估计相机运动。而在单目视觉里程计中，必须先进行初始化，然后才能使用PnP PnP 问题有很多种求解方法，例如用三对点估计位姿的P3P，直接线性变换（DLT），非线性优化构建最小二乘问题并迭代求解 2.1.4. 3D-3D: ICP假设一组配对好的3D 点（比如对两个RGB-D 图像进行了匹配）：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224001316.png#pic_center =300x)现在，找一个欧氏变换R; t，使得：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224025260.png#pic_center =300x)这个问题可以用迭代最近点（Iterative Closest Point, ICP）求解ICP 的求解也分为两种方式：利用线性代数的求解（主要是SVD），以及利用非线性优化方式的求解（类似于Bundle Adjustment）。 2.1.5. 特征点法的缺陷特征点法存在的问题： 关键点的提取与描述子的计算非常耗时 使用特征点时，忽略了除特征点以外的所有信息。一张图像有几十万个像素，而特征点只有几百个。只使用特征点丢弃了大部分可能有用的图像信息。 相机有时会运动到特征缺失的地方，往往这些地方没有明显的纹理信息。 克服对策： 只计算关键点，不计算描述子。同时，使用光流法（Optical Flow）来跟踪特征点的运动。这样可以回避计算和匹配描述子带来的时间，而光流本身的计算时间要小于特征点的计算与匹配。 只计算关键点，不计算描述子。同时，使用直接法（Direct Method）来计算特征点在下一时刻图像的位置。这同样可以跳过描述子的计算过程，而且直接法的计算更加简单。 2.2. 光流法光流法仍然使用特征点，只是把匹配描述子替换成了光流跟踪，估计相机运动时仍使用对极几何、PnP 或ICP 算法。 光流是一种描述像素随着时间，在图像之间运动的方法，计算部分像素运动的称为稀疏光流，计算所有像素的称为稠密光流。 LK光流是光流法的一种，它对观测量做了“灰度不变”假设和“某个窗口内的像素具有相同的运动”假设。因而能够从前后两幅图片中追踪到同一个点的位置移动。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224237540.png#pic_center =300x)在实际应用中，LK光流的作用就是跟踪特征点。与对每一帧提取特征点相比，使用LK光流只需要提取一次特征点，后续视频帧只需要跟踪就可以了，节约了许多特征提取时间。 2.3. 直接法在直接法中，根据图像的像素灰度信息同时估计相机的运动和点的投影，不要求提取到的点必须为角点。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224336943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224410575.png#pic_center =400x)直接法的思路是根据当前相机的位姿估计值，来寻找p2 的位置。但若相机位姿不够好，p2 的外观和p1 会有明显差别。于是，为了减小这个差别，我们优化相机的位姿，来寻找与p1 更相似的p2。光度误差（Photometric Error），也就是P 的两个像的亮度误差：![在这里插入图片描述](https://img-blog.csdnimg.cn/2020021622444270.png#pic_center =300x)优化目标为该误差的二范数 能够做这种优化的理由，仍是基于灰度不变假设。在直接法中，假设一个空间点在各个视角下，成像的灰度是不变的。有许多个（比如N 个）空间点Pi，那么，整个相机位姿估计问题变为：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216224522325.png#pic_center =400x)然后使用G-N 或L-M 计算增量，迭代求解。 3. 后端优化前端视觉里程计能给出一个短时间内的轨迹和地图，但由于不可避免的误差累积，这个地图在长时间内是不准确的。所以，在视觉里程计的基础上，我们还希望构建一个尺度、规模更大的优化问题，以考虑长时间内的最优轨迹和地图。 3.1. 线性系统和卡尔曼滤波KF![在这里插入图片描述](https://img-blog.csdnimg.cn/2020021718160174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x) 3.2. 非线性系统和扩展的卡尔曼滤波EKF把卡尔曼滤波器的结果拓展到非线性系统中来，称为扩展卡尔曼滤波器（ExtendedKalman Filter，EKF）。通常的做法是，在某个点附近考虑运动方程以及观测方程的一阶泰勒展开，只保留一阶项，即线性的部分，然后按照线性系统进行推导。 先定义一个卡尔曼增益Kk： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217181656173.png#pic_center =300x)在卡尔曼增益的基础上，后验概率的形式为： 3.3. 光束法平差BA所谓的Bundle Adjustment，是指从视觉重建中提炼出最优的3D 模型和相机参数（内参数和外参数）。从每一个特征点反射出来的几束光线（bundles of light rays），在我们把相机姿态和特征点空间位置做出最优的调整(adjustment) 之后，最后收束到相机光心的这个过程，简称为BA。左侧的p 是全局坐标系下的三维坐标点，右侧的us， vs 是该点在图像平面上的最终像素坐标。系统的观测方程为： z=h(T,p) 其中，T为相机的位姿变换矩阵,其对应的李代数为ξ。则以最小二乘的角度考虑，可得此次观测的误差： e=z-h(T,p) 然后，把其他时刻的观测量也考虑进来，我们可以给误差添加一个下标。设zij 为在位姿ξi 处观察路标pj 产生的数据，那么整体的代价函数（Cost Function）为：对这个最小二乘进行求解，相当于对位姿和路标同时作了调整，也就是所谓的BA。 3.4. 位姿图优化构建一个只有轨迹的图优化，而位姿节点之间的边，可以由两个关键帧之间通过特征匹配之后得到的运动估计来给定初始值。一旦初始估计完成，我们就不再优化那些路标点的位置，而只关心所有的相机位姿之间的联系了。通过这种方式，我们省去了大量的特征点优化的计算，只保留了关键帧的轨迹，从而构建了所谓的位姿图位姿图优化中的节点表示相机位姿，边表示两个节点之间相对运动的估计。边可表示为或按李群的写法：然后构建误差eij：所有的位姿顶点和位姿——位姿边构成了一个图优化，本质上是一个最小二乘问题，优化变量为各个顶点的位姿，边来自于位姿观测约束。记ε 为所有边的集合，那么总体目标函数为：我们依然可以用Gauss-Newton、Levenberg-Marquardt 等方法求解此问题，除了用李代数表示优化位姿以外，别的都是相似的。 4. 回环检测4.1. 概述4.1.1. 回环检测的意义前端提供特征点的提取和轨迹、地图的初值，而后端负责对这所有的数据进行优化。然而，如果像VO 那样仅考虑相邻时间上的关联，那么，之前产生的误差将不可避免地累计到下一个时刻，使得整个SLAM 会出现累积误差。长期估计的结果将不可靠，或者说，我们无法构建全局一致的轨迹和地图。 回环检测模块，能够给出除了相邻帧之外的，一些时隔更加久远的约束。回环检测的关键，就是如何有效地检测出相机经过同一个地方这件事。如果能够成功地检测这件事，就可以为后端的Pose Graph 提供更多的有效数据，使之得到更好的估计，特别是得到一个全局一致（Global Consistent）的估计。 4.1.2. 核心问题：如何计算图像间的相似性 4.1.3. 准确率和召回率准确率：算法提取的所有回环中，确实是真实回环的概率。召回率：在所有真实回环中，被正确检测出来的概率。 为了评价算法的好坏，我们会测试它在各种配置下的P 和R 值，然后做出一条Precision-Recall 曲线。当用召回率为横轴，用准确率为纵轴时，我们会关心整条曲线偏向右上方的程度、100% 准确率下的召回率，或者50% 召回率时候的准确率，作为评价算法的指标。 值得一提的是，在SLAM 中，我们对准确率要求更高，而对召回率则相对宽容一些。由于假阳性的（检测结果是而实际不是的）回环将在后端的Pose Graph 中添加根本错误的边，有些时候会导致优化算法给出完全错误的结果。而相比之下，召回率低一些，则顶多有部分的回环没有被检测到，地图可能受一些累积误差的影响——然而仅需一两次回环就可以完全消除它们了。所以说在选择回环检测算法时，我们更倾向于把参数设置地更严格一些，或者在检测之后再加上回环验证的步骤。 4.2. 词袋模型词袋，也就是Bag-of-Words（BoW），目的是用“图像上有哪几种特征”来描述一个图像。字典中的单词，假设为w1、w2、w3。然后，对于任意图像A，根据它们含有的单词，可记为：字典是固定的，所以只要用[1 1 0]T 这个向量就可以表达A 的意义。通过字典和单词，只需一个向量就可以描述整张图像了。 同理，用[2 0 1]T 可以描述图像B。如果只考虑“是否出现”而不考虑数量的话，也可以是[1 0 1]T ，这时候这个向量就是二值的。于是，根据这两个向量，设计一定的计算方式，就能确定图像间的相似性了。当然如果对两个向量求差仍然有一些不同的做法，比如说对于a，b∈ RW，可以计算：其中范数取L1 范数，即各元素绝对值之和。请注意在两个向量完全一样时，我们将得到1；完全相反时（a 为0 的地方b 为1）得到0。这样就定义了两个描述向量的相似性，也就定义了图像之间的相似程度。 4.3. 字典创建4.3.1. K均值算法字典由很多单词组成，而每一个单词代表了一个概念。一个单词与一个单独的特征点不同，它不是从单个图像上提取出来的，而是某一类特征的组合。所以，字典生成问题类似于一个聚类问题。当我们有N 个特征点，想要归成k 个类，那么用K-means 来做，主要有以下几个步骤： 4.3.2. k叉树字典使用一种k叉树来表达字典。它的思路很简单，类似于层次聚类，是K-means的直接扩展。假定我们有N 个特征点，希望构建一个深度为d，每次分叉为k 的树，那么做法如下：实际上，最终我们仍在叶子层构建了单词，而树结构中的中间节点仅供快速查找时使用。这样一个k 分支，深度为d 的树，可以容纳kd个单词。另一方面，在查找某个给定特征对应的单词时，只需将它与每个中间结点的聚类中心比较（一共d 次），即可找到最后的单词，保证了对数级别的查找效率。 4.4. 相似度计算考虑权重以后，对于某个图像A，它的特征点可对应到许多个单词，组成它的Bag-of-Words： 对于给定的VA和VB，通过某些方式即可比较其相似度。如L1范数： 5. 建图所谓地图，即所有路标点的集合。一旦我们确定了路标点的位置，那就可以说我们完成了建图。SLAM 作为一种底层技术，往往是用来为上层应用提供信息的。应用层面对于“定位”的需求是相似的，他们希望SLAM 提供相机或搭载相机的主体的空间位姿信息。而对于地图，则存在着许多不同的需求。稀疏地图只建模感兴趣的部分，也就是前面说了很久的特征点（路标点）。稠密地图是指，建模所有看到过的部分。在稠密重建，我们需要知道每一个像素点（或大部分像素点）的距离，那么大致上有以下几种解决方案： 使用单目相机，利用移动相机之后进行三角化，测量像素的距离。 使用双目相机，利用左右目的视差计算像素的距离（多目原理相同）。 使用RGB-D 相机直接获得像素距离。前两种方式称为立体视觉（Stereo Vision），其中移动单目的又称为移动视角的立体视觉（Moving View Stereo）。相比于RGB-D 直接测量的深度，单目和双目对深度的获取往往是“费力不讨好”的——我们需要花费大量的计算，最后得到一些不怎么可靠的¬深度估计。当然，RGB-D 也有一些量程、应用范围和光照的限制，不过相比于单目和双目的结果，使用RGB-D 进行稠密重建往往是更常见的选择。而单目双目的好处，是在目前RGB-D还无法很好应用的室外、大场景场合中，仍能通过立体视觉估计深度信息。5.1. 单目稠密建图在稠密深度图估计中，我们无法把每个像素都当作特征点，计算描述子。因此，稠密深度估计问题中，匹配就成为很重要的一环：如何确定第一张图的某像素，出现在其他图里的位置呢？这需要用到极线搜索和块匹配技术。然后，当我们知道了某个像素在各个图中的位置，就能像特征点那样，利用三角测量确定它的深度。左边的相机观测到了某个像素p1。由于这是一个单目相机，我们无从知道它的深度，所以假设这个深度可能在某个区域之内，不妨说是某最小值到无穷远之间：(dmin，+∞)。因此，该像素对应的空间点就分布在某条线段（本例中是射线）上。在另一个视角（右侧相机）看来，这条线段的投影也形成图像平面上的一条线，我们知道这称为极线。在p1 周围取一个大小为w * w 的小块，然后在极线上也取很多同样大小的小块进行比较，就可以一定程度上提高区分性。这就是所谓的块匹配。然后计算小块与小块间的差异，存在很多计算方法，如它计算的是两个小块的相关性，接近0表示两个图像不相似，而接近1表示相似。5.2. RGB-D稠密建图除了使用单目和双目进行稠密重建之外，在适用范围内，RGB-D 相机是一种更好的选择。在RGB-D 相机中可以完全通过传感器中硬件测量得到深度，无需消耗大量的计算资源来估计它们。并且，RGB-D 的结构光或飞时原理，保证了深度数据对纹理的无关性。即使面对纯色的物体，只要它能够反射光，我们就能测量到它的深度。这亦是RGB-D 传感器的一大优势。 利用RGB-D 进行稠密建图是相对容易的。不过，根据地图形式不同，也存在着若干种不同的主流建图方式。最直观最简单的方法，就是根据估算的相机位姿，将RGB-D 数据转化为点云（Point Cloud），然后进行拼接，最后得到一个由离散的点组成的点云地图（Point Cloud Map）。在此基础上，如果我们对外观有进一步的要求，希望估计物体的表面，可以使用三角网格（Mesh），面片（Surfel）进行建图。另一方面，如果希望知道地图的障碍物信息并在地图上导航，亦可通过体素（Voxel）建立占据网格地图（Occupancy Map）。","categories":[],"tags":[]},{"title":"《DeepLearning with Python》读书笔记（一）","slug":"《DeepLearning with Python》读书笔记（一）","date":"2020-03-05T04:55:01.501Z","updated":"2020-03-05T04:55:08.534Z","comments":true,"path":"2020/03/05/《DeepLearning with Python》读书笔记（一）/","link":"","permalink":"http://yoursite.com/2020/03/05/%E3%80%8ADeepLearning%20with%20Python%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"1.什么是深度学习![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217185528695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =800x) 三张图理解深度学习工作原理神经网络中每层对输入数据所做的具体操作保存在该层的权重（weight）中，其本质是一串数字。用术语来说，每层实现的变换由其权重来参数化（parameterize，见图 1-7）。权重有时也被称为该层的参数（parameter）。在这种语境下，学习的意思是为神经网络的所有层找到一组权重值，使得该网络能够将每个示例输入与其目标正确地一一对应。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217190131517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =500x)想要控制一件事物，首先需要能够观察它。想要控制神经网络的输出，就需要能够衡量该输出与预期值之间的距离。这是神经网络损失函数（loss function）的任务，该函数也叫目标函数（objective function）。损失函数的输入是网络预测值与真实目标值（即你希望网络输出的结果），然后计算一个距离值，衡量该网络在这个示例上的效果好坏![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217190500415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x)深度学习的基本技巧是利用这个距离值作为反馈信号来对权重值进行微调，以降低当前示 例对应的损失值（见图 1-9）。这种调节由优化器（optimizer）来完成，它实现了所谓的反向 传播（backpropagation）算法，这是深度学习的核心算法。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217194424145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW53ZW5ibzY2NjY=,size_16,color_FFFFFF,t_70#pic_center =400x)一开始对神经网络的权重随机赋值，因此网络只是实现了一系列随机变换。其输出结果自然也和理想值相去甚远，相应地，损失值也很高。但随着网络处理的示例越来越多，权重值也 在向正确的方向逐步微调，损失值也逐渐降低。这就是训练循环（training loop），将这种循环重复足够多的次数（通常对数千个示例进行数十次迭代），得到的权重值可以使损失函数最小。具有最小损失的网络，其输出值与目标值尽可能地接近，这就是训练好的网络。再次强调，这是一个简单的机制，一旦具有足够大的规模，将会产生魔法般的效果。 2.神经网络的数学基础2.2 神经网络的数据表示数据存储在多维 Numpy 数组中，也叫张量（tensor）。一般来说，当前所 有机器学习系统都使用张量作为基本数据结构。张量对这个领域非常重要，重要到 Google 的 TensorFlow 都以它来命名。那么什么是张量？ 张量这一概念的核心在于，它是一个数据容器。它包含的数据几乎总是数值数据，因此它 是数字的容器。你可能对矩阵很熟悉，它是二维张量。张量是矩阵向任意维度的推广［注意， 张量的维度（dimension）通常叫作轴（axis）］。 2.2.1标量（0D张量）仅包含一个数字的张量叫作标量（scalar，也叫标量张量、零维张量、0D 张量）。在 Numpy 中，一个 float32 或 float64 的数字就是一个标量张量（或标量数组）。标量张量有 0 个轴。张量轴的个数也叫作 阶（rank）。 2.2.2向量（1D张量）数字组成的数组叫作向量（vector）或一维张量（1D 张量）。一维张量只有一个轴。下面是一个 Numpy 向量。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200217202516264.png#pic_center =300x)这个向量有 5 个元素，所以被称为 5D 向量。不要把 5D 向量和 5D 张量弄混！ 5D 向量只 有一个轴，沿着轴有 5 个维度，而 5D 张量有 5 个轴（沿着每个轴可能有任意个维度）。维度 （dimensionality）可以表示沿着某个轴上的元素个数（比如 5D 向量），也可以表示张量中轴的个 数（比如 5D 张量），这有时会令人感到混乱。对于后一种情况，技术上更准确的说法是 5 阶张量 （张量的阶数即轴的个数），但 5D 张量这种模糊的写法更常见。 2.2.3 矩阵（2D张量）向量组成的数组叫作矩阵（matrix）或二维张量（2D 张量）。矩阵有 2 个轴（通常叫作行和列）。 2.2.4 3D 张量与更高维张量将多个矩阵组合成一个新的数组，可以得到一个 3D 张量，你可以将其直观地理解为数字组成的立方体。将多个 3D 张量组合成一个数组，可以创建一个 4D 张量，以此类推。深度学习处理的一般是 0D 到 4D 的张量，但处理视频数据时可能会遇到 5D 张量。 2.2.5 关键属性张量是由以下三个关键属性来定义的。 轴的个数（阶）。例如，3D 张量有 3 个轴，矩阵有 2 个轴。这在 Numpy 等 Python 库中也叫张量的 ndim。 形状。这是一个整数元组，表示张量沿每个轴的维度大小（元素个数）。例如，前面矩阵示例的形状为 (3, 5)，3D 张量示例的形状为 (3, 3, 5)。向量的形状只包含一个元素，比如 (5,)，而标量的形状为空，即 ()。 数据类型（在 Python 库中通常叫作 dtype）。这是张量中所包含数据的类型，例如，张量的类型可以是 float32、uint8、float64 等。在极少数情况下，你可能会遇到字符（char）张量。注意，Numpy（以及大多数其他库）中不存在字符串张量，因为张量存储在预先分配的连续内存段中，而字符串的长度是可变的，无法用这种方式存储。2.2.6 在 Numpy 中操作张量我们使用语法 train_images[i] 来选择沿着第一个轴的特定数字。选择张量的特定元素叫作张量切片（tensor slicing）2.2.7 数据批量的概念通常来说，深度学习中所有数据张量的第一个轴（0 轴，因为索引从 0 开始）都是样本轴（samples axis，有时也叫样本维度）。在 MNIST 的例子中，样本就是数字图像。 此外，深度学习模型不会同时处理整个数据集，而是将数据拆分成小批量。具体来看，下面是 MNIST 数据集的一个批量，批量大小为 128。对于这种批量张量，第一个轴（0 轴）叫作批量轴（batch axis）或批量维度（batch dimension）。在使用 Keras 和其他深度学习库时，你会经常遇到这个术语。 2.2.8 现实世界中的数据张量我们用几个你未来会遇到的示例来具体介绍数据张量。你需要处理的数据几乎总是以下类别之一。 2.2.9 向量数据这是最常见的数据。对于这种数据集，每个数据点都被编码为一个向量，因此一个数据批量就被编码为 2D 张量（即向量组成的数组），其中第一个轴是样本轴，第二个轴是特征轴。 例如，人口统计数据集，其中包括每个人的年龄、邮编和收入。每个人可以表示为包含 3 个值的向量，而整个数据集包含 100 000 个人，因此可以存储在形状为 (100000, 3) 的 2D张量中。 2.2.10 时间序列数据或序列数据当时间（或序列顺序）对于数据很重要时，应该将数据存储在带有时间轴的 3D 张量中。每个样本可以被编码为一个向量序列（即 2D 张量），因此一个数据批量就被编码为一个 3D 张量（见图 2-3）。根据惯例，时间轴始终是第 2 个轴（索引为 1 的轴）。例如，股票价格数据集。每一分钟，我们将股票的当前价格、前一分钟的最高价格和前一分钟的最低价格保存下来。因此每分钟被编码为一个 3D 向量，整个交易日被编码为一个形状为 (390, 3) 的 2D 张量（一个交易日有 390 分钟），而 250 天的数据则可以保存在一个形状为 (250, 390, 3) 的 3D 张量中。这里每个样本是一天的股票数据。 2.2.11 图像数据图像通常具有三个维度：高度、宽度和颜色深度。虽然灰度图像（比如 MNIST 数字图像） 只有一个颜色通道，因此可以保存在 2D 张量中，但按照惯例，图像张量始终都是 3D 张量，灰 度图像的彩色通道只有一维。因此，如果图像大小为 256×256，那么 128 张灰度图像组成的批 量可以保存在一个形状为 (128, 256, 256, 1) 的张量中，而 128 张彩色图像组成的批量则 可以保存在一个形状为 (128, 256, 256, 3) 的张量中（见图 2-4）。 图像张量的形状有两种约定：通道在后（channels-last）的约定（在 TensorFlow 中使用）和 通道在前（channels-first）的约定（在 Theano 中使用）。Google 的 TensorFlow 机器学习框架将 颜色深度轴放在最后：(samples, height, width, color_depth)。与此相反，Theano 将图像深度轴放在批量轴之后：(samples, color_depth, height, width)。如果采 用 Theano 约定，前面的两个例子将变成 (128, 1, 256, 256) 和 (128, 3, 256, 256)。 Keras 框架同时支持这两种格式。 2.2.12 视频数据视频数据是现实生活中需要用到 5D 张量的少数数据类型之一。视频可以看作一系列帧， 每一帧都是一张彩色图像。由于每一帧都可以保存在一个形状为 (height, width, color_ depth) 的 3D 张量中，因此一系列帧可以保存在一个形状为 (frames, height, width, color_depth) 的 4D 张量中，而不同视频组成的批量则可以保存在一个 5D 张量中，其形状为 (samples, frames, height, width, color_depth)。 举个例子，一个以每秒 4 帧采样的 60 秒 YouTube 视频片段，视频尺寸为 144×256，这个 视频共有 240 帧。4 个这样的视频片段组成的批量将保存在形状为 (4, 240, 144, 256, 3) 的张量中。总共有 106 168 320 个值！如果张量的数据类型（dtype）是 float32，每个值都是 32 位，那么这个张量共有 405MB。好大！你在现实生活中遇到的视频要小得多，因为它们不以 float32 格式存储，而且通常被大大压缩，比如 MPEG 格式。 2.3 神经网络的“齿轮”：张量运算2.3.6 深度学习的几何解释前面讲过，神经网络完全由一系列张量运算组成，而这些张量运算都只是输入数据的几何变换。因此，你可以将神经网络解释为高维空间中非常复杂的几何变换，这种变换可以通过许多简单的步骤来实现。 对于三维的情况，下面这个思维图像是很有用的。想象有两张彩纸：一张红色，一张蓝色。将其中一张纸放在另一张上。现在将两张纸一起揉成小球。这个皱巴巴的纸球就是你的输入数据，每张纸对应于分类问题中的一个类别。神经网络（或者任何机器学习模型）要做的就是找到可以让纸球恢复平整的变换，从而能够再次让两个类别明确可分。通过深度学习，这一过程可以用三维空间中一系列简单的变换来实现，比如你用手指对纸球做的变换，每次做一个动作，如图 2-9 所示。让纸球恢复平整就是机器学习的内容：为复杂的、高度折叠的数据流形找到简洁的表示。现在你应该能够很好地理解，为什么深度学习特别擅长这一点：它将复杂的几何变换逐步分解为一长串基本的几何变换，这与人类展开纸球所采取的策略大致相同。深度网络的每一层都通过变换使数据解开一点点——许多层堆叠在一起，可以实现非常复杂的解开过程。 2.4 神经网络的“引擎”：基于梯度的优化4.机器学习基础4.1 机器学习的四个分支监督学习 监督学习是目前最常见的机器学习类型。给定一组样本（通常由人工标注），它可以学会将输入数据映射到已知目标［也叫标注（annotation）］。一般来说，近年来广受关注的深度学习应用几乎都属于监督学习，比如光学字符识别、语音识别、图像分类和语言翻译。虽然监督学习主要包括分类和回归，但还有更多的奇特变体，主要包括如下几种。 序列生成（sequence generation）。给定一张图像，预测描述图像的文字。序列生成有时可以被重新表示为一系列分类问题，比如反复预测序列中的单词或标记。 语法树预测（syntax tree prediction）。给定一个句子，预测其分解生成的语法树。 目标检测（object detection）。给定一张图像，在图中特定目标的周围画一个边界框。这个问题也可以表示为分类问题（给定多个候选边界框，对每个框内的目标进行分类）或分类与回归联合问题（用向量回归来预测边界框的坐标）。 图像分割（image segmentation）。给定一张图像，在特定物体上画一个像素级的掩模（mask）。 无监督学习 无监督学习是指在没有目标的情况下寻找输入数据的有趣变换，其目的在于数据可视化、数据压缩、数据去噪或更好地理解数据中的相关性。无监督学习是数据分析的必备技能，在解决监督学习问题之前，为了更好地了解数据集，它通常是一个必要步骤。降维（dimensionalityreduction）和聚类（clustering）都是众所周知的无监督学习方法。 自监督学习自监督学习是监督学习的一个特例，它与众不同，值得单独归为一类。自监督学习是没有 人工标注的标签的监督学习，你可以将它看作没有人类参与的监督学习。标签仍然存在（因为 总要有什么东西来监督学习过程），但它们是从输入数据中生成的，通常是使用启发式算法生 成的。 举个例子，自编码器（autoencoder）是有名的自监督学习的例子，其生成的目标就是未经 修改的输入。同样，给定视频中过去的帧来预测下一帧，或者给定文本中前面的词来预测下一个词， 都是自监督学习的例子［这两个例子也属于时序监督学习（temporally supervised learning），即用 未来的输入数据作为监督］。注意，监督学习、自监督学习和无监督学习之间的区别有时很模糊， 这三个类别更像是没有明确界限的连续体。自监督学习可以被重新解释为监督学习或无监督学 习，这取决于你关注的是学习机制还是应用场景。 强化学习 强化学习一直以来被人们所忽视，但最近随着 Google 的 DeepMind 公司将其成功应用于学 习玩 Atari 游戏（以及后来学习下围棋并达到最高水平），机器学习的这一分支开始受到大量关注。 在强化学习中，智能体（agent）接收有关其环境的信息，并学会选择使某种奖励最大化的行动。 例如，神经网络会“观察”视频游戏的屏幕并输出游戏操作，目的是尽可能得高分，这种神经 网络可以通过强化学习来训练。 分类和回归术语表分类和回归都包含很多专业术语。这些术语在机器学习领域都有确切的定义，你应该了解这些定义。 样本（sample）或输入（input）：进入模型的数据点。 预测（prediction）或输出（output）：从模型出来的结果。 目标（target）：真实值。对于外部数据源，理想情况下，模型应该能够预测出目标。 预测误差（prediction error）或损失值（loss value）：模型预测与目标之间的距离。 类别（class）：分类问题中供选择的一组标签。例如，对猫狗图像进行分类时，“狗”和“猫”就是两个类别。 标签（label）：分类问题中类别标注的具体例子。比如，如果 1234 号图像被标注为包含类别“狗”，那么“狗”就是 1234 号图像的标签。 真值（ground-truth）或标注（annotation）：数据集的所有目标，通常由人工收集。 二分类（binary classification）：一种分类任务，每个输入样本都应被划分到两个互斥的类别中。 多分类（multiclass classification）：一种分类任务，每个输入样本都应被划分到两个以上的类别中，比如手写数字分类。 多标签分类（multilabel classification）：一种分类任务，每个输入样本都可以分配多个标签。举个例子，如果一幅图像里可能既有猫又有狗，那么应该同时标注“猫”标签和“狗”标签。每幅图像的标签个数通常是可变的。 标量回归（scalar regression）：目标是连续标量值的任务。预测房价就是一个很好的例子，不同的目标价格形成一个连续的空间。 向量回归（vector regression）：目标是一组连续值（比如一个连续向量）的任务。如果对多个值（比如图像边界框的坐标）进行回归，那就是向量回归。 小批量（mini-batch）或批量（batch）：模型同时处理的一小部分样本（样本数通常为 8~128）。样本数通常取 2 的幂，这样便于 GPU 上的内存分配。训练时，小批量用来为模型权重计算一次梯度下降更新。 5.深度学习用于计算机视觉5.1 卷积神经网络简介5.1.1 卷积运算密集连接层和卷积层的根本区别在于，Dense 层从输入特征空间中学到的是全局模式,比如对于 MNIST 数字，全局模式就是涉及所有像素的模式），而卷积层学到的是局部模式（见 图 5-1），对于图像来说，学到的就是在输入图像的二维小窗口中发现的模式。在上面的例子中， 这些窗口的大小都是 3×3。这个重要特性使卷积神经网络具有以下两个有趣的性质。 卷积神经网络学到的模式具有平移不变性（translation invariant）。卷积神经网络在图像 右下角学到某个模式之后，它可以在任何地方识别这个模式，比如左上角。对于密集连 接网络来说，如果模式出现在新的位置，它只能重新学习这个模式。这使得卷积神经网 络在处理图像时可以高效利用数据（因为视觉世界从根本上具有平移不变性），它只需 要更少的训练样本就可以学到具有泛化能力的数据表示。 卷积神经网络可以学到模式的空间层次结构（spatial hierarchies of patterns），见图 5-2。 第一个卷积层将学习较小的局部模式（比如边缘），第二个卷积层将学习由第一层特征 组成的更大的模式，以此类推。这使得卷积神经网络可以有效地学习越来越复杂、越来 越抽象的视觉概念（因为视觉世界从根本上具有空间层次结构）。在 MNIST 示例中，第一个卷积层接收一个大小为 (28, 28, 1) 的特征图，并输出一个大 小为 (26, 26, 32) 的特征图，即它在输入上计算 32 个过滤器。对于这 32 个输出通道，每个 通道都包含一个 26×26 的数值网格，它是过滤器对输入的响应图（response map），表示这个过 滤器模式在输入中不同位置的响应（见图 5-3）。这也是特征图这一术语的含义：深度轴的每个 维度都是一个特征（或过滤器），而 2D 张量 output[:, :, n] 是这个过滤器在输入上的响应 的二维空间图（map）。卷积由以下两个关键参数所定义。 从输入中提取的图块尺寸：这些图块的大小通常是 3×3 或 5×5。本例中为 3×3，这是很常见的选择。 输出特征图的深度：卷积所计算的过滤器的数量。本例第一层的深度为 32，最后一层的深度是 64。 卷积的工作原理：在 3D 输入特征图上滑动（slide）这些 3×3 或 5×5 的窗口，在每个可能 的位置停止并提取周围特征的 3D 图块［形状为 (window_height, window_width, input_ depth)］。然后每个 3D 图块与学到的同一个权重矩阵［叫作卷积核（convolution kernel）］做 张量积，转换成形状为 (output_depth,) 的 1D 向量。然后对所有这些向量进行空间重组， 使其转换为形状为 (height, width, output_depth) 的 3D 输出特征图。输出特征图中的 每个空间位置都对应于输入特征图中的相同位置（比如输出的右下角包含了输入右下角的信 息）。举个例子，利用 3×3 的窗口，向量 output[i, j, :] 来自 3D 图块 input[i-1:i+1, j-1:j+1, :]。整个过程详见下图 。注意，输出的宽度和高度可能与输入的宽度和高度不同。不同的原因可能有两点。 边界效应，可以通过对输入特征图进行填充来抵消。 使用了步幅（stride），稍后会给出其定义。 填充如果你希望输出特征图的空间维度与输入相同，那么可以使用填充（padding）。填充是在输入特征图的每一边添加适当数目的行和列，使得每个输入方块都能作为卷积窗口的中心。对于 3×3 的窗口，在左右各添加一列，在上下各添加一行。对于 5×5 的窗口，各添加两行和两列（见图 5-6）。对于 Conv2D 层，可以通过 padding 参数来设置填充，这个参数有两个取值：”valid” 表示不使用填充（只使用有效的窗口位置）；”same” 表示“填充后输出的宽度和高度与输入相同”。padding 参数的默认值为 “valid”。 卷积步幅两个连续窗口的距离是卷积的一个参数，叫作步幅，默认值为 1。也可以使用步进卷积（strided convolution），即步幅大于 1 的卷积。在图 5-7 中，你可以看到用步幅为 2 的 3×3 卷积从 5×5 输入中提取的图块（无填充）。 5.1.2 最大池化运算最大池化的作用：对特征图进行下采样，与步进卷积类似。最大池化是从输入特征图中提取窗口，并输出每个通道的最大值。它的概念与卷积类似，但是最大池化使用硬编码的 max 张量运算对局部图块进行变换，而不是使用学到的线性变换（卷积核）。最大池化与卷积的最大不同之处在于，最大池化通常使用 2×2 的窗口和步幅 2，其目的是将特征图下采样 2 倍。与此相对的是，卷积通常使用 3×3 窗口和步幅 1。 简而言之，使用下采样的原因，一是减少需要处理的特征图的元素个数，二是通过让连续 卷积层的观察窗口越来越大（即窗口覆盖原始输入的比例越来越大），从而引入空间过滤器的层 级结构。 注意，最大池化不是实现这种下采样的唯一方法。你已经知道，还可以在前一个卷积层中 使用步幅来实现。此外，你还可以使用平均池化来代替最大池化，其方法是将每个局部输入图 块变换为取该图块各通道的平均值，而不是最大值。但最大池化的效果往往比这些替代方法更好。 简而言之，原因在于特征中往往编码了某种模式或概念在特征图的不同位置是否存在（因此得 名特征图），而观察不同特征的最大值而不是平均值能够给出更多的信息。因此，最合理的子采 样策略是首先生成密集的特征图（通过无步进的卷积），然后观察特征每个小图块上的最大激活， 而不是查看输入的稀疏窗口（通过步进卷积）或对输入图块取平均，因为后两种方法可能导致 错过或淡化特征是否存在的信息。 5.3.3 小结 卷积神经网络是用于计算机视觉任务的最佳机器学习模型。即使在非常小的数据集上也可以从头开始训练一个卷积神经网络，而且得到的结果还不错。 在小型数据集上的主要问题是过拟合。在处理图像数据时，数据增强是一种降低过拟合的强大方法。 利用特征提取，可以很容易将现有的卷积神经网络复用于新的数据集。对于小型图像数据集，这是一种很有价值的方法。 作为特征提取的补充，你还可以使用微调，将现有模型之前学到的一些数据表示应用于新问题。这种方法可以进一步提高模型性能。 现在你已经拥有一套可靠的工具来处理图像分类问题，特别是对于小型数据集。 9.2 深度学习的局限性深度学习模型只是将一个向量空间映射到另一个向量空间的简单而又连续的几何 变换链。它能做的只是将一个数据流形 X 映射到另一个流形 Y，前提是从 X 到 Y 存在可学习的 连续变换。深度学习模型可以被看作一种程序，但反过来说，大多数程序都不能被表示为深度 学习模型。对于大多数任务而言，要么不存在相应的深度神经网络能够解决任务，要么即使存 在这样的网络，它也可能是不可学习的（learnable）。后一种情况的原因可能是相应的几何变换 过于复杂，也可能是没有合适的数据用于学习。 通过堆叠更多的层并使用更多训练数据来扩展当前的深度学习技术，只能在表面上缓解一 些问题，无法解决更根本的问题，比如深度学习模型可以表示的内容非常有限，比如大多数你 想要学习的程序都不能被表示为数据流形的连续几何变形。 简而言之，深度学习模型并不理解它们的输入，至少不是人类所说的理解。我们自己对图 像、声音和语言的理解是基于我们作为人类的感觉运动体验。机器学习模型无法获得这些体验， 因此也就无法用与人类相似的方式来理解它们的输入。通过对输入模型的大量训练样本进行标 记，我们可以让模型学会一个简单几何变换，这个变换在一组特定样本上将数据映射到人类概念， 但这种映射只是我们头脑中原始模型的简化。我们头脑中的原始模型是从我们作为具身主体的 体验发展而来的。机器学习模型就像是镜子中的模糊图像（见图 9-3）。","categories":[],"tags":[]},{"title":"Linux备忘录","slug":"Linux备忘录","date":"2020-03-05T04:54:34.452Z","updated":"2020-03-05T05:03:17.940Z","comments":true,"path":"2020/03/05/Linux备忘录/","link":"","permalink":"http://yoursite.com/2020/03/05/Linux%E5%A4%87%E5%BF%98%E5%BD%95/","excerpt":"","text":"Ubuntu备忘 指令 作用 Ctrl+h 或者 ls -a 显示隐藏文件 ls -l name.file 查看文件详细信息 cp source.file target.file -r 复制文件和目录 mv file1 file2 改名字 mv flie1 ~/a/b/file2 移动位置 file target.file 查看文件类型 less name.file 以bash手册的形式查看name.file的内容，支持空格、PageDown翻下页，PageUp翻上页，Enter翻下行，q退出。 touch name.file 若name.file不存在，则创建新文件；若name.file存在，则更新修改时间。 ps -ef 显示所有进程的扩展信息。 top 实时监控进程，按q退出,按d设置刷新间隔。 kill PID 关闭第PID个进程，程度弱，可能被忽略。 killall name* 强制关闭name开头的所有进程，谨慎使用，使用通配符*时可能关闭系统进程，损坏系统。 ×××××××××× ×××××××××××× sudo dpkg -i package.deb 安装软件包 sudo apt-get install -f 修复有问题的软件包的依赖项 grep netease-cloud-music 查看网易云音乐软件包是否已经安装 sudo apt-get remove netease-cloud-music 卸载网易云音乐 dpkg -l 显示所有安装了的软件包 ××××××××××××××× ××××××××××××××××××× 点击图标实现最小化应用 1gsettings set org.compiz.unityshell:/org/compiz/profiles/unity/plugins/unityshell/ launcher-minimize-window true vim备忘 指令 作用 Ctrl + f 向下翻整页 Ctrl + b 向上翻整页 - /etc/vim/vimrc vimrc是vim的配置文件 shell备忘 查看电脑有哪些shell 1cat /etc/shells ros备忘环境变量配置1echo \"source /opt/ros/kinetic/setup.bash\" &gt;&gt; ~/.bashrc source这个单词，代表驱寻找的意思，后面一长串/opt/ros/kinetic/setup.bash就是ROS本身工作空间环境变量配置脚本文件的路径，&gt;&gt; ~/.bashrc表示将这个环境变量配置脚本写到终端配置文件.bashrc中。 这里出现了一个新的文件，也就是终端配置文件.bashrc，这是我们打开的终端的一个配置文件，配置环境变量就相当于将工作空间的环境变量脚本，包括其路径，记录到这个终端配置文件.bashrc上。 1echo \"source /home/twb/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc 这个代码就是配置我们所创建的工作空间的环境变量，/home/twb/catkin_ws/devel/setup.bash这个是路径。.bashrc中增加内容如下查看一下现在ROS内部的环境变量有哪些 1echo $ROS_PACKAGE_PATH 结果如下：冒号前面是我自己创建的工作空间的路径，那个/src文件夹是专门存放源代码和功能包的。冒号后面是ROS本身工作空间下源代码和软件包所存放的文件夹的路径。 Python备忘 安装 anaconda 后Linux的终端界面前部出现（base）字样 1.打开一个终端 ，输入命令：vim ～/.bashrc2.在 .bashrc文件最后面添加命令：conda deactivate 再重新打开终端即可消除base字样","categories":[],"tags":[]},{"title":"Python基础知识学习","slug":"Python基础知识学习","date":"2020-03-05T04:52:30.825Z","updated":"2020-03-05T04:52:37.899Z","comments":true,"path":"2020/03/05/Python基础知识学习/","link":"","permalink":"http://yoursite.com/2020/03/05/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"1.Python历史 2.基础环境准备Python环境安装windows/macOS1.访问https://www.python.org/downloads/2.下载合适的版本。3.点击安装Linux1.多数系统自带2.找对应系统手册 Python运行交互界面 Jupyter 演示界面Ubuntu安装一个Jupyter包，也可以直接装anacondawindows安装anaconda出现以上结果表示Jupyter安装正确。 文件编辑和执行 3.基本语法 4.变量 5.算符和表达式 6.执行流控制执行流控制代码控制流的先后执行顺序。 7.函数 8.局部变量 9.作用域 10.参数默认值 11.返回值 12.lambda 13.模块 14.from import 15.模块预编译 16.main文件模式化写法 1234import sysfor name in dir(sys): if name.startswith('s') and name.endswith('e'): print(name) 17.内置数据结构","categories":[],"tags":[]},{"title":"改变生活方式从改善饮食习惯开始","slug":"改变生活方式从改善饮食习惯开始","date":"2020-03-05T04:51:33.118Z","updated":"2020-03-05T04:51:40.256Z","comments":true,"path":"2020/03/05/改变生活方式从改善饮食习惯开始/","link":"","permalink":"http://yoursite.com/2020/03/05/%E6%94%B9%E5%8F%98%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F%E4%BB%8E%E6%94%B9%E5%96%84%E9%A5%AE%E9%A3%9F%E4%B9%A0%E6%83%AF%E5%BC%80%E5%A7%8B/","excerpt":"","text":"减肥不是目的，改变饮食习惯才是1.戒掉所有含糖饮料和高热量垃圾食品（炸鸡、方便面等）2.去超市买任何食物前对比热量和营养价值表选购，了解自己都在吃些什么3.记录下每天吃的食物的总热量4.吃六七分饱就停筷，哪怕留着过一会儿饿了再吃也不能吃撑（坚决不吃自助）5.饿了就吃些黄瓜西红柿胡萝卜或者煮鸡蛋充饥6.尽量避免使用交通工具7.能爬楼梯就不要坐电梯8.能站着绝对不坐9.粗粮细粮搭配吃10.吃东西一口尽量咀嚼20次再咽下11.饭后半小时内站立或走动12.禁止一切夜宵13.用牛肉鱼肉鸡肉代替猪肉，猪肉是肉类中营养价值最低热量最高的14.社交活动是用茶代替一切饮品，因为是零卡15.保持每周三次的有氧运动","categories":[],"tags":[]}]}